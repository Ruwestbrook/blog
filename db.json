{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1585633272799},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1585633272800},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1585633272800},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1585633272801},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1585633272801},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1585633272820},{"_id":"source/_posts/Android下拉刷新.md","hash":"94e164c0ccbbfedae2e20b36db8ab46405fe1119","modified":1585633272781},{"_id":"source/_posts/Android动画插值器.md","hash":"0b316b8ffe8fd471ae43749d0dc91e3307373208","modified":1585633272782},{"_id":"source/_posts/Android属性动画.md","hash":"20820bc70df430760a5ffc4ce6662a0d13525865","modified":1585633272782},{"_id":"source/_posts/Android打包小记.md","hash":"b40dfcf9203fb0f90bf83244c36a3c2cc0111537","modified":1585633272783},{"_id":"source/_posts/Android视图动画.md","hash":"7c0d4678537118640756f3d27f9a17059e83b8f3","modified":1585633272783},{"_id":"source/_posts/Android通知使用.md","hash":"4a416c3ca54808b9249d661ae116238859982bbb","modified":1585633272784},{"_id":"source/_posts/IOS第三方库的之CocoaPods管理.md","hash":"e6d1c1fc1891e721c1a3b35cba7ac8454cce05e1","modified":1585633272785},{"_id":"source/_posts/HTTP想到哪儿写到哪儿.md","hash":"00da13e08bcf47a47f44cf476faae7b419470703","modified":1585633272784},{"_id":"source/_posts/Java面试.md","hash":"1f9376786caa1924a3685c799a27afb0d484bcba","modified":1585633272785},{"_id":"source/_posts/android-studio中文候选框不会跟随光标.md","hash":"412930330142e3e71ed5b76173d2b9f6a0be64cc","modified":1585633272786},{"_id":"source/_posts/androidt图片保存的坑.md","hash":"efe0c51f7f424a51a56d40321428d2afc0690056","modified":1585633272787},{"_id":"source/_posts/android中文字的绘制.md","hash":"3048c9e9d31c19c99962f9bff52fed209df99f60","modified":1585633272787},{"_id":"source/_posts/android路由.md","hash":"206cc1897b3205907ccc76ad49bb6936c65f0d23","modified":1585633272788},{"_id":"source/_posts/dataBinding使用小记.md","hash":"32dd723b63ce721735cbb7efcb08780f4b776df3","modified":1585633272788},{"_id":"source/_posts/kotlin学习笔记.md","hash":"d03c15a80e43f6afb92b3bdf2e7c621151f96d54","modified":1585633272789},{"_id":"source/_posts/nginx服务器搭建.md","hash":"3f054a1e58a798aa57d048a317a65863138ea0e2","modified":1585633272789},{"_id":"source/_posts/recyclerView分割线的源码阅读.md","hash":"f51899d23bfb20992c948e63965d8509c0a9cc37","modified":1585633272790},{"_id":"source/_posts/retrofit添加公共参数.md","hash":"8c7f54258c609e657254236e8820b11ea03d837b","modified":1585633272790},{"_id":"source/_posts/ubuntu服务器开启rewrite.md","hash":"a26508ea0949ef3b5369f090a3752cef95271bce","modified":1585633272790},{"_id":"source/_posts/xcode导入第三方库.md","hash":"18e12e1b1dbd638d0c796c9665092b8d3f30e72a","modified":1585633272790},{"_id":"source/_posts/你会用git吗.md","hash":"90ee71ab3c5fa8b352e7e56aeb7108cf1be37d19","modified":1585633272791},{"_id":"source/_posts/会换行的ViewGroup.md","hash":"b9bccec3d149123ca9c92ea32bd9357c37332780","modified":1585633272791},{"_id":"source/_posts/圆形View.md","hash":"3846f94f0c9dbb858bd0054c7b5377bebb00618b","modified":1585633272792},{"_id":"source/_posts/多种线程方式上传图片的区别.md","hash":"cae16cd659550d1593911ee1ea52f9a65d61d0cf","modified":1585633272792},{"_id":"source/_posts/开发艺术第一章笔记.md","hash":"6d9bda278562fe4f55d48a7c7cbd63fe9c3f13c0","modified":1585633272793},{"_id":"source/_posts/搭建自己的博客.md","hash":"100c56d18dc458a09fdefb466f5d0c06732836b8","modified":1585635883745},{"_id":"source/_posts/注意事项.md","hash":"4c774c1051f560a8936a40369ef0c1bace5b9e55","modified":1585633272794},{"_id":"source/about/index.md","hash":"e8aece2777bd22f468a49097f0a064a0f0295176","modified":1585633272795},{"_id":"source/_posts/生活趣事.md","hash":"de71ce2f53c5f6d5f08edb448d5e0dfd7cec1578","modified":1585633272795},{"_id":"source/_posts/自定义EditText.md","hash":"c8d065893a59b0d5a6015688428ea10d281d6b89","modified":1585638403792},{"_id":"source/categories/index.md","hash":"e5136e8ffe17850e18900ed6195214eb3e4ea094","modified":1585633272796},{"_id":"source/links/index.md","hash":"44574cd0aeef7599eedfc82a7d1eafb2f9340ea6","modified":1585633272797},{"_id":"source/repository/index.md","hash":"25ec76e6c1b15df70f941b231a403f2399499977","modified":1585633272798},{"_id":"source/tags/index.md","hash":"782f00db116672a38f684cc3e9af11d21734d580","modified":1585633272798},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1585633272802},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1585633272802},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1585633272803},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1585633272804},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1585633272803},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1585633272804},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1585633272805},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1585633272805},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1585633272805},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1585633272806},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1585633272806},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1585633272807},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1585633272818},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1585633272818},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1585633272818},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1585633272819},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1585633272819},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1585633272820},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1585633272820},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1585633272821},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1585633272807},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1585633272808},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1585633272809},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1585633272808},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1585633272809},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1585633272810},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1585633272810},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1585633272811},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1585633272811},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1585633272812},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1585633272815},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1585633272816},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1585633272816},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1585633272816},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1585633272817},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1585633272817},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1585633272822},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1585633272829},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1585633272838},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1585633272839},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1585633272839},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1585633272840},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1585633272841},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1585633272841},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1585633272841},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1585633272845},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1585633272846},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1585633272847},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1585633272847},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1585633272812},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1585633272813},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1585633272813},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1585633272814},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1585633272814},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1585633272814},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1585633272823},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1585633272823},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1585633272824},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1585633272824},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1585633272825},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1585633272825},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1585633272826},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1585633272826},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1585633272827},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1585633272827},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1585633272828},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1585633272828},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1585633272830},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1585633272831},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1585633272835},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1585633272842},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1585633272843},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1585633272843},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1585633272844},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1585633272844},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1585633272845},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1585633272834},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1585633272833},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1585633272838}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2019-03-05T02:17:20.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-03-05 10:17:20\n---\n","updated":"2020-03-31T05:41:12.795Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck8fkje8g000r9otsw1e9ims1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2019-03-05T02:16:39.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-05 10:16:39\n---\n","updated":"2020-03-31T05:41:12.796Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck8fkje8n000t9ots1mpehl4d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"links","date":"2019-03-05T02:17:28.000Z","_content":"","source":"links/index.md","raw":"---\ntitle: links\ndate: 2019-03-05 10:17:28\n---\n","updated":"2020-03-31T05:41:12.797Z","path":"links/index.html","comments":1,"layout":"page","_id":"ck8fkje8u000w9otsztc7q2rk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"repository","date":"2019-03-05T02:17:03.000Z","_content":"","source":"repository/index.md","raw":"---\ntitle: repository\ndate: 2019-03-05 10:17:03\n---\n","updated":"2020-03-31T05:41:12.798Z","path":"repository/index.html","comments":1,"layout":"page","_id":"ck8fkje8y000z9ots11k6ax43","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-03-05T02:16:48.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-05 10:16:48\n---\n","updated":"2020-03-31T05:41:12.798Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck8fkje9100129otsx86zxc9n","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android下拉刷新","date":"2018-10-30T13:35:38.000Z","_content":"下拉刷新永远是一个头痛的问题,本来是有官方的组件直接实现就好了,但是发现需求是需要实现一些动画的,那也只能自己设计了\n\n最初的想法是百度上找相似的然后稍微看懂改一下,发现最多的就是使用RecyclerView来做文章添加头部和尾部,但是实际使用下来来看,有以下缺点:\n\n1.添加之后使用adapter并不奏效,要使用RecyclerView.getAdapter()才可以,因为这里使用了装饰者模式,所以adapter并不是RecyclerView直接的适配器\n\n2.再给Recycler添加分割线的时候不好处理(也可能是我水平有限不知道怎么解决)\n\n所以就换了一种方式,直接自定义RefreshView继承LinearLayout,然后再这里面添加RecyclerView,当然,我还是想的太简单了\n\n\n最先思考的问题,如何判断RecyclerView在最顶部,只有其在最顶部的时候才能下拉刷新,总不能在其浏览到中时,往上滑动结果是刷新了列表\n\n其次RefreshView内部的OnTouchEvent事件无效(黑人问号脸)\n\n\n其实可以靠一个方法解决,RefreshView获取RecyclerView,然后给它添加onTouch事件,然后在里面也判断他是否头部在最前面就好了\n\n\n关于RefreshView内部的OnTouchEvent事件无效的问题:应该是onInterceptTouchEvent()拦截了传递给了子控件RecyclerView,不然RecyclerView滑动就无效了(应该好好看看这里了,以为自己懂了,其实一点不懂)\n\n\n\n\n问题一:滑动时冲突问题:当RefreshView在最顶部时,此时下拉刷新,但是同时RefreshView也会跟着滑动,想了很久,看了很久的代码,才发现,这个时候要把滑动事件拦截!! 也就是onTouch方法中返回true表示滑动事件已经被消费了,被自己蠢哭了\n","source":"_posts/Android下拉刷新.md","raw":"---\ntitle: Android下拉刷新\ndate: 2018-10-30 21:35:38\ntags:\n- android\n---\n下拉刷新永远是一个头痛的问题,本来是有官方的组件直接实现就好了,但是发现需求是需要实现一些动画的,那也只能自己设计了\n\n最初的想法是百度上找相似的然后稍微看懂改一下,发现最多的就是使用RecyclerView来做文章添加头部和尾部,但是实际使用下来来看,有以下缺点:\n\n1.添加之后使用adapter并不奏效,要使用RecyclerView.getAdapter()才可以,因为这里使用了装饰者模式,所以adapter并不是RecyclerView直接的适配器\n\n2.再给Recycler添加分割线的时候不好处理(也可能是我水平有限不知道怎么解决)\n\n所以就换了一种方式,直接自定义RefreshView继承LinearLayout,然后再这里面添加RecyclerView,当然,我还是想的太简单了\n\n\n最先思考的问题,如何判断RecyclerView在最顶部,只有其在最顶部的时候才能下拉刷新,总不能在其浏览到中时,往上滑动结果是刷新了列表\n\n其次RefreshView内部的OnTouchEvent事件无效(黑人问号脸)\n\n\n其实可以靠一个方法解决,RefreshView获取RecyclerView,然后给它添加onTouch事件,然后在里面也判断他是否头部在最前面就好了\n\n\n关于RefreshView内部的OnTouchEvent事件无效的问题:应该是onInterceptTouchEvent()拦截了传递给了子控件RecyclerView,不然RecyclerView滑动就无效了(应该好好看看这里了,以为自己懂了,其实一点不懂)\n\n\n\n\n问题一:滑动时冲突问题:当RefreshView在最顶部时,此时下拉刷新,但是同时RefreshView也会跟着滑动,想了很久,看了很久的代码,才发现,这个时候要把滑动事件拦截!! 也就是onTouch方法中返回true表示滑动事件已经被消费了,被自己蠢哭了\n","slug":"Android下拉刷新","published":1,"updated":"2020-03-31T05:41:12.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6400009ots1v2qb46j","content":"<p>下拉刷新永远是一个头痛的问题,本来是有官方的组件直接实现就好了,但是发现需求是需要实现一些动画的,那也只能自己设计了</p>\n<p>最初的想法是百度上找相似的然后稍微看懂改一下,发现最多的就是使用RecyclerView来做文章添加头部和尾部,但是实际使用下来来看,有以下缺点:</p>\n<p>1.添加之后使用adapter并不奏效,要使用RecyclerView.getAdapter()才可以,因为这里使用了装饰者模式,所以adapter并不是RecyclerView直接的适配器</p>\n<p>2.再给Recycler添加分割线的时候不好处理(也可能是我水平有限不知道怎么解决)</p>\n<p>所以就换了一种方式,直接自定义RefreshView继承LinearLayout,然后再这里面添加RecyclerView,当然,我还是想的太简单了</p>\n<p>最先思考的问题,如何判断RecyclerView在最顶部,只有其在最顶部的时候才能下拉刷新,总不能在其浏览到中时,往上滑动结果是刷新了列表</p>\n<p>其次RefreshView内部的OnTouchEvent事件无效(黑人问号脸)</p>\n<p>其实可以靠一个方法解决,RefreshView获取RecyclerView,然后给它添加onTouch事件,然后在里面也判断他是否头部在最前面就好了</p>\n<p>关于RefreshView内部的OnTouchEvent事件无效的问题:应该是onInterceptTouchEvent()拦截了传递给了子控件RecyclerView,不然RecyclerView滑动就无效了(应该好好看看这里了,以为自己懂了,其实一点不懂)</p>\n<p>问题一:滑动时冲突问题:当RefreshView在最顶部时,此时下拉刷新,但是同时RefreshView也会跟着滑动,想了很久,看了很久的代码,才发现,这个时候要把滑动事件拦截!! 也就是onTouch方法中返回true表示滑动事件已经被消费了,被自己蠢哭了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>下拉刷新永远是一个头痛的问题,本来是有官方的组件直接实现就好了,但是发现需求是需要实现一些动画的,那也只能自己设计了</p>\n<p>最初的想法是百度上找相似的然后稍微看懂改一下,发现最多的就是使用RecyclerView来做文章添加头部和尾部,但是实际使用下来来看,有以下缺点:</p>\n<p>1.添加之后使用adapter并不奏效,要使用RecyclerView.getAdapter()才可以,因为这里使用了装饰者模式,所以adapter并不是RecyclerView直接的适配器</p>\n<p>2.再给Recycler添加分割线的时候不好处理(也可能是我水平有限不知道怎么解决)</p>\n<p>所以就换了一种方式,直接自定义RefreshView继承LinearLayout,然后再这里面添加RecyclerView,当然,我还是想的太简单了</p>\n<p>最先思考的问题,如何判断RecyclerView在最顶部,只有其在最顶部的时候才能下拉刷新,总不能在其浏览到中时,往上滑动结果是刷新了列表</p>\n<p>其次RefreshView内部的OnTouchEvent事件无效(黑人问号脸)</p>\n<p>其实可以靠一个方法解决,RefreshView获取RecyclerView,然后给它添加onTouch事件,然后在里面也判断他是否头部在最前面就好了</p>\n<p>关于RefreshView内部的OnTouchEvent事件无效的问题:应该是onInterceptTouchEvent()拦截了传递给了子控件RecyclerView,不然RecyclerView滑动就无效了(应该好好看看这里了,以为自己懂了,其实一点不懂)</p>\n<p>问题一:滑动时冲突问题:当RefreshView在最顶部时,此时下拉刷新,但是同时RefreshView也会跟着滑动,想了很久,看了很久的代码,才发现,这个时候要把滑动事件拦截!! 也就是onTouch方法中返回true表示滑动事件已经被消费了,被自己蠢哭了</p>\n"},{"title":"Android动画插值器","date":"2018-11-13T06:30:03.000Z","_content":"animate都能设置Interpolator来控制动画的变化率\n\n下面图片展示了系统内置的九种插值器的对于同一个动画的影响效果\n\n![内置插值器演示](http://image.honglingqi.cn/blogImages/1113/1542092680973.gif)\n\n\n从下到下依次是:\n* AccelerateInterpolator:加速播放\n* DecelerateInterpolator:减速播放\n* LinearInterpolator:匀速播放\n* OvershootInterpolator:快速完成动画，超出再回到结束样式\n* AccelerateDecelerateInterpolator:先加速再减速\n* AnticipateInterpolator:先退后再加速前进\n* AnticipateOvershootInterpolator:先退后再加速前进，超出终点后再回终点\n* BounceInterpolator:最后阶段弹球效果\n* CycleInterpolator:周期运动(构造函数有参数float cycles 表示次数)\n\n也可以自己实现插值器:\n其实Interpolator是一个接口,如果需自定义Interpolator的话,只需要实现重写Interpolator的方法就可以了\n\n\n    @Override\n            public float getInterpolation(float input) {\n                return 0;\n            }\ngetInterpolation函数的float input代表动画的完成进度,0代表刚开始,1表示已结束,\n试着写了一个:\n\n\n     ScaleAnimation animation=new ScaleAnimation(1,3,1,3,\n                            1,0.5f,1,0.5f);\n                    animation.setDuration(1500);\n                    animation.setFillAfter(true);\n                    animation.setRepeatCount(0);\n                    animation.setInterpolator(new Interpolator() {\n                        @Override\n                        public float getInterpolation(float input) {\n                            return input-1;\n                        }\n                    });\n                    view.startAnimation(animation);\n缩放动画,从一倍放大到三倍,设置了自定义的Interpolator,返回值是input-1,结果出现了奇怪的东西:\n\n并没有像预想那样放大,而是先缩小到0再放大跟原来一样,Interpolator到底干了什么?\n仔细想了很久之后发现了变化的规律:因为这是变大的操作,所以倍数应该是1+(3-1)*(input-1),从一倍到三倍,\n所以在刚开始的时候input=0,其值变化规律是-1->0->1\n* 那么负数怎么计算呢?\n\n我的理解负数代表了和我们定义动画相反的顺序,在这个例子中我们需要的是变大,但是动画前段的变化是-1到0,那么就是从一倍变小到0倍\n,也就是消失不见,接着从0倍到一倍,逐渐变大\n\n为此从定义另外一个变小的动画来验证自己的猜想\n\n\n    ScaleAnimation animation=new ScaleAnimation(3,1,3,1,\n                            1,0.5f,1,0.5f);\n                    animation.setDuration(1500);\n                    animation.setFillAfter(true);\n                    animation.setRepeatCount(0);\n                    animation.setInterpolator(new Interpolator() {\n                        @Override\n                        public float getInterpolation(float input) {\n                            return input-1;\n                        }\n                    });\n                    view.startAnimation(animation);\n这是变小的操作,那么结合这个Interpolator,其值的变化应该是3-(3-1)*(input-1),从五倍变小到三倍\n\n\n![验证猜想](http://image.honglingqi.cn/blogImages/1113/1542099170983.gif)\n\n需要注意的是这里并没有改变Interpolator的速率,这里只是改变了变化规律,如果需要改变速率,那么需要更加复杂的数学函数去实现(好像全忘记了)\n","source":"_posts/Android动画插值器.md","raw":"---\ntitle: Android动画插值器\ndate: 2018-11-13 14:30:03\ntags:\n- android\n---\nanimate都能设置Interpolator来控制动画的变化率\n\n下面图片展示了系统内置的九种插值器的对于同一个动画的影响效果\n\n![内置插值器演示](http://image.honglingqi.cn/blogImages/1113/1542092680973.gif)\n\n\n从下到下依次是:\n* AccelerateInterpolator:加速播放\n* DecelerateInterpolator:减速播放\n* LinearInterpolator:匀速播放\n* OvershootInterpolator:快速完成动画，超出再回到结束样式\n* AccelerateDecelerateInterpolator:先加速再减速\n* AnticipateInterpolator:先退后再加速前进\n* AnticipateOvershootInterpolator:先退后再加速前进，超出终点后再回终点\n* BounceInterpolator:最后阶段弹球效果\n* CycleInterpolator:周期运动(构造函数有参数float cycles 表示次数)\n\n也可以自己实现插值器:\n其实Interpolator是一个接口,如果需自定义Interpolator的话,只需要实现重写Interpolator的方法就可以了\n\n\n    @Override\n            public float getInterpolation(float input) {\n                return 0;\n            }\ngetInterpolation函数的float input代表动画的完成进度,0代表刚开始,1表示已结束,\n试着写了一个:\n\n\n     ScaleAnimation animation=new ScaleAnimation(1,3,1,3,\n                            1,0.5f,1,0.5f);\n                    animation.setDuration(1500);\n                    animation.setFillAfter(true);\n                    animation.setRepeatCount(0);\n                    animation.setInterpolator(new Interpolator() {\n                        @Override\n                        public float getInterpolation(float input) {\n                            return input-1;\n                        }\n                    });\n                    view.startAnimation(animation);\n缩放动画,从一倍放大到三倍,设置了自定义的Interpolator,返回值是input-1,结果出现了奇怪的东西:\n\n并没有像预想那样放大,而是先缩小到0再放大跟原来一样,Interpolator到底干了什么?\n仔细想了很久之后发现了变化的规律:因为这是变大的操作,所以倍数应该是1+(3-1)*(input-1),从一倍到三倍,\n所以在刚开始的时候input=0,其值变化规律是-1->0->1\n* 那么负数怎么计算呢?\n\n我的理解负数代表了和我们定义动画相反的顺序,在这个例子中我们需要的是变大,但是动画前段的变化是-1到0,那么就是从一倍变小到0倍\n,也就是消失不见,接着从0倍到一倍,逐渐变大\n\n为此从定义另外一个变小的动画来验证自己的猜想\n\n\n    ScaleAnimation animation=new ScaleAnimation(3,1,3,1,\n                            1,0.5f,1,0.5f);\n                    animation.setDuration(1500);\n                    animation.setFillAfter(true);\n                    animation.setRepeatCount(0);\n                    animation.setInterpolator(new Interpolator() {\n                        @Override\n                        public float getInterpolation(float input) {\n                            return input-1;\n                        }\n                    });\n                    view.startAnimation(animation);\n这是变小的操作,那么结合这个Interpolator,其值的变化应该是3-(3-1)*(input-1),从五倍变小到三倍\n\n\n![验证猜想](http://image.honglingqi.cn/blogImages/1113/1542099170983.gif)\n\n需要注意的是这里并没有改变Interpolator的速率,这里只是改变了变化规律,如果需要改变速率,那么需要更加复杂的数学函数去实现(好像全忘记了)\n","slug":"Android动画插值器","published":1,"updated":"2020-03-31T05:41:12.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6d00019otsul171dw8","content":"<p>animate都能设置Interpolator来控制动画的变化率</p>\n<p>下面图片展示了系统内置的九种插值器的对于同一个动画的影响效果</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1113/1542092680973.gif\" alt=\"内置插值器演示\"></p>\n<p>从下到下依次是:</p>\n<ul>\n<li>AccelerateInterpolator:加速播放</li>\n<li>DecelerateInterpolator:减速播放</li>\n<li>LinearInterpolator:匀速播放</li>\n<li>OvershootInterpolator:快速完成动画，超出再回到结束样式</li>\n<li>AccelerateDecelerateInterpolator:先加速再减速</li>\n<li>AnticipateInterpolator:先退后再加速前进</li>\n<li>AnticipateOvershootInterpolator:先退后再加速前进，超出终点后再回终点</li>\n<li>BounceInterpolator:最后阶段弹球效果</li>\n<li>CycleInterpolator:周期运动(构造函数有参数float cycles 表示次数)</li>\n</ul>\n<p>也可以自己实现插值器:<br>其实Interpolator是一个接口,如果需自定义Interpolator的话,只需要实现重写Interpolator的方法就可以了</p>\n<pre><code>@Override\n        public float getInterpolation(float input) {\n            return 0;\n        }\n</code></pre><p>getInterpolation函数的float input代表动画的完成进度,0代表刚开始,1表示已结束,<br>试着写了一个:</p>\n<pre><code>ScaleAnimation animation=new ScaleAnimation(1,3,1,3,\n                       1,0.5f,1,0.5f);\n               animation.setDuration(1500);\n               animation.setFillAfter(true);\n               animation.setRepeatCount(0);\n               animation.setInterpolator(new Interpolator() {\n                   @Override\n                   public float getInterpolation(float input) {\n                       return input-1;\n                   }\n               });\n               view.startAnimation(animation);\n</code></pre><p>缩放动画,从一倍放大到三倍,设置了自定义的Interpolator,返回值是input-1,结果出现了奇怪的东西:</p>\n<p>并没有像预想那样放大,而是先缩小到0再放大跟原来一样,Interpolator到底干了什么?<br>仔细想了很久之后发现了变化的规律:因为这是变大的操作,所以倍数应该是1+(3-1)*(input-1),从一倍到三倍,<br>所以在刚开始的时候input=0,其值变化规律是-1-&gt;0-&gt;1</p>\n<ul>\n<li>那么负数怎么计算呢?</li>\n</ul>\n<p>我的理解负数代表了和我们定义动画相反的顺序,在这个例子中我们需要的是变大,但是动画前段的变化是-1到0,那么就是从一倍变小到0倍<br>,也就是消失不见,接着从0倍到一倍,逐渐变大</p>\n<p>为此从定义另外一个变小的动画来验证自己的猜想</p>\n<pre><code>ScaleAnimation animation=new ScaleAnimation(3,1,3,1,\n                        1,0.5f,1,0.5f);\n                animation.setDuration(1500);\n                animation.setFillAfter(true);\n                animation.setRepeatCount(0);\n                animation.setInterpolator(new Interpolator() {\n                    @Override\n                    public float getInterpolation(float input) {\n                        return input-1;\n                    }\n                });\n                view.startAnimation(animation);\n</code></pre><p>这是变小的操作,那么结合这个Interpolator,其值的变化应该是3-(3-1)*(input-1),从五倍变小到三倍</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1113/1542099170983.gif\" alt=\"验证猜想\"></p>\n<p>需要注意的是这里并没有改变Interpolator的速率,这里只是改变了变化规律,如果需要改变速率,那么需要更加复杂的数学函数去实现(好像全忘记了)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>animate都能设置Interpolator来控制动画的变化率</p>\n<p>下面图片展示了系统内置的九种插值器的对于同一个动画的影响效果</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1113/1542092680973.gif\" alt=\"内置插值器演示\"></p>\n<p>从下到下依次是:</p>\n<ul>\n<li>AccelerateInterpolator:加速播放</li>\n<li>DecelerateInterpolator:减速播放</li>\n<li>LinearInterpolator:匀速播放</li>\n<li>OvershootInterpolator:快速完成动画，超出再回到结束样式</li>\n<li>AccelerateDecelerateInterpolator:先加速再减速</li>\n<li>AnticipateInterpolator:先退后再加速前进</li>\n<li>AnticipateOvershootInterpolator:先退后再加速前进，超出终点后再回终点</li>\n<li>BounceInterpolator:最后阶段弹球效果</li>\n<li>CycleInterpolator:周期运动(构造函数有参数float cycles 表示次数)</li>\n</ul>\n<p>也可以自己实现插值器:<br>其实Interpolator是一个接口,如果需自定义Interpolator的话,只需要实现重写Interpolator的方法就可以了</p>\n<pre><code>@Override\n        public float getInterpolation(float input) {\n            return 0;\n        }\n</code></pre><p>getInterpolation函数的float input代表动画的完成进度,0代表刚开始,1表示已结束,<br>试着写了一个:</p>\n<pre><code>ScaleAnimation animation=new ScaleAnimation(1,3,1,3,\n                       1,0.5f,1,0.5f);\n               animation.setDuration(1500);\n               animation.setFillAfter(true);\n               animation.setRepeatCount(0);\n               animation.setInterpolator(new Interpolator() {\n                   @Override\n                   public float getInterpolation(float input) {\n                       return input-1;\n                   }\n               });\n               view.startAnimation(animation);\n</code></pre><p>缩放动画,从一倍放大到三倍,设置了自定义的Interpolator,返回值是input-1,结果出现了奇怪的东西:</p>\n<p>并没有像预想那样放大,而是先缩小到0再放大跟原来一样,Interpolator到底干了什么?<br>仔细想了很久之后发现了变化的规律:因为这是变大的操作,所以倍数应该是1+(3-1)*(input-1),从一倍到三倍,<br>所以在刚开始的时候input=0,其值变化规律是-1-&gt;0-&gt;1</p>\n<ul>\n<li>那么负数怎么计算呢?</li>\n</ul>\n<p>我的理解负数代表了和我们定义动画相反的顺序,在这个例子中我们需要的是变大,但是动画前段的变化是-1到0,那么就是从一倍变小到0倍<br>,也就是消失不见,接着从0倍到一倍,逐渐变大</p>\n<p>为此从定义另外一个变小的动画来验证自己的猜想</p>\n<pre><code>ScaleAnimation animation=new ScaleAnimation(3,1,3,1,\n                        1,0.5f,1,0.5f);\n                animation.setDuration(1500);\n                animation.setFillAfter(true);\n                animation.setRepeatCount(0);\n                animation.setInterpolator(new Interpolator() {\n                    @Override\n                    public float getInterpolation(float input) {\n                        return input-1;\n                    }\n                });\n                view.startAnimation(animation);\n</code></pre><p>这是变小的操作,那么结合这个Interpolator,其值的变化应该是3-(3-1)*(input-1),从五倍变小到三倍</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1113/1542099170983.gif\" alt=\"验证猜想\"></p>\n<p>需要注意的是这里并没有改变Interpolator的速率,这里只是改变了变化规律,如果需要改变速率,那么需要更加复杂的数学函数去实现(好像全忘记了)</p>\n"},{"title":"Android属性动画","date":"2018-11-14T02:11:14.000Z","_content":"\nAndroid动画一共分为两种,视图动画和属性动画,之前但是视图动画有局限性,他只能对View进行移动、缩放、旋转和淡入淡出操作,移动之后也只是\n改变了View的视图位置,并没有影响到它的属性,\n\n平移例子就很好的说明了这一点:View移动到了另一个位置,但是点击事件还是在原来的地方才能响应\n\n\n基于这些缺点,Android在Android3.0中推出了属性动画\n\n## ValueAnimator\n\n在我的理解上来说,这可能并不算是一个真正意义上的动画,他只是随着随着时间的进行来改变他的值,然后用这个值去改变某一些属性参数,\n虽然他有一个继承了setTarget()的方法,但是好像用不到?\n还是接上面的例子,我们想要实现的是不管View移动到哪里,他总是能响应点击事件,而不是在最初的位置才能响应事件\n\n首先创建ValueAnimator实例:\n\n\n    ValueAnimator valueAnimator=ValueAnimator.ofInt(200,300);\n    valueAnimator.setDuration(1500);\n这是最简单的构造ValueAnimator之一,代表一段数值的变化,从200-300,用时1500毫秒,变化的类型永远是int类型的\n参数代表的是变化区间,是一个可变参数,至少需要一个参数\n\n\n      valueAnimator.setTarget(view);\n      valueAnimator.start();\n然后你可能会这样用,但是运行了之后好像并不可以,因为ValueAnimator只是改变自己的值,并不会去控制其他的属性,所以我们在这个ValueAnimator\n设置一个监听器,监听它的值的变化:\n\n\n    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animation) {\n                            int value=(int)animation.getAnimatedValue();\n                            Log.d(TAG, \"onAnimationUpdate: \"+value);\n                        }\n                    });\n可以看到值一直在发生变化,拿到了这个之后,我们就可以开始模拟之前的平移动画了:用layout()来改变view的位置\n\n\n        //在onAnimationUpdate()添加layout()方法\n        final int x=view.getLeft();(这之前就获取到的)\n        view.layout(x+value,view.getTop(),x+value+view.getWidth(),view.getBottom());\n 这样也实现了View的移动,并且也实现了平移操作\n\n\n 除了ValueAnimator.ofInt()来构造ValueAnimator之外,还可以使用ValueAnimator.ofFloat();ValueAnimator.ofArgb(),是比较常用的,\n 我们也可以使用 ValueAnimator.ofObject()来自定义ValueAnimator返回的类型,其实在onAnimationUpdate中animation.getAnimatedValue()\n 返回的就是object类型的变量,这个时候我们就要自定义一个返回类型了 通过实现TypeEvaluator<T>接口来自定义返回类型\n\n    public class CharEvaluator implements TypeEvaluator<Character> {\n                @Override\n                public Character evaluate(float fraction, Character startValue, Character endValue) {\n                    return (char) (endValue-(1-fraction)*(endValue-startValue));\n                }\n上面就是一个自定义的TypeEvaluator返回的是char类型的字符float fraction代表了动画完成的进度,相当于插值器中的float input\n\n使用CharEvaluate\n\n    ValueAnimator animator=ObjectAnimator.ofObject(new CharEvaluator(), 'A', 'Z');\n\n\n## ObjectAnimator\n\nValueAnimator并不能直接的改变UI,而是在监听函数中动态的去设置相应的值,UI状态才能发生改变,但是只是改变View的某一个特定的值的话,采用ObjectAnimator无疑是更好的选择\nObjectAnimator继承自ValueAnimator,使用的方式也比ValueAnimator更加的简单:\n\n构造函数:\n\n        ObjectAnimator animator=ObjectAnimator ofInt(Object target, String propertyName, int... values)\n        target:需要设置动画的对象\n        propertyName:需要改变的属性名称\n        values:改变的值\n\nObjectAnimator的具体使用方法为:寻找target的setPropertyName()方法,然后将values设置进去\n例如我想把一个View的透明度从0变到1,使用ObjectAnimator:\n\n        ObjectAnimator animator=ObjectAnimator ofInt(view,\"alpha\", 0,1);\n\n然后再设置其他的属性就可以执行了\n\n只要设置的propertyName可以在target中找到setPropertyName()的方法的话,那么ObjectAnimator动画就可以执行\n\n        /**\n        动态的改变mImageView的top值,相当于改变其高度\n        **/\n        ObjectAnimator animator=ObjectAnimator.ofInt(mImageView,\"top\",500,200,500,400,900);\n\n\n\n*tips:如果当values只有一个值的时候,会调用getPropertyName()来获取起始值,values作为结束值\n\n\n## AnimatorSet\n\n当有多个动画需要同时使用的时候,AnimatorSet无疑是一个很好的选择:\n\n\n            ObjectAnimator animator1=ObjectAnimator ofInt(view,\"alpha\", 0,1);\n           ObjectAnimator animator2=ObjectAnimator.ofInt(mImageView,\"top\",500,200,500,400,900);\n           AnimatorSet animatorSet = new AnimatorSet();\n           //两个动画同时播放:\n           animatorSet.playTogether(animator1,animator2);\n           //依次播放\n           set.playSequentially(animator1,animator2);\n*tips:\n1. 每个动画可以单独设置target或者duration等属性,同时AnimatorSet也可以设置这些属性,如果AnimatorSet设置了之后单个动画的属性的就会失效\n1. 依次播放的动画会在这一个动画结束后才开始下一个,如果是无限播放,那么下一个将轮不到播放\n\n##  AnimatorSet.Builder\n\nAnimatorSet不能灵活控制单个动画的执行顺序 只能一起或者一次执行\n AnimatorSet.Builder 随意可以使用  setStartDelay针对单个动画  after之前播放 with 一起播放 before在之后播放\n 使用AnimatorSet.play()可以获取到AnimatorSet.Builder实例\n\n                   AnimatorSet set=new AnimatorSet();\n                 AnimatorSet.Builder builder=set.play(animator1).with(animator2).after(animator3);\n                animator1.setStartDelay(1500);\n                animator2.setStartDelay(1500);\n                set.setStartDelay(1500);\n                set.play(animator1).with(animator2);\n               set.setDuration(1500);\n\n\nAnimatorSet用xml表示\n\n        <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:ordering=\"together\">\n            <objectAnimator\n                android:valueFrom=\"0\"\n                android:valueTo=\"1\"\n                android:propertyName=\"alpha\"/>\n            <objectAnimator\n                android:valueFrom=\"0\"\n                android:valueTo=\"200\"\n                android:propertyName=\"top\"/>\n        </set>\n        android:orderin=sequentially || together 顺序播放或者一起播放\n","source":"_posts/Android属性动画.md","raw":"---\ntitle: Android属性动画\ndate: 2018-11-14 10:11:14\ntags:\n- android\n---\n\nAndroid动画一共分为两种,视图动画和属性动画,之前但是视图动画有局限性,他只能对View进行移动、缩放、旋转和淡入淡出操作,移动之后也只是\n改变了View的视图位置,并没有影响到它的属性,\n\n平移例子就很好的说明了这一点:View移动到了另一个位置,但是点击事件还是在原来的地方才能响应\n\n\n基于这些缺点,Android在Android3.0中推出了属性动画\n\n## ValueAnimator\n\n在我的理解上来说,这可能并不算是一个真正意义上的动画,他只是随着随着时间的进行来改变他的值,然后用这个值去改变某一些属性参数,\n虽然他有一个继承了setTarget()的方法,但是好像用不到?\n还是接上面的例子,我们想要实现的是不管View移动到哪里,他总是能响应点击事件,而不是在最初的位置才能响应事件\n\n首先创建ValueAnimator实例:\n\n\n    ValueAnimator valueAnimator=ValueAnimator.ofInt(200,300);\n    valueAnimator.setDuration(1500);\n这是最简单的构造ValueAnimator之一,代表一段数值的变化,从200-300,用时1500毫秒,变化的类型永远是int类型的\n参数代表的是变化区间,是一个可变参数,至少需要一个参数\n\n\n      valueAnimator.setTarget(view);\n      valueAnimator.start();\n然后你可能会这样用,但是运行了之后好像并不可以,因为ValueAnimator只是改变自己的值,并不会去控制其他的属性,所以我们在这个ValueAnimator\n设置一个监听器,监听它的值的变化:\n\n\n    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                        @Override\n                        public void onAnimationUpdate(ValueAnimator animation) {\n                            int value=(int)animation.getAnimatedValue();\n                            Log.d(TAG, \"onAnimationUpdate: \"+value);\n                        }\n                    });\n可以看到值一直在发生变化,拿到了这个之后,我们就可以开始模拟之前的平移动画了:用layout()来改变view的位置\n\n\n        //在onAnimationUpdate()添加layout()方法\n        final int x=view.getLeft();(这之前就获取到的)\n        view.layout(x+value,view.getTop(),x+value+view.getWidth(),view.getBottom());\n 这样也实现了View的移动,并且也实现了平移操作\n\n\n 除了ValueAnimator.ofInt()来构造ValueAnimator之外,还可以使用ValueAnimator.ofFloat();ValueAnimator.ofArgb(),是比较常用的,\n 我们也可以使用 ValueAnimator.ofObject()来自定义ValueAnimator返回的类型,其实在onAnimationUpdate中animation.getAnimatedValue()\n 返回的就是object类型的变量,这个时候我们就要自定义一个返回类型了 通过实现TypeEvaluator<T>接口来自定义返回类型\n\n    public class CharEvaluator implements TypeEvaluator<Character> {\n                @Override\n                public Character evaluate(float fraction, Character startValue, Character endValue) {\n                    return (char) (endValue-(1-fraction)*(endValue-startValue));\n                }\n上面就是一个自定义的TypeEvaluator返回的是char类型的字符float fraction代表了动画完成的进度,相当于插值器中的float input\n\n使用CharEvaluate\n\n    ValueAnimator animator=ObjectAnimator.ofObject(new CharEvaluator(), 'A', 'Z');\n\n\n## ObjectAnimator\n\nValueAnimator并不能直接的改变UI,而是在监听函数中动态的去设置相应的值,UI状态才能发生改变,但是只是改变View的某一个特定的值的话,采用ObjectAnimator无疑是更好的选择\nObjectAnimator继承自ValueAnimator,使用的方式也比ValueAnimator更加的简单:\n\n构造函数:\n\n        ObjectAnimator animator=ObjectAnimator ofInt(Object target, String propertyName, int... values)\n        target:需要设置动画的对象\n        propertyName:需要改变的属性名称\n        values:改变的值\n\nObjectAnimator的具体使用方法为:寻找target的setPropertyName()方法,然后将values设置进去\n例如我想把一个View的透明度从0变到1,使用ObjectAnimator:\n\n        ObjectAnimator animator=ObjectAnimator ofInt(view,\"alpha\", 0,1);\n\n然后再设置其他的属性就可以执行了\n\n只要设置的propertyName可以在target中找到setPropertyName()的方法的话,那么ObjectAnimator动画就可以执行\n\n        /**\n        动态的改变mImageView的top值,相当于改变其高度\n        **/\n        ObjectAnimator animator=ObjectAnimator.ofInt(mImageView,\"top\",500,200,500,400,900);\n\n\n\n*tips:如果当values只有一个值的时候,会调用getPropertyName()来获取起始值,values作为结束值\n\n\n## AnimatorSet\n\n当有多个动画需要同时使用的时候,AnimatorSet无疑是一个很好的选择:\n\n\n            ObjectAnimator animator1=ObjectAnimator ofInt(view,\"alpha\", 0,1);\n           ObjectAnimator animator2=ObjectAnimator.ofInt(mImageView,\"top\",500,200,500,400,900);\n           AnimatorSet animatorSet = new AnimatorSet();\n           //两个动画同时播放:\n           animatorSet.playTogether(animator1,animator2);\n           //依次播放\n           set.playSequentially(animator1,animator2);\n*tips:\n1. 每个动画可以单独设置target或者duration等属性,同时AnimatorSet也可以设置这些属性,如果AnimatorSet设置了之后单个动画的属性的就会失效\n1. 依次播放的动画会在这一个动画结束后才开始下一个,如果是无限播放,那么下一个将轮不到播放\n\n##  AnimatorSet.Builder\n\nAnimatorSet不能灵活控制单个动画的执行顺序 只能一起或者一次执行\n AnimatorSet.Builder 随意可以使用  setStartDelay针对单个动画  after之前播放 with 一起播放 before在之后播放\n 使用AnimatorSet.play()可以获取到AnimatorSet.Builder实例\n\n                   AnimatorSet set=new AnimatorSet();\n                 AnimatorSet.Builder builder=set.play(animator1).with(animator2).after(animator3);\n                animator1.setStartDelay(1500);\n                animator2.setStartDelay(1500);\n                set.setStartDelay(1500);\n                set.play(animator1).with(animator2);\n               set.setDuration(1500);\n\n\nAnimatorSet用xml表示\n\n        <set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:ordering=\"together\">\n            <objectAnimator\n                android:valueFrom=\"0\"\n                android:valueTo=\"1\"\n                android:propertyName=\"alpha\"/>\n            <objectAnimator\n                android:valueFrom=\"0\"\n                android:valueTo=\"200\"\n                android:propertyName=\"top\"/>\n        </set>\n        android:orderin=sequentially || together 顺序播放或者一起播放\n","slug":"Android属性动画","published":1,"updated":"2020-03-31T05:41:12.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6j00039otswkk7hwbn","content":"<p>Android动画一共分为两种,视图动画和属性动画,之前但是视图动画有局限性,他只能对View进行移动、缩放、旋转和淡入淡出操作,移动之后也只是<br>改变了View的视图位置,并没有影响到它的属性,</p>\n<p>平移例子就很好的说明了这一点:View移动到了另一个位置,但是点击事件还是在原来的地方才能响应</p>\n<p>基于这些缺点,Android在Android3.0中推出了属性动画</p>\n<h2 id=\"ValueAnimator\"><a href=\"#ValueAnimator\" class=\"headerlink\" title=\"ValueAnimator\"></a>ValueAnimator</h2><p>在我的理解上来说,这可能并不算是一个真正意义上的动画,他只是随着随着时间的进行来改变他的值,然后用这个值去改变某一些属性参数,<br>虽然他有一个继承了setTarget()的方法,但是好像用不到?<br>还是接上面的例子,我们想要实现的是不管View移动到哪里,他总是能响应点击事件,而不是在最初的位置才能响应事件</p>\n<p>首先创建ValueAnimator实例:</p>\n<pre><code>ValueAnimator valueAnimator=ValueAnimator.ofInt(200,300);\nvalueAnimator.setDuration(1500);\n</code></pre><p>这是最简单的构造ValueAnimator之一,代表一段数值的变化,从200-300,用时1500毫秒,变化的类型永远是int类型的<br>参数代表的是变化区间,是一个可变参数,至少需要一个参数</p>\n<pre><code>valueAnimator.setTarget(view);\nvalueAnimator.start();\n</code></pre><p>然后你可能会这样用,但是运行了之后好像并不可以,因为ValueAnimator只是改变自己的值,并不会去控制其他的属性,所以我们在这个ValueAnimator<br>设置一个监听器,监听它的值的变化:</p>\n<pre><code>valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                    @Override\n                    public void onAnimationUpdate(ValueAnimator animation) {\n                        int value=(int)animation.getAnimatedValue();\n                        Log.d(TAG, &quot;onAnimationUpdate: &quot;+value);\n                    }\n                });\n</code></pre><p>可以看到值一直在发生变化,拿到了这个之后,我们就可以开始模拟之前的平移动画了:用layout()来改变view的位置</p>\n<pre><code>//在onAnimationUpdate()添加layout()方法\nfinal int x=view.getLeft();(这之前就获取到的)\nview.layout(x+value,view.getTop(),x+value+view.getWidth(),view.getBottom());\n</code></pre><p> 这样也实现了View的移动,并且也实现了平移操作</p>\n<p> 除了ValueAnimator.ofInt()来构造ValueAnimator之外,还可以使用ValueAnimator.ofFloat();ValueAnimator.ofArgb(),是比较常用的,<br> 我们也可以使用 ValueAnimator.ofObject()来自定义ValueAnimator返回的类型,其实在onAnimationUpdate中animation.getAnimatedValue()<br> 返回的就是object类型的变量,这个时候我们就要自定义一个返回类型了 通过实现TypeEvaluator<t>接口来自定义返回类型</t></p>\n<pre><code>public class CharEvaluator implements TypeEvaluator&lt;Character&gt; {\n            @Override\n            public Character evaluate(float fraction, Character startValue, Character endValue) {\n                return (char) (endValue-(1-fraction)*(endValue-startValue));\n            }\n</code></pre><p>上面就是一个自定义的TypeEvaluator返回的是char类型的字符float fraction代表了动画完成的进度,相当于插值器中的float input</p>\n<p>使用CharEvaluate</p>\n<pre><code>ValueAnimator animator=ObjectAnimator.ofObject(new CharEvaluator(), &apos;A&apos;, &apos;Z&apos;);\n</code></pre><h2 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h2><p>ValueAnimator并不能直接的改变UI,而是在监听函数中动态的去设置相应的值,UI状态才能发生改变,但是只是改变View的某一个特定的值的话,采用ObjectAnimator无疑是更好的选择<br>ObjectAnimator继承自ValueAnimator,使用的方式也比ValueAnimator更加的简单:</p>\n<p>构造函数:</p>\n<pre><code>ObjectAnimator animator=ObjectAnimator ofInt(Object target, String propertyName, int... values)\ntarget:需要设置动画的对象\npropertyName:需要改变的属性名称\nvalues:改变的值\n</code></pre><p>ObjectAnimator的具体使用方法为:寻找target的setPropertyName()方法,然后将values设置进去<br>例如我想把一个View的透明度从0变到1,使用ObjectAnimator:</p>\n<pre><code>ObjectAnimator animator=ObjectAnimator ofInt(view,&quot;alpha&quot;, 0,1);\n</code></pre><p>然后再设置其他的属性就可以执行了</p>\n<p>只要设置的propertyName可以在target中找到setPropertyName()的方法的话,那么ObjectAnimator动画就可以执行</p>\n<pre><code>/**\n动态的改变mImageView的top值,相当于改变其高度\n**/\nObjectAnimator animator=ObjectAnimator.ofInt(mImageView,&quot;top&quot;,500,200,500,400,900);\n</code></pre><p>*tips:如果当values只有一个值的时候,会调用getPropertyName()来获取起始值,values作为结束值</p>\n<h2 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h2><p>当有多个动画需要同时使用的时候,AnimatorSet无疑是一个很好的选择:</p>\n<pre><code> ObjectAnimator animator1=ObjectAnimator ofInt(view,&quot;alpha&quot;, 0,1);\nObjectAnimator animator2=ObjectAnimator.ofInt(mImageView,&quot;top&quot;,500,200,500,400,900);\nAnimatorSet animatorSet = new AnimatorSet();\n//两个动画同时播放:\nanimatorSet.playTogether(animator1,animator2);\n//依次播放\nset.playSequentially(animator1,animator2);\n</code></pre><p>*tips:</p>\n<ol>\n<li>每个动画可以单独设置target或者duration等属性,同时AnimatorSet也可以设置这些属性,如果AnimatorSet设置了之后单个动画的属性的就会失效</li>\n<li>依次播放的动画会在这一个动画结束后才开始下一个,如果是无限播放,那么下一个将轮不到播放</li>\n</ol>\n<h2 id=\"AnimatorSet-Builder\"><a href=\"#AnimatorSet-Builder\" class=\"headerlink\" title=\"AnimatorSet.Builder\"></a>AnimatorSet.Builder</h2><p>AnimatorSet不能灵活控制单个动画的执行顺序 只能一起或者一次执行<br> AnimatorSet.Builder 随意可以使用  setStartDelay针对单个动画  after之前播放 with 一起播放 before在之后播放<br> 使用AnimatorSet.play()可以获取到AnimatorSet.Builder实例</p>\n<pre><code>    AnimatorSet set=new AnimatorSet();\n  AnimatorSet.Builder builder=set.play(animator1).with(animator2).after(animator3);\n animator1.setStartDelay(1500);\n animator2.setStartDelay(1500);\n set.setStartDelay(1500);\n set.play(animator1).with(animator2);\nset.setDuration(1500);\n</code></pre><p>AnimatorSet用xml表示</p>\n<pre><code>&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:ordering=&quot;together&quot;&gt;\n    &lt;objectAnimator\n        android:valueFrom=&quot;0&quot;\n        android:valueTo=&quot;1&quot;\n        android:propertyName=&quot;alpha&quot;/&gt;\n    &lt;objectAnimator\n        android:valueFrom=&quot;0&quot;\n        android:valueTo=&quot;200&quot;\n        android:propertyName=&quot;top&quot;/&gt;\n&lt;/set&gt;\nandroid:orderin=sequentially || together 顺序播放或者一起播放\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Android动画一共分为两种,视图动画和属性动画,之前但是视图动画有局限性,他只能对View进行移动、缩放、旋转和淡入淡出操作,移动之后也只是<br>改变了View的视图位置,并没有影响到它的属性,</p>\n<p>平移例子就很好的说明了这一点:View移动到了另一个位置,但是点击事件还是在原来的地方才能响应</p>\n<p>基于这些缺点,Android在Android3.0中推出了属性动画</p>\n<h2 id=\"ValueAnimator\"><a href=\"#ValueAnimator\" class=\"headerlink\" title=\"ValueAnimator\"></a>ValueAnimator</h2><p>在我的理解上来说,这可能并不算是一个真正意义上的动画,他只是随着随着时间的进行来改变他的值,然后用这个值去改变某一些属性参数,<br>虽然他有一个继承了setTarget()的方法,但是好像用不到?<br>还是接上面的例子,我们想要实现的是不管View移动到哪里,他总是能响应点击事件,而不是在最初的位置才能响应事件</p>\n<p>首先创建ValueAnimator实例:</p>\n<pre><code>ValueAnimator valueAnimator=ValueAnimator.ofInt(200,300);\nvalueAnimator.setDuration(1500);\n</code></pre><p>这是最简单的构造ValueAnimator之一,代表一段数值的变化,从200-300,用时1500毫秒,变化的类型永远是int类型的<br>参数代表的是变化区间,是一个可变参数,至少需要一个参数</p>\n<pre><code>valueAnimator.setTarget(view);\nvalueAnimator.start();\n</code></pre><p>然后你可能会这样用,但是运行了之后好像并不可以,因为ValueAnimator只是改变自己的值,并不会去控制其他的属性,所以我们在这个ValueAnimator<br>设置一个监听器,监听它的值的变化:</p>\n<pre><code>valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                    @Override\n                    public void onAnimationUpdate(ValueAnimator animation) {\n                        int value=(int)animation.getAnimatedValue();\n                        Log.d(TAG, &quot;onAnimationUpdate: &quot;+value);\n                    }\n                });\n</code></pre><p>可以看到值一直在发生变化,拿到了这个之后,我们就可以开始模拟之前的平移动画了:用layout()来改变view的位置</p>\n<pre><code>//在onAnimationUpdate()添加layout()方法\nfinal int x=view.getLeft();(这之前就获取到的)\nview.layout(x+value,view.getTop(),x+value+view.getWidth(),view.getBottom());\n</code></pre><p> 这样也实现了View的移动,并且也实现了平移操作</p>\n<p> 除了ValueAnimator.ofInt()来构造ValueAnimator之外,还可以使用ValueAnimator.ofFloat();ValueAnimator.ofArgb(),是比较常用的,<br> 我们也可以使用 ValueAnimator.ofObject()来自定义ValueAnimator返回的类型,其实在onAnimationUpdate中animation.getAnimatedValue()<br> 返回的就是object类型的变量,这个时候我们就要自定义一个返回类型了 通过实现TypeEvaluator<t>接口来自定义返回类型</t></p>\n<pre><code>public class CharEvaluator implements TypeEvaluator&lt;Character&gt; {\n            @Override\n            public Character evaluate(float fraction, Character startValue, Character endValue) {\n                return (char) (endValue-(1-fraction)*(endValue-startValue));\n            }\n</code></pre><p>上面就是一个自定义的TypeEvaluator返回的是char类型的字符float fraction代表了动画完成的进度,相当于插值器中的float input</p>\n<p>使用CharEvaluate</p>\n<pre><code>ValueAnimator animator=ObjectAnimator.ofObject(new CharEvaluator(), &apos;A&apos;, &apos;Z&apos;);\n</code></pre><h2 id=\"ObjectAnimator\"><a href=\"#ObjectAnimator\" class=\"headerlink\" title=\"ObjectAnimator\"></a>ObjectAnimator</h2><p>ValueAnimator并不能直接的改变UI,而是在监听函数中动态的去设置相应的值,UI状态才能发生改变,但是只是改变View的某一个特定的值的话,采用ObjectAnimator无疑是更好的选择<br>ObjectAnimator继承自ValueAnimator,使用的方式也比ValueAnimator更加的简单:</p>\n<p>构造函数:</p>\n<pre><code>ObjectAnimator animator=ObjectAnimator ofInt(Object target, String propertyName, int... values)\ntarget:需要设置动画的对象\npropertyName:需要改变的属性名称\nvalues:改变的值\n</code></pre><p>ObjectAnimator的具体使用方法为:寻找target的setPropertyName()方法,然后将values设置进去<br>例如我想把一个View的透明度从0变到1,使用ObjectAnimator:</p>\n<pre><code>ObjectAnimator animator=ObjectAnimator ofInt(view,&quot;alpha&quot;, 0,1);\n</code></pre><p>然后再设置其他的属性就可以执行了</p>\n<p>只要设置的propertyName可以在target中找到setPropertyName()的方法的话,那么ObjectAnimator动画就可以执行</p>\n<pre><code>/**\n动态的改变mImageView的top值,相当于改变其高度\n**/\nObjectAnimator animator=ObjectAnimator.ofInt(mImageView,&quot;top&quot;,500,200,500,400,900);\n</code></pre><p>*tips:如果当values只有一个值的时候,会调用getPropertyName()来获取起始值,values作为结束值</p>\n<h2 id=\"AnimatorSet\"><a href=\"#AnimatorSet\" class=\"headerlink\" title=\"AnimatorSet\"></a>AnimatorSet</h2><p>当有多个动画需要同时使用的时候,AnimatorSet无疑是一个很好的选择:</p>\n<pre><code> ObjectAnimator animator1=ObjectAnimator ofInt(view,&quot;alpha&quot;, 0,1);\nObjectAnimator animator2=ObjectAnimator.ofInt(mImageView,&quot;top&quot;,500,200,500,400,900);\nAnimatorSet animatorSet = new AnimatorSet();\n//两个动画同时播放:\nanimatorSet.playTogether(animator1,animator2);\n//依次播放\nset.playSequentially(animator1,animator2);\n</code></pre><p>*tips:</p>\n<ol>\n<li>每个动画可以单独设置target或者duration等属性,同时AnimatorSet也可以设置这些属性,如果AnimatorSet设置了之后单个动画的属性的就会失效</li>\n<li>依次播放的动画会在这一个动画结束后才开始下一个,如果是无限播放,那么下一个将轮不到播放</li>\n</ol>\n<h2 id=\"AnimatorSet-Builder\"><a href=\"#AnimatorSet-Builder\" class=\"headerlink\" title=\"AnimatorSet.Builder\"></a>AnimatorSet.Builder</h2><p>AnimatorSet不能灵活控制单个动画的执行顺序 只能一起或者一次执行<br> AnimatorSet.Builder 随意可以使用  setStartDelay针对单个动画  after之前播放 with 一起播放 before在之后播放<br> 使用AnimatorSet.play()可以获取到AnimatorSet.Builder实例</p>\n<pre><code>    AnimatorSet set=new AnimatorSet();\n  AnimatorSet.Builder builder=set.play(animator1).with(animator2).after(animator3);\n animator1.setStartDelay(1500);\n animator2.setStartDelay(1500);\n set.setStartDelay(1500);\n set.play(animator1).with(animator2);\nset.setDuration(1500);\n</code></pre><p>AnimatorSet用xml表示</p>\n<pre><code>&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:ordering=&quot;together&quot;&gt;\n    &lt;objectAnimator\n        android:valueFrom=&quot;0&quot;\n        android:valueTo=&quot;1&quot;\n        android:propertyName=&quot;alpha&quot;/&gt;\n    &lt;objectAnimator\n        android:valueFrom=&quot;0&quot;\n        android:valueTo=&quot;200&quot;\n        android:propertyName=&quot;top&quot;/&gt;\n&lt;/set&gt;\nandroid:orderin=sequentially || together 顺序播放或者一起播放\n</code></pre>"},{"title":"Android打包小记","date":"2019-03-04T06:01:03.000Z","_content":"\n1. 压缩图片来减小apk体积,压缩地址:https://tinypng.com/\n\n2. 减少支持的SO库构架,一般都有:armeabi-v7a,armeabi,armeabi-v8a,X86, 'mips', 'mips64'不用全部选择,\n然后如果SDK中需要那就没有办法(这个方法最减少apk体积)\n\n3. 适配全面屏:\nAndroidManifest.xml中application加入:\n```\n    android:resizeableActivity=\"true\"\n```\n的属性,然后加入:\n\n```\n<meta-data\n        android:name=\"max_aspect\"\n        android:value=\"2.1\"/>\n```\n\n4. dex突破65535的限制:在build.app中加入\n```\n  multiDexEnabled true\n```\n5.移除无用的resource文件(release常见配置)\n```\nbuildTypes {\n\n       debug {\n        .\n        .\n        .\n        .\n       }\n\n       release {\n           // 不显示Log\n           buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n           // 是否混淆\n           minifyEnabled true\n           // zipAlign优化\n           zipAlignEnabled true\n           // 移除无用的resource文件\n           shrinkResources true\n           .\n           .\n           .\n           .\n\n       }\n   }\n```\n\nPS:删除无效代码实际并不能有效的减少APK体积\n","source":"_posts/Android打包小记.md","raw":"---\ntitle: Android打包小记\ndate: 2019-03-04 14:01:03\ntags:\n- android\n---\n\n1. 压缩图片来减小apk体积,压缩地址:https://tinypng.com/\n\n2. 减少支持的SO库构架,一般都有:armeabi-v7a,armeabi,armeabi-v8a,X86, 'mips', 'mips64'不用全部选择,\n然后如果SDK中需要那就没有办法(这个方法最减少apk体积)\n\n3. 适配全面屏:\nAndroidManifest.xml中application加入:\n```\n    android:resizeableActivity=\"true\"\n```\n的属性,然后加入:\n\n```\n<meta-data\n        android:name=\"max_aspect\"\n        android:value=\"2.1\"/>\n```\n\n4. dex突破65535的限制:在build.app中加入\n```\n  multiDexEnabled true\n```\n5.移除无用的resource文件(release常见配置)\n```\nbuildTypes {\n\n       debug {\n        .\n        .\n        .\n        .\n       }\n\n       release {\n           // 不显示Log\n           buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n           // 是否混淆\n           minifyEnabled true\n           // zipAlign优化\n           zipAlignEnabled true\n           // 移除无用的resource文件\n           shrinkResources true\n           .\n           .\n           .\n           .\n\n       }\n   }\n```\n\nPS:删除无效代码实际并不能有效的减少APK体积\n","slug":"Android打包小记","published":1,"updated":"2020-03-31T05:41:12.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6l00049otswda27hcf","content":"<ol>\n<li><p>压缩图片来减小apk体积,压缩地址:<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com/</a></p>\n</li>\n<li><p>减少支持的SO库构架,一般都有:armeabi-v7a,armeabi,armeabi-v8a,X86, ‘mips’, ‘mips64’不用全部选择,<br>然后如果SDK中需要那就没有办法(这个方法最减少apk体积)</p>\n</li>\n<li><p>适配全面屏:<br>AndroidManifest.xml中application加入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:resizeableActivity=&quot;true&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>的属性,然后加入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">        android:name=&quot;max_aspect&quot;</span><br><span class=\"line\">        android:value=&quot;2.1&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>dex突破65535的限制:在build.app中加入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multiDexEnabled true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.移除无用的resource文件(release常见配置)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       debug &#123;</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       release &#123;</span><br><span class=\"line\">           // 不显示Log</span><br><span class=\"line\">           buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;</span><br><span class=\"line\">           // 是否混淆</span><br><span class=\"line\">           minifyEnabled true</span><br><span class=\"line\">           // zipAlign优化</span><br><span class=\"line\">           zipAlignEnabled true</span><br><span class=\"line\">           // 移除无用的resource文件</span><br><span class=\"line\">           shrinkResources true</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>PS:删除无效代码实际并不能有效的减少APK体积</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>压缩图片来减小apk体积,压缩地址:<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">https://tinypng.com/</a></p>\n</li>\n<li><p>减少支持的SO库构架,一般都有:armeabi-v7a,armeabi,armeabi-v8a,X86, ‘mips’, ‘mips64’不用全部选择,<br>然后如果SDK中需要那就没有办法(这个方法最减少apk体积)</p>\n</li>\n<li><p>适配全面屏:<br>AndroidManifest.xml中application加入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:resizeableActivity=&quot;true&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>的属性,然后加入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">        android:name=&quot;max_aspect&quot;</span><br><span class=\"line\">        android:value=&quot;2.1&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>dex突破65535的限制:在build.app中加入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multiDexEnabled true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.移除无用的resource文件(release常见配置)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       debug &#123;</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">        .</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       release &#123;</span><br><span class=\"line\">           // 不显示Log</span><br><span class=\"line\">           buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;</span><br><span class=\"line\">           // 是否混淆</span><br><span class=\"line\">           minifyEnabled true</span><br><span class=\"line\">           // zipAlign优化</span><br><span class=\"line\">           zipAlignEnabled true</span><br><span class=\"line\">           // 移除无用的resource文件</span><br><span class=\"line\">           shrinkResources true</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\">           .</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>PS:删除无效代码实际并不能有效的减少APK体积</p>\n"},{"title":"Android视图动画","date":"2018-11-04T13:13:16.000Z","_content":"### 1.1补间动画\n\n共分为四种\n\n1.改变View的透明度 AlphaAnimation\n\n   因为只是改变View的透明度,所以它的属性并不是很多只有fromAlpha和toAlpha\n   fromAlpha:初始的alpha的值,\n   toAlpha:结束时alpha的值\n\n\n* 代码实现:\n\n\n    AlphaAnimation alphaAnimation =new AlphaAnimation(float fromAlpha, float toAlpha)\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:toAlpha=\"1.0\"\n        android:fromAlpha=\"0.1\"/>\n\n\n下面三个因为会改变View的位置或者大小或者形状,因此需要确定一个中心去确定如何执行动画\n\n\n\n2.scale:改变View的大小:\n\n int pivotXType   int pivotYType :对于动画执行的XY坐标的位置,原点都是View的左上角\n  有三个值可以使用:\n  * Animation.ABSOLUTE :坐标的绝对值,原点是View的左上角 ,X、Y的数值代表实际多少像素\n  * Animation.RELATIVE_TO_SELF:坐标相对于自己来说,X、Y的数值代表自己的width,height的倍数\n  * Animation.RELATIVE_TO_PARENT.坐标相对于父View来说,X、Y的数值代表父View的width,height的倍数\n\n  float pivotXValue float pivotYValue:对于动画执行XY坐标的距离\n\n   - float fromX:初始X的大小,百分比\n   - float toX:结束时X的大小,百分比\n   - float fromY:初始Y的大小,百分比\n   - float toY:结束时Y的大小,百分比\n\n* 代码实现:\n\n\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY)\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY,\n                                                 float toY,float pivotX, float pivotY)\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY,\n                                              int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE -->\n    <!--为百分比时代表RELATIVE_TO_SELF -->\n    <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n    <scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:pivotY=\"\"\n        android:pivotX=\"\"\n        android:fromXScale=\"\"\n        android:fromYScale=\"\"\n        android:toXScale=\"\"\n        android:toYScale=\"\" />\n\n\n3.改变View的位置(平移操作)\nint fromXType,int toXType int fromYType, int toYType:含义跟Scale的int pivotXType,int pivotYType相同\n float fromXValue, float toXValue,float fromYValue,  float toYValue:XY方向上平移的距离\n\n* 代码实现:\n\n\n    TranslateAnimation animation=new TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)\n    TranslateAnimation animation=new TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,\n                                                     int fromYType, float fromYValue, int toYType, float toYValue)\n\n* xml实现\n\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <!--fromXDelta,fromYDelta,toXDelta,toYDelta为数值时代表-->\n    <!--为百分比时代表RELATIVE_TO_SELF -->\n    <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n    <translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:fromXDelta=\"100\"\n        android:fromYDelta=\"100\"\n        android:toXDelta=\"100\"\n        android:toYDelta=\"100\"/>\n\n4.旋转View\n\nint pivotXType, float pivotXValue,int pivotYType, float pivotYValue:四个数值的参数和Scale相同,代表围绕某一个点旋转\n\nfloat fromDegrees:起始角度\nfloat toDegrees:结束角度\n\n* 代码实现:\n\n\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees)\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,\n                                                    int pivotYType, float pivotYValue)\n* xml实现:\n\n\n\n     <?xml version=\"1.0\" encoding=\"utf-8\"?>\n     <!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE -->\n     <!--为百分比时代表RELATIVE_TO_SELF -->\n     <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n     <rotate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n         android:pivotX=\"\"\n         android:pivotY=\"\"\n         android:fromDegrees=\"\"\n         android:toDegrees=\"\"/>\n\n\n 5.这种动画可以同时使用,用AnimationSet\n\n * 代码实现:\n\n\n    AnimationSet set=new AnimationSet(boolean shareInterpolator)//shareInterpolator代表是否动画使用同一个插值器\n    void addAnimation(Animation a) 来增加动画个数\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <rotate/>\n        <scale/>\n        <translate/>\n        <alpha/>\n    </set>\n\n Animation有一些通用的方法:\n\n* setDuration(long durationMillis)  //设置动画的时间 毫秒为单位\n\n* setRepeatCount(int repeatCount)//设置动画的重复次数 如果设置成-1或者小于-1(Animation.INFINITE)代表无限循环\n\n* setRepeatMode(int repeatMode)//设置动画重复的模式 1(Animation.RESTART)代表回放 2(Animation.REVERSE)代表倒叙回放\n\n* setFillAfter(boolean fillAfter) //设置动画是否保存结束后的状态\n\n* setFillBefore(boolean fillBefore)//设置动画是否保存开始时的状态\n\n* setFillEnabled(boolean fillEnabled)//设置动画是否保存开始时的状态\n\n* setAnimationListener(AnimationListener)     //设置动画监听\n其中AnimationListener是一个接口:\n\n\n     public static interface AnimationListener {\n                    //动画开始时调用\n                    void onAnimationStart(Animation animation);\n                    //动画结束时调用     \n                    void onAnimationEnd(Animation animation);\n                    //动画重复时调用\n                    void onAnimationRepeat(Animation animation);\n                }\n\n\nxml中通用属性:\n\n      android:duration=\"1000\"   \n      android:repeatCount=\"-1\"\n      android:repeatMode=\"[\"reverse\"  \"restart\"]\"\n      android:fillBefore=\"[\"true\"  \"false\"]\"\n      android:fillAfter=\"[\"true\"  \"false\"]\"\n      android:fillEnabled=\"[\"true\"  \"false\"]\"\n\n### 1.2 逐帧动画\n\n顾名思义就是动画一帧一帧的播放,那么就需要每一帧的图片资源\n\n* 代码实现:\n\n\n      AnimationDrawable drawable=new AnimationDrawable();\n            for (int i = 0; i < 14; i++) {\n            Drawable drawable1=getResources().getDrawable(R.drawable.id);\n             drawable.addFrame(drawable1,60);\n            }\n       drawable.setOneShot(false);\n\n* void addFrame(Drawable frame, int duration) //添加帧数,并且设置帧数的持续时间\n* void setOneShot(boolean oneShot)//true表示重复播放 false表示只播放一次\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=\"[\"true\"  \"false\"]\">\n        <!--每一帧都要设置一个item-->\n        <item android:drawable=\"\" android:duration=\"\"/>\n    </animation-list>\n","source":"_posts/Android视图动画.md","raw":"---\ntitle: Android视图动画\ndate: 2018-11-04 21:13:16\ntags:\n- android\n---\n### 1.1补间动画\n\n共分为四种\n\n1.改变View的透明度 AlphaAnimation\n\n   因为只是改变View的透明度,所以它的属性并不是很多只有fromAlpha和toAlpha\n   fromAlpha:初始的alpha的值,\n   toAlpha:结束时alpha的值\n\n\n* 代码实现:\n\n\n    AlphaAnimation alphaAnimation =new AlphaAnimation(float fromAlpha, float toAlpha)\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:toAlpha=\"1.0\"\n        android:fromAlpha=\"0.1\"/>\n\n\n下面三个因为会改变View的位置或者大小或者形状,因此需要确定一个中心去确定如何执行动画\n\n\n\n2.scale:改变View的大小:\n\n int pivotXType   int pivotYType :对于动画执行的XY坐标的位置,原点都是View的左上角\n  有三个值可以使用:\n  * Animation.ABSOLUTE :坐标的绝对值,原点是View的左上角 ,X、Y的数值代表实际多少像素\n  * Animation.RELATIVE_TO_SELF:坐标相对于自己来说,X、Y的数值代表自己的width,height的倍数\n  * Animation.RELATIVE_TO_PARENT.坐标相对于父View来说,X、Y的数值代表父View的width,height的倍数\n\n  float pivotXValue float pivotYValue:对于动画执行XY坐标的距离\n\n   - float fromX:初始X的大小,百分比\n   - float toX:结束时X的大小,百分比\n   - float fromY:初始Y的大小,百分比\n   - float toY:结束时Y的大小,百分比\n\n* 代码实现:\n\n\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY)\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY,\n                                                 float toY,float pivotX, float pivotY)\n    ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY,\n                                              int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE -->\n    <!--为百分比时代表RELATIVE_TO_SELF -->\n    <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n    <scale xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:pivotY=\"\"\n        android:pivotX=\"\"\n        android:fromXScale=\"\"\n        android:fromYScale=\"\"\n        android:toXScale=\"\"\n        android:toYScale=\"\" />\n\n\n3.改变View的位置(平移操作)\nint fromXType,int toXType int fromYType, int toYType:含义跟Scale的int pivotXType,int pivotYType相同\n float fromXValue, float toXValue,float fromYValue,  float toYValue:XY方向上平移的距离\n\n* 代码实现:\n\n\n    TranslateAnimation animation=new TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)\n    TranslateAnimation animation=new TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,\n                                                     int fromYType, float fromYValue, int toYType, float toYValue)\n\n* xml实现\n\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <!--fromXDelta,fromYDelta,toXDelta,toYDelta为数值时代表-->\n    <!--为百分比时代表RELATIVE_TO_SELF -->\n    <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n    <translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:fromXDelta=\"100\"\n        android:fromYDelta=\"100\"\n        android:toXDelta=\"100\"\n        android:toYDelta=\"100\"/>\n\n4.旋转View\n\nint pivotXType, float pivotXValue,int pivotYType, float pivotYValue:四个数值的参数和Scale相同,代表围绕某一个点旋转\n\nfloat fromDegrees:起始角度\nfloat toDegrees:结束角度\n\n* 代码实现:\n\n\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees)\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)\n    RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,\n                                                    int pivotYType, float pivotYValue)\n* xml实现:\n\n\n\n     <?xml version=\"1.0\" encoding=\"utf-8\"?>\n     <!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE -->\n     <!--为百分比时代表RELATIVE_TO_SELF -->\n     <!--百分比后面加一个p代表RELATIVE_TO_PARENT-->\n     <rotate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n         android:pivotX=\"\"\n         android:pivotY=\"\"\n         android:fromDegrees=\"\"\n         android:toDegrees=\"\"/>\n\n\n 5.这种动画可以同时使用,用AnimationSet\n\n * 代码实现:\n\n\n    AnimationSet set=new AnimationSet(boolean shareInterpolator)//shareInterpolator代表是否动画使用同一个插值器\n    void addAnimation(Animation a) 来增加动画个数\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <set xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <rotate/>\n        <scale/>\n        <translate/>\n        <alpha/>\n    </set>\n\n Animation有一些通用的方法:\n\n* setDuration(long durationMillis)  //设置动画的时间 毫秒为单位\n\n* setRepeatCount(int repeatCount)//设置动画的重复次数 如果设置成-1或者小于-1(Animation.INFINITE)代表无限循环\n\n* setRepeatMode(int repeatMode)//设置动画重复的模式 1(Animation.RESTART)代表回放 2(Animation.REVERSE)代表倒叙回放\n\n* setFillAfter(boolean fillAfter) //设置动画是否保存结束后的状态\n\n* setFillBefore(boolean fillBefore)//设置动画是否保存开始时的状态\n\n* setFillEnabled(boolean fillEnabled)//设置动画是否保存开始时的状态\n\n* setAnimationListener(AnimationListener)     //设置动画监听\n其中AnimationListener是一个接口:\n\n\n     public static interface AnimationListener {\n                    //动画开始时调用\n                    void onAnimationStart(Animation animation);\n                    //动画结束时调用     \n                    void onAnimationEnd(Animation animation);\n                    //动画重复时调用\n                    void onAnimationRepeat(Animation animation);\n                }\n\n\nxml中通用属性:\n\n      android:duration=\"1000\"   \n      android:repeatCount=\"-1\"\n      android:repeatMode=\"[\"reverse\"  \"restart\"]\"\n      android:fillBefore=\"[\"true\"  \"false\"]\"\n      android:fillAfter=\"[\"true\"  \"false\"]\"\n      android:fillEnabled=\"[\"true\"  \"false\"]\"\n\n### 1.2 逐帧动画\n\n顾名思义就是动画一帧一帧的播放,那么就需要每一帧的图片资源\n\n* 代码实现:\n\n\n      AnimationDrawable drawable=new AnimationDrawable();\n            for (int i = 0; i < 14; i++) {\n            Drawable drawable1=getResources().getDrawable(R.drawable.id);\n             drawable.addFrame(drawable1,60);\n            }\n       drawable.setOneShot(false);\n\n* void addFrame(Drawable frame, int duration) //添加帧数,并且设置帧数的持续时间\n* void setOneShot(boolean oneShot)//true表示重复播放 false表示只播放一次\n\n* xml实现:\n\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <animation-list\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        android:oneshot=\"[\"true\"  \"false\"]\">\n        <!--每一帧都要设置一个item-->\n        <item android:drawable=\"\" android:duration=\"\"/>\n    </animation-list>\n","slug":"Android视图动画","published":1,"updated":"2020-03-31T05:41:12.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6n00059ots0yo11mwe","content":"<h3 id=\"1-1补间动画\"><a href=\"#1-1补间动画\" class=\"headerlink\" title=\"1.1补间动画\"></a>1.1补间动画</h3><p>共分为四种</p>\n<p>1.改变View的透明度 AlphaAnimation</p>\n<p>   因为只是改变View的透明度,所以它的属性并不是很多只有fromAlpha和toAlpha<br>   fromAlpha:初始的alpha的值,<br>   toAlpha:结束时alpha的值</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AlphaAnimation alphaAnimation =new AlphaAnimation(float fromAlpha, float toAlpha)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:toAlpha=&quot;1.0&quot;\n    android:fromAlpha=&quot;0.1&quot;/&gt;\n</code></pre><p>下面三个因为会改变View的位置或者大小或者形状,因此需要确定一个中心去确定如何执行动画</p>\n<p>2.scale:改变View的大小:</p>\n<p> int pivotXType   int pivotYType :对于动画执行的XY坐标的位置,原点都是View的左上角<br>  有三个值可以使用:</p>\n<ul>\n<li>Animation.ABSOLUTE :坐标的绝对值,原点是View的左上角 ,X、Y的数值代表实际多少像素</li>\n<li>Animation.RELATIVE_TO_SELF:坐标相对于自己来说,X、Y的数值代表自己的width,height的倍数</li>\n<li><p>Animation.RELATIVE_TO_PARENT.坐标相对于父View来说,X、Y的数值代表父View的width,height的倍数</p>\n<p>float pivotXValue float pivotYValue:对于动画执行XY坐标的距离</p>\n<ul>\n<li>float fromX:初始X的大小,百分比</li>\n<li>float toX:结束时X的大小,百分比</li>\n<li>float fromY:初始Y的大小,百分比</li>\n<li>float toY:结束时Y的大小,百分比</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY)\nScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY,\n                                             float toY,float pivotX, float pivotY)\nScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY,\n                                          int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE --&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:pivotY=&quot;&quot;\n    android:pivotX=&quot;&quot;\n    android:fromXScale=&quot;&quot;\n    android:fromYScale=&quot;&quot;\n    android:toXScale=&quot;&quot;\n    android:toYScale=&quot;&quot; /&gt;\n</code></pre><p>3.改变View的位置(平移操作)<br>int fromXType,int toXType int fromYType, int toYType:含义跟Scale的int pivotXType,int pivotYType相同<br> float fromXValue, float toXValue,float fromYValue,  float toYValue:XY方向上平移的距离</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>TranslateAnimation animation=new TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)\nTranslateAnimation animation=new TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,\n                                                 int fromYType, float fromYValue, int toYType, float toYValue)\n</code></pre><ul>\n<li>xml实现</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--fromXDelta,fromYDelta,toXDelta,toYDelta为数值时代表--&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:fromXDelta=&quot;100&quot;\n    android:fromYDelta=&quot;100&quot;\n    android:toXDelta=&quot;100&quot;\n    android:toYDelta=&quot;100&quot;/&gt;\n</code></pre><p>4.旋转View</p>\n<p>int pivotXType, float pivotXValue,int pivotYType, float pivotYValue:四个数值的参数和Scale相同,代表围绕某一个点旋转</p>\n<p>float fromDegrees:起始角度<br>float toDegrees:结束角度</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees)\nRotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)\nRotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,\n                                                int pivotYType, float pivotYValue)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE --&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:pivotX=&quot;&quot;\n    android:pivotY=&quot;&quot;\n    android:fromDegrees=&quot;&quot;\n    android:toDegrees=&quot;&quot;/&gt;\n</code></pre><p> 5.这种动画可以同时使用,用AnimationSet</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AnimationSet set=new AnimationSet(boolean shareInterpolator)//shareInterpolator代表是否动画使用同一个插值器\nvoid addAnimation(Animation a) 来增加动画个数\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;rotate/&gt;\n    &lt;scale/&gt;\n    &lt;translate/&gt;\n    &lt;alpha/&gt;\n&lt;/set&gt;\n</code></pre><p> Animation有一些通用的方法:</p>\n<ul>\n<li><p>setDuration(long durationMillis)  //设置动画的时间 毫秒为单位</p>\n</li>\n<li><p>setRepeatCount(int repeatCount)//设置动画的重复次数 如果设置成-1或者小于-1(Animation.INFINITE)代表无限循环</p>\n</li>\n<li><p>setRepeatMode(int repeatMode)//设置动画重复的模式 1(Animation.RESTART)代表回放 2(Animation.REVERSE)代表倒叙回放</p>\n</li>\n<li><p>setFillAfter(boolean fillAfter) //设置动画是否保存结束后的状态</p>\n</li>\n<li><p>setFillBefore(boolean fillBefore)//设置动画是否保存开始时的状态</p>\n</li>\n<li><p>setFillEnabled(boolean fillEnabled)//设置动画是否保存开始时的状态</p>\n</li>\n<li><p>setAnimationListener(AnimationListener)     //设置动画监听<br>其中AnimationListener是一个接口:</p>\n</li>\n</ul>\n<pre><code>public static interface AnimationListener {\n               //动画开始时调用\n               void onAnimationStart(Animation animation);\n               //动画结束时调用     \n               void onAnimationEnd(Animation animation);\n               //动画重复时调用\n               void onAnimationRepeat(Animation animation);\n           }\n</code></pre><p>xml中通用属性:</p>\n<pre><code>android:duration=&quot;1000&quot;   \nandroid:repeatCount=&quot;-1&quot;\nandroid:repeatMode=&quot;[&quot;reverse&quot;  &quot;restart&quot;]&quot;\nandroid:fillBefore=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\nandroid:fillAfter=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\nandroid:fillEnabled=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\n</code></pre><h3 id=\"1-2-逐帧动画\"><a href=\"#1-2-逐帧动画\" class=\"headerlink\" title=\"1.2 逐帧动画\"></a>1.2 逐帧动画</h3><p>顾名思义就是动画一帧一帧的播放,那么就需要每一帧的图片资源</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AnimationDrawable drawable=new AnimationDrawable();\n      for (int i = 0; i &lt; 14; i++) {\n      Drawable drawable1=getResources().getDrawable(R.drawable.id);\n       drawable.addFrame(drawable1,60);\n      }\n drawable.setOneShot(false);\n</code></pre><ul>\n<li>void addFrame(Drawable frame, int duration) //添加帧数,并且设置帧数的持续时间</li>\n<li><p>void setOneShot(boolean oneShot)//true表示重复播放 false表示只播放一次</p>\n</li>\n<li><p>xml实现:</p>\n</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;animation-list\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:oneshot=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;&gt;\n    &lt;!--每一帧都要设置一个item--&gt;\n    &lt;item android:drawable=&quot;&quot; android:duration=&quot;&quot;/&gt;\n&lt;/animation-list&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-1补间动画\"><a href=\"#1-1补间动画\" class=\"headerlink\" title=\"1.1补间动画\"></a>1.1补间动画</h3><p>共分为四种</p>\n<p>1.改变View的透明度 AlphaAnimation</p>\n<p>   因为只是改变View的透明度,所以它的属性并不是很多只有fromAlpha和toAlpha<br>   fromAlpha:初始的alpha的值,<br>   toAlpha:结束时alpha的值</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AlphaAnimation alphaAnimation =new AlphaAnimation(float fromAlpha, float toAlpha)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:toAlpha=&quot;1.0&quot;\n    android:fromAlpha=&quot;0.1&quot;/&gt;\n</code></pre><p>下面三个因为会改变View的位置或者大小或者形状,因此需要确定一个中心去确定如何执行动画</p>\n<p>2.scale:改变View的大小:</p>\n<p> int pivotXType   int pivotYType :对于动画执行的XY坐标的位置,原点都是View的左上角<br>  有三个值可以使用:</p>\n<ul>\n<li>Animation.ABSOLUTE :坐标的绝对值,原点是View的左上角 ,X、Y的数值代表实际多少像素</li>\n<li>Animation.RELATIVE_TO_SELF:坐标相对于自己来说,X、Y的数值代表自己的width,height的倍数</li>\n<li><p>Animation.RELATIVE_TO_PARENT.坐标相对于父View来说,X、Y的数值代表父View的width,height的倍数</p>\n<p>float pivotXValue float pivotYValue:对于动画执行XY坐标的距离</p>\n<ul>\n<li>float fromX:初始X的大小,百分比</li>\n<li>float toX:结束时X的大小,百分比</li>\n<li>float fromY:初始Y的大小,百分比</li>\n<li>float toY:结束时Y的大小,百分比</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>ScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY)\nScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY,\n                                             float toY,float pivotX, float pivotY)\nScaleAnimation scaleAnimation=new ScaleAnimation(float fromX, float toX, float fromY, float toY,\n                                          int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE --&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:pivotY=&quot;&quot;\n    android:pivotX=&quot;&quot;\n    android:fromXScale=&quot;&quot;\n    android:fromYScale=&quot;&quot;\n    android:toXScale=&quot;&quot;\n    android:toYScale=&quot;&quot; /&gt;\n</code></pre><p>3.改变View的位置(平移操作)<br>int fromXType,int toXType int fromYType, int toYType:含义跟Scale的int pivotXType,int pivotYType相同<br> float fromXValue, float toXValue,float fromYValue,  float toYValue:XY方向上平移的距离</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>TranslateAnimation animation=new TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)\nTranslateAnimation animation=new TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,\n                                                 int fromYType, float fromYValue, int toYType, float toYValue)\n</code></pre><ul>\n<li>xml实现</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--fromXDelta,fromYDelta,toXDelta,toYDelta为数值时代表--&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:fromXDelta=&quot;100&quot;\n    android:fromYDelta=&quot;100&quot;\n    android:toXDelta=&quot;100&quot;\n    android:toYDelta=&quot;100&quot;/&gt;\n</code></pre><p>4.旋转View</p>\n<p>int pivotXType, float pivotXValue,int pivotYType, float pivotYValue:四个数值的参数和Scale相同,代表围绕某一个点旋转</p>\n<p>float fromDegrees:起始角度<br>float toDegrees:结束角度</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>RotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees)\nRotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)\nRotateAnimation rotateAnimation=new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,\n                                                int pivotYType, float pivotYValue)\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!--pivotY和pivotX为数值时代表 Animation.ABSOLUTE --&gt;\n&lt;!--为百分比时代表RELATIVE_TO_SELF --&gt;\n&lt;!--百分比后面加一个p代表RELATIVE_TO_PARENT--&gt;\n&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:pivotX=&quot;&quot;\n    android:pivotY=&quot;&quot;\n    android:fromDegrees=&quot;&quot;\n    android:toDegrees=&quot;&quot;/&gt;\n</code></pre><p> 5.这种动画可以同时使用,用AnimationSet</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AnimationSet set=new AnimationSet(boolean shareInterpolator)//shareInterpolator代表是否动画使用同一个插值器\nvoid addAnimation(Animation a) 来增加动画个数\n</code></pre><ul>\n<li>xml实现:</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;rotate/&gt;\n    &lt;scale/&gt;\n    &lt;translate/&gt;\n    &lt;alpha/&gt;\n&lt;/set&gt;\n</code></pre><p> Animation有一些通用的方法:</p>\n<ul>\n<li><p>setDuration(long durationMillis)  //设置动画的时间 毫秒为单位</p>\n</li>\n<li><p>setRepeatCount(int repeatCount)//设置动画的重复次数 如果设置成-1或者小于-1(Animation.INFINITE)代表无限循环</p>\n</li>\n<li><p>setRepeatMode(int repeatMode)//设置动画重复的模式 1(Animation.RESTART)代表回放 2(Animation.REVERSE)代表倒叙回放</p>\n</li>\n<li><p>setFillAfter(boolean fillAfter) //设置动画是否保存结束后的状态</p>\n</li>\n<li><p>setFillBefore(boolean fillBefore)//设置动画是否保存开始时的状态</p>\n</li>\n<li><p>setFillEnabled(boolean fillEnabled)//设置动画是否保存开始时的状态</p>\n</li>\n<li><p>setAnimationListener(AnimationListener)     //设置动画监听<br>其中AnimationListener是一个接口:</p>\n</li>\n</ul>\n<pre><code>public static interface AnimationListener {\n               //动画开始时调用\n               void onAnimationStart(Animation animation);\n               //动画结束时调用     \n               void onAnimationEnd(Animation animation);\n               //动画重复时调用\n               void onAnimationRepeat(Animation animation);\n           }\n</code></pre><p>xml中通用属性:</p>\n<pre><code>android:duration=&quot;1000&quot;   \nandroid:repeatCount=&quot;-1&quot;\nandroid:repeatMode=&quot;[&quot;reverse&quot;  &quot;restart&quot;]&quot;\nandroid:fillBefore=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\nandroid:fillAfter=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\nandroid:fillEnabled=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;\n</code></pre><h3 id=\"1-2-逐帧动画\"><a href=\"#1-2-逐帧动画\" class=\"headerlink\" title=\"1.2 逐帧动画\"></a>1.2 逐帧动画</h3><p>顾名思义就是动画一帧一帧的播放,那么就需要每一帧的图片资源</p>\n<ul>\n<li>代码实现:</li>\n</ul>\n<pre><code>AnimationDrawable drawable=new AnimationDrawable();\n      for (int i = 0; i &lt; 14; i++) {\n      Drawable drawable1=getResources().getDrawable(R.drawable.id);\n       drawable.addFrame(drawable1,60);\n      }\n drawable.setOneShot(false);\n</code></pre><ul>\n<li>void addFrame(Drawable frame, int duration) //添加帧数,并且设置帧数的持续时间</li>\n<li><p>void setOneShot(boolean oneShot)//true表示重复播放 false表示只播放一次</p>\n</li>\n<li><p>xml实现:</p>\n</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;animation-list\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:oneshot=&quot;[&quot;true&quot;  &quot;false&quot;]&quot;&gt;\n    &lt;!--每一帧都要设置一个item--&gt;\n    &lt;item android:drawable=&quot;&quot; android:duration=&quot;&quot;/&gt;\n&lt;/animation-list&gt;\n</code></pre>"},{"title":"Android通知使用","date":"2019-01-07T09:07:36.000Z","_content":"又重新学习了一遍《第一行代码》,不过这次用的是kotlin来编写Android的代码,写到通知的的时候,\n意外的发现书上的代码不起作用了,于是Google了下原因:\n原来在Android8.0之后,Google限制了通知的使用,查看源码发现:之前的Builder(Context context)方法加上了deprecated的注解:\n```\n         /** @deprecated */\n         @Deprecated\n         public Builder(Context context) {\n                    this(context, (String)null);\n                }\n```\n查看了一下意思的话:加上这个注解说明这个方法是危险的或者有更好的方法代替\n\n但是其实如果你指定app的编译版本在26以下时,这个方法还是有效的,但是在26以上,那么就不\n能发出通知了\n\n作为一名规范的开发者吧,还是要追随官方的脚步的,本人也不是很喜欢降低Android的编译版本来\n获取一些不必要的权限或者其他的东西\n\n随开始研究Android8.0以上的通知使用规则:\n```\n        public Builder(@NonNull Context context, @NonNull String channelId)\n```\n现在推荐的是使用这个方法来发送通知,但是很好奇的是channelId到底是个什么东西,拿来干什么?\n\n原来从8.0开始,Google引入了通知渠道的概念,简单的来说就是指定你的APP有哪些通知类型,就比如QQ有好友发送消息的通知和好友\n验证的通知,需要将通知分类,然后根据这个分类来发送通知\n\n而且也加入了通知等级的概念,一共有六个值可以选择:\n```\n*. IMPORTANCE_NONE :A notification with no importance: does not show in the shade.\n\n*. IMPORTANCE_MIN :Min notification importance: only shows in the shade, below the fold\n\n*. IMPORTANCE_LOW :Low notification importance: shows everywhere, but is not intrusive.\n\n*. IMPORTANCE_DEFAULT : Default notification importance: shows everywhere, makes noise, but does not visually  intrude.\n\n*. IMPORTANCE_HIGH :Higher notification importance: shows everywhere, makes noise and peeks. May use full screen intents\n\n*. IMPORTANCE_MAX  :Unused(没用过)\n\n\n          if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){\n                    val channel: NotificationChannel = NotificationChannel(\"message\",\"好友消息\",NotificationManager.IMPORTANCE_DEFAULT)\n                    val channel2: NotificationChannel = NotificationChannel(\"verification\",\"好友验证\",NotificationManager.IMPORTANCE_DEFAULT)\n                    getNotificationManager().createNotificationChannel(channel)\n                    getNotificationManager().createNotificationChannel(channel2)\n                }\n```\n然后就是注册通知类型了,一定是要在8.0及以上才有这种消息管理,低版本是没有的\n\n运行之后查看app的通知权限,可以很清楚的看到我们注册了两种消息通知,接下去就可以选择能使用通知啦\n\n\n\n\n\n![创建通知类型](http://image.honglingqi.cn/blogImages/0107/20190107.png)\n```\n           private fun getNotification(title:String,progress: Int): Notification {\n                val builder:NotificationCompat.Builder\n                if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){\n                //这里的类型一定要填写之前注册好的类型 否则通知不会显示\n                     builder= NotificationCompat.Builder(this,\"message\")\n                }else{\n                     builder= NotificationCompat.Builder(this)\n                }\n                val intent= Intent(this, TestActivity::class.java)\n                val pi= PendingIntent.getActivity(this,0,intent,0)\n                builder.setSmallIcon(R.mipmap.ic_launcher)\n                builder.setLargeIcon(BitmapFactory.decodeResource(resources,R.mipmap.ic_launcher))\n                builder.setContentIntent(pi)\n                builder.setContentTitle(title)\n                if(progress>0){\n                    builder.setContentText(\"{$progress}%\")\n                    builder.setProgress(100,progress,false)\n                }\n                return builder.build()\n            }\n             getNotificationManager().notify(1,getNotification(\"这是一个通知\",-1))\n```\n大功告成!\n","source":"_posts/Android通知使用.md","raw":"---\ntitle: Android通知使用\ndate: 2019-01-07 17:07:36\ntags:\n- android\n---\n又重新学习了一遍《第一行代码》,不过这次用的是kotlin来编写Android的代码,写到通知的的时候,\n意外的发现书上的代码不起作用了,于是Google了下原因:\n原来在Android8.0之后,Google限制了通知的使用,查看源码发现:之前的Builder(Context context)方法加上了deprecated的注解:\n```\n         /** @deprecated */\n         @Deprecated\n         public Builder(Context context) {\n                    this(context, (String)null);\n                }\n```\n查看了一下意思的话:加上这个注解说明这个方法是危险的或者有更好的方法代替\n\n但是其实如果你指定app的编译版本在26以下时,这个方法还是有效的,但是在26以上,那么就不\n能发出通知了\n\n作为一名规范的开发者吧,还是要追随官方的脚步的,本人也不是很喜欢降低Android的编译版本来\n获取一些不必要的权限或者其他的东西\n\n随开始研究Android8.0以上的通知使用规则:\n```\n        public Builder(@NonNull Context context, @NonNull String channelId)\n```\n现在推荐的是使用这个方法来发送通知,但是很好奇的是channelId到底是个什么东西,拿来干什么?\n\n原来从8.0开始,Google引入了通知渠道的概念,简单的来说就是指定你的APP有哪些通知类型,就比如QQ有好友发送消息的通知和好友\n验证的通知,需要将通知分类,然后根据这个分类来发送通知\n\n而且也加入了通知等级的概念,一共有六个值可以选择:\n```\n*. IMPORTANCE_NONE :A notification with no importance: does not show in the shade.\n\n*. IMPORTANCE_MIN :Min notification importance: only shows in the shade, below the fold\n\n*. IMPORTANCE_LOW :Low notification importance: shows everywhere, but is not intrusive.\n\n*. IMPORTANCE_DEFAULT : Default notification importance: shows everywhere, makes noise, but does not visually  intrude.\n\n*. IMPORTANCE_HIGH :Higher notification importance: shows everywhere, makes noise and peeks. May use full screen intents\n\n*. IMPORTANCE_MAX  :Unused(没用过)\n\n\n          if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){\n                    val channel: NotificationChannel = NotificationChannel(\"message\",\"好友消息\",NotificationManager.IMPORTANCE_DEFAULT)\n                    val channel2: NotificationChannel = NotificationChannel(\"verification\",\"好友验证\",NotificationManager.IMPORTANCE_DEFAULT)\n                    getNotificationManager().createNotificationChannel(channel)\n                    getNotificationManager().createNotificationChannel(channel2)\n                }\n```\n然后就是注册通知类型了,一定是要在8.0及以上才有这种消息管理,低版本是没有的\n\n运行之后查看app的通知权限,可以很清楚的看到我们注册了两种消息通知,接下去就可以选择能使用通知啦\n\n\n\n\n\n![创建通知类型](http://image.honglingqi.cn/blogImages/0107/20190107.png)\n```\n           private fun getNotification(title:String,progress: Int): Notification {\n                val builder:NotificationCompat.Builder\n                if(Build.VERSION.SDK_INT>=Build.VERSION_CODES.O){\n                //这里的类型一定要填写之前注册好的类型 否则通知不会显示\n                     builder= NotificationCompat.Builder(this,\"message\")\n                }else{\n                     builder= NotificationCompat.Builder(this)\n                }\n                val intent= Intent(this, TestActivity::class.java)\n                val pi= PendingIntent.getActivity(this,0,intent,0)\n                builder.setSmallIcon(R.mipmap.ic_launcher)\n                builder.setLargeIcon(BitmapFactory.decodeResource(resources,R.mipmap.ic_launcher))\n                builder.setContentIntent(pi)\n                builder.setContentTitle(title)\n                if(progress>0){\n                    builder.setContentText(\"{$progress}%\")\n                    builder.setProgress(100,progress,false)\n                }\n                return builder.build()\n            }\n             getNotificationManager().notify(1,getNotification(\"这是一个通知\",-1))\n```\n大功告成!\n","slug":"Android通知使用","published":1,"updated":"2020-03-31T05:41:12.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6s00089otszv6mcrho","content":"<p>又重新学习了一遍《第一行代码》,不过这次用的是kotlin来编写Android的代码,写到通知的的时候,<br>意外的发现书上的代码不起作用了,于是Google了下原因:<br>原来在Android8.0之后,Google限制了通知的使用,查看源码发现:之前的Builder(Context context)方法加上了deprecated的注解:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** @deprecated */</span><br><span class=\"line\">@Deprecated</span><br><span class=\"line\">public Builder(Context context) &#123;</span><br><span class=\"line\">           this(context, (String)null);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看了一下意思的话:加上这个注解说明这个方法是危险的或者有更好的方法代替</p>\n<p>但是其实如果你指定app的编译版本在26以下时,这个方法还是有效的,但是在26以上,那么就不<br>能发出通知了</p>\n<p>作为一名规范的开发者吧,还是要追随官方的脚步的,本人也不是很喜欢降低Android的编译版本来<br>获取一些不必要的权限或者其他的东西</p>\n<p>随开始研究Android8.0以上的通知使用规则:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder(@NonNull Context context, @NonNull String channelId)</span><br></pre></td></tr></table></figure></p>\n<p>现在推荐的是使用这个方法来发送通知,但是很好奇的是channelId到底是个什么东西,拿来干什么?</p>\n<p>原来从8.0开始,Google引入了通知渠道的概念,简单的来说就是指定你的APP有哪些通知类型,就比如QQ有好友发送消息的通知和好友<br>验证的通知,需要将通知分类,然后根据这个分类来发送通知</p>\n<p>而且也加入了通知等级的概念,一共有六个值可以选择:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*. IMPORTANCE_NONE :A notification with no importance: does not show in the shade.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_MIN :Min notification importance: only shows in the shade, below the fold</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_LOW :Low notification importance: shows everywhere, but is not intrusive.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_DEFAULT : Default notification importance: shows everywhere, makes noise, but does not visually  intrude.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_HIGH :Higher notification importance: shows everywhere, makes noise and peeks. May use full screen intents</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_MAX  :Unused(没用过)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">          if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class=\"line\">                    val channel: NotificationChannel = NotificationChannel(&quot;message&quot;,&quot;好友消息&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class=\"line\">                    val channel2: NotificationChannel = NotificationChannel(&quot;verification&quot;,&quot;好友验证&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class=\"line\">                    getNotificationManager().createNotificationChannel(channel)</span><br><span class=\"line\">                    getNotificationManager().createNotificationChannel(channel2)</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后就是注册通知类型了,一定是要在8.0及以上才有这种消息管理,低版本是没有的</p>\n<p>运行之后查看app的通知权限,可以很清楚的看到我们注册了两种消息通知,接下去就可以选择能使用通知啦</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/0107/20190107.png\" alt=\"创建通知类型\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private fun getNotification(title:String,progress: Int): Notification &#123;</span><br><span class=\"line\">     val builder:NotificationCompat.Builder</span><br><span class=\"line\">     if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class=\"line\">     //这里的类型一定要填写之前注册好的类型 否则通知不会显示</span><br><span class=\"line\">          builder= NotificationCompat.Builder(this,&quot;message&quot;)</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">          builder= NotificationCompat.Builder(this)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     val intent= Intent(this, TestActivity::class.java)</span><br><span class=\"line\">     val pi= PendingIntent.getActivity(this,0,intent,0)</span><br><span class=\"line\">     builder.setSmallIcon(R.mipmap.ic_launcher)</span><br><span class=\"line\">     builder.setLargeIcon(BitmapFactory.decodeResource(resources,R.mipmap.ic_launcher))</span><br><span class=\"line\">     builder.setContentIntent(pi)</span><br><span class=\"line\">     builder.setContentTitle(title)</span><br><span class=\"line\">     if(progress&gt;0)&#123;</span><br><span class=\"line\">         builder.setContentText(&quot;&#123;$progress&#125;%&quot;)</span><br><span class=\"line\">         builder.setProgress(100,progress,false)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return builder.build()</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  getNotificationManager().notify(1,getNotification(&quot;这是一个通知&quot;,-1))</span><br></pre></td></tr></table></figure></p>\n<p>大功告成!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>又重新学习了一遍《第一行代码》,不过这次用的是kotlin来编写Android的代码,写到通知的的时候,<br>意外的发现书上的代码不起作用了,于是Google了下原因:<br>原来在Android8.0之后,Google限制了通知的使用,查看源码发现:之前的Builder(Context context)方法加上了deprecated的注解:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** @deprecated */</span><br><span class=\"line\">@Deprecated</span><br><span class=\"line\">public Builder(Context context) &#123;</span><br><span class=\"line\">           this(context, (String)null);</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看了一下意思的话:加上这个注解说明这个方法是危险的或者有更好的方法代替</p>\n<p>但是其实如果你指定app的编译版本在26以下时,这个方法还是有效的,但是在26以上,那么就不<br>能发出通知了</p>\n<p>作为一名规范的开发者吧,还是要追随官方的脚步的,本人也不是很喜欢降低Android的编译版本来<br>获取一些不必要的权限或者其他的东西</p>\n<p>随开始研究Android8.0以上的通知使用规则:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Builder(@NonNull Context context, @NonNull String channelId)</span><br></pre></td></tr></table></figure></p>\n<p>现在推荐的是使用这个方法来发送通知,但是很好奇的是channelId到底是个什么东西,拿来干什么?</p>\n<p>原来从8.0开始,Google引入了通知渠道的概念,简单的来说就是指定你的APP有哪些通知类型,就比如QQ有好友发送消息的通知和好友<br>验证的通知,需要将通知分类,然后根据这个分类来发送通知</p>\n<p>而且也加入了通知等级的概念,一共有六个值可以选择:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*. IMPORTANCE_NONE :A notification with no importance: does not show in the shade.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_MIN :Min notification importance: only shows in the shade, below the fold</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_LOW :Low notification importance: shows everywhere, but is not intrusive.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_DEFAULT : Default notification importance: shows everywhere, makes noise, but does not visually  intrude.</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_HIGH :Higher notification importance: shows everywhere, makes noise and peeks. May use full screen intents</span><br><span class=\"line\"></span><br><span class=\"line\">*. IMPORTANCE_MAX  :Unused(没用过)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">          if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class=\"line\">                    val channel: NotificationChannel = NotificationChannel(&quot;message&quot;,&quot;好友消息&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class=\"line\">                    val channel2: NotificationChannel = NotificationChannel(&quot;verification&quot;,&quot;好友验证&quot;,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class=\"line\">                    getNotificationManager().createNotificationChannel(channel)</span><br><span class=\"line\">                    getNotificationManager().createNotificationChannel(channel2)</span><br><span class=\"line\">                &#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后就是注册通知类型了,一定是要在8.0及以上才有这种消息管理,低版本是没有的</p>\n<p>运行之后查看app的通知权限,可以很清楚的看到我们注册了两种消息通知,接下去就可以选择能使用通知啦</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/0107/20190107.png\" alt=\"创建通知类型\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private fun getNotification(title:String,progress: Int): Notification &#123;</span><br><span class=\"line\">     val builder:NotificationCompat.Builder</span><br><span class=\"line\">     if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class=\"line\">     //这里的类型一定要填写之前注册好的类型 否则通知不会显示</span><br><span class=\"line\">          builder= NotificationCompat.Builder(this,&quot;message&quot;)</span><br><span class=\"line\">     &#125;else&#123;</span><br><span class=\"line\">          builder= NotificationCompat.Builder(this)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     val intent= Intent(this, TestActivity::class.java)</span><br><span class=\"line\">     val pi= PendingIntent.getActivity(this,0,intent,0)</span><br><span class=\"line\">     builder.setSmallIcon(R.mipmap.ic_launcher)</span><br><span class=\"line\">     builder.setLargeIcon(BitmapFactory.decodeResource(resources,R.mipmap.ic_launcher))</span><br><span class=\"line\">     builder.setContentIntent(pi)</span><br><span class=\"line\">     builder.setContentTitle(title)</span><br><span class=\"line\">     if(progress&gt;0)&#123;</span><br><span class=\"line\">         builder.setContentText(&quot;&#123;$progress&#125;%&quot;)</span><br><span class=\"line\">         builder.setProgress(100,progress,false)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return builder.build()</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  getNotificationManager().notify(1,getNotification(&quot;这是一个通知&quot;,-1))</span><br></pre></td></tr></table></figure></p>\n<p>大功告成!</p>\n"},{"title":"IOS第三方库的之CocoaPods管理","date":"2018-06-22T02:25:22.000Z","_content":"在IOS开发中,也需要导入很多第三方的类库,就比如AFNetworking,用户网络请求,所以自己尝试着去实践了下,真的好多坑啊\n\n## 1.安装\n如果机器版本太久就需要更新一下ruby\n```\n//更新源操作\ngem sources --remove https://rubygems.org/\ngem sources -a https://ruby.taobao.org/\ngen sources -l\n\n//安装 cocoapods\nsudo gem install cocoapods\n\n//将Github上的开源库都托管都安装Podspec索引安装到到本地,\npod setup\n\n```\n到此就安装完毕了,如果中途有下载过慢的情况,可以搜索网络替换一下源\n\n## 2.使用前\n例如需要使用AFNetworking这个类库,可以搜索一下是否存在\n```angular2html\npod search AFNetworking //可以不区分大小写\n```\n如果是下面这这种情况:\n![搜索成功](http://image.honglingqi.cn/blogImages/0622/success.png)\n那么说明可以使用了\n\n如果出现了一下错误:\n<p style=\"color:red\">[!] Unable to find a pod with name, author, summary, or description matching `AFNetworking`</p>\n\n执行下面的操作\n```angular2html\nrm ~/Library/Caches/CocoaPods/search_index.json\n```\n然后就可以了\n\n## 导入\n用xcode新建一个项目,然后在终端中进入这个文件夹(你也可以手动)\n```angular2html\ntouch podfile //生成文件\nopen podfile\n```\n然后填入一些你需要使用的类库信息,这里我使用了AFNetworking来做测试,进入到其github的仓库,里面有需要添加的依赖:\n```angular2html\nsource 'https://github.com/CocoaPods/Specs.git'\nplatform :ios, '8.0'\n\ntarget 'TargetName' do\npod 'AFNetworking', '~> 3.0'\nend\n```\n其中,吧TargetName 换成你自己的工程名字,比如我新建的工程叫做test 那么这里就填写test\n\n接下去进行安装\n\n``pod install\n``\n\n![安装成功](http://image.honglingqi.cn/blogImages/0622/install.png)\n\n## 使用\n\n之前的我都成功了很多次了,唯独最后一步使用我一直不能成功,很气,最后自己看博客看书,才找到门道:\n在执行完\n```pod install```\n之后项目的根目录会多出来三个文件:test.xcworkspace,pods,podfile.lock\n然后之后打开test.xcworkspace这个文件,而不是test.xcodeproj ,很奇怪这到底怎么实现的,最后发现自己太笨了:\n1.打开Xcode 选择 open another project\n1.然后找到项目,按照下图打开\n![打开项目](http://image.honglingqi.cn/blogImages/0622/open.png)\n1.接下去就可以使用啦,再头部导入:#import \"AFNetWorking.h\",但是在导入的时候没有提示,\n不知道为什么,一开始我还以为错了,结果是能build 成功的,照着例子请求了下网址,是能有数据的\n\n```angular2html\n-(void)get\n{\n    //1.创建会话管理者\n    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n\n    //2.封装参数\n    NSDictionary *dict = @{\n                           @\"channel\":@\"0\",\n                           @\"pwd\":@\"1314\",\n                           @\"type\":@\"JSON\"\n                           };\n    //3.发送GET请求\n    /*\n     第一个参数:请求路径(NSString)+ 不需要加参数\n     第二个参数:发送给服务器的参数数据\n     第三个参数:progress 进度回调\n     第四个参数:success  成功之后的回调(此处的成功或者是失败指的是整个请求)\n     task:请求任务\n     responseObject:注意!!!响应体信息--->(json--->oc))\n     task.response: 响应头信息\n     第五个参数:failure 失败之后的回调\n     */\n    [manager GET:@\"请求的url\" parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        NSLog(@\"success--%@--%@\",[responseObject class],responseObject);\n\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\n        NSLog(@\"failure--%@\",error);\n    }];\n}\n```\n### 总结\n Object-C 真的是让人头大的东西,刚学IOS开发,还有很多不懂的地方啊,学习吧\n","source":"_posts/IOS第三方库的之CocoaPods管理.md","raw":"---\ntitle: IOS第三方库的之CocoaPods管理\ndate: 2018-06-22 10:25:22\ntags:\n- ios\n---\n在IOS开发中,也需要导入很多第三方的类库,就比如AFNetworking,用户网络请求,所以自己尝试着去实践了下,真的好多坑啊\n\n## 1.安装\n如果机器版本太久就需要更新一下ruby\n```\n//更新源操作\ngem sources --remove https://rubygems.org/\ngem sources -a https://ruby.taobao.org/\ngen sources -l\n\n//安装 cocoapods\nsudo gem install cocoapods\n\n//将Github上的开源库都托管都安装Podspec索引安装到到本地,\npod setup\n\n```\n到此就安装完毕了,如果中途有下载过慢的情况,可以搜索网络替换一下源\n\n## 2.使用前\n例如需要使用AFNetworking这个类库,可以搜索一下是否存在\n```angular2html\npod search AFNetworking //可以不区分大小写\n```\n如果是下面这这种情况:\n![搜索成功](http://image.honglingqi.cn/blogImages/0622/success.png)\n那么说明可以使用了\n\n如果出现了一下错误:\n<p style=\"color:red\">[!] Unable to find a pod with name, author, summary, or description matching `AFNetworking`</p>\n\n执行下面的操作\n```angular2html\nrm ~/Library/Caches/CocoaPods/search_index.json\n```\n然后就可以了\n\n## 导入\n用xcode新建一个项目,然后在终端中进入这个文件夹(你也可以手动)\n```angular2html\ntouch podfile //生成文件\nopen podfile\n```\n然后填入一些你需要使用的类库信息,这里我使用了AFNetworking来做测试,进入到其github的仓库,里面有需要添加的依赖:\n```angular2html\nsource 'https://github.com/CocoaPods/Specs.git'\nplatform :ios, '8.0'\n\ntarget 'TargetName' do\npod 'AFNetworking', '~> 3.0'\nend\n```\n其中,吧TargetName 换成你自己的工程名字,比如我新建的工程叫做test 那么这里就填写test\n\n接下去进行安装\n\n``pod install\n``\n\n![安装成功](http://image.honglingqi.cn/blogImages/0622/install.png)\n\n## 使用\n\n之前的我都成功了很多次了,唯独最后一步使用我一直不能成功,很气,最后自己看博客看书,才找到门道:\n在执行完\n```pod install```\n之后项目的根目录会多出来三个文件:test.xcworkspace,pods,podfile.lock\n然后之后打开test.xcworkspace这个文件,而不是test.xcodeproj ,很奇怪这到底怎么实现的,最后发现自己太笨了:\n1.打开Xcode 选择 open another project\n1.然后找到项目,按照下图打开\n![打开项目](http://image.honglingqi.cn/blogImages/0622/open.png)\n1.接下去就可以使用啦,再头部导入:#import \"AFNetWorking.h\",但是在导入的时候没有提示,\n不知道为什么,一开始我还以为错了,结果是能build 成功的,照着例子请求了下网址,是能有数据的\n\n```angular2html\n-(void)get\n{\n    //1.创建会话管理者\n    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n\n    //2.封装参数\n    NSDictionary *dict = @{\n                           @\"channel\":@\"0\",\n                           @\"pwd\":@\"1314\",\n                           @\"type\":@\"JSON\"\n                           };\n    //3.发送GET请求\n    /*\n     第一个参数:请求路径(NSString)+ 不需要加参数\n     第二个参数:发送给服务器的参数数据\n     第三个参数:progress 进度回调\n     第四个参数:success  成功之后的回调(此处的成功或者是失败指的是整个请求)\n     task:请求任务\n     responseObject:注意!!!响应体信息--->(json--->oc))\n     task.response: 响应头信息\n     第五个参数:failure 失败之后的回调\n     */\n    [manager GET:@\"请求的url\" parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        NSLog(@\"success--%@--%@\",[responseObject class],responseObject);\n\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\n        NSLog(@\"failure--%@\",error);\n    }];\n}\n```\n### 总结\n Object-C 真的是让人头大的东西,刚学IOS开发,还有很多不懂的地方啊,学习吧\n","slug":"IOS第三方库的之CocoaPods管理","published":1,"updated":"2020-03-31T05:41:12.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6v000a9otswfwb4kib","content":"<p>在IOS开发中,也需要导入很多第三方的类库,就比如AFNetworking,用户网络请求,所以自己尝试着去实践了下,真的好多坑啊</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p>如果机器版本太久就需要更新一下ruby<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//更新源操作</span><br><span class=\"line\">gem sources --remove https://rubygems.org/</span><br><span class=\"line\">gem sources -a https://ruby.taobao.org/</span><br><span class=\"line\">gen sources -l</span><br><span class=\"line\"></span><br><span class=\"line\">//安装 cocoapods</span><br><span class=\"line\">sudo gem install cocoapods</span><br><span class=\"line\"></span><br><span class=\"line\">//将Github上的开源库都托管都安装Podspec索引安装到到本地,</span><br><span class=\"line\">pod setup</span><br></pre></td></tr></table></figure></p>\n<p>到此就安装完毕了,如果中途有下载过慢的情况,可以搜索网络替换一下源</p>\n<h2 id=\"2-使用前\"><a href=\"#2-使用前\" class=\"headerlink\" title=\"2.使用前\"></a>2.使用前</h2><p>例如需要使用AFNetworking这个类库,可以搜索一下是否存在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search AFNetworking //可以不区分大小写</span><br></pre></td></tr></table></figure></p>\n<p>如果是下面这这种情况:<br><img src=\"http://image.honglingqi.cn/blogImages/0622/success.png\" alt=\"搜索成功\"><br>那么说明可以使用了</p>\n<p>如果出现了一下错误:</p>\n<p style=\"color:red\">[!] Unable to find a pod with name, author, summary, or description matching <code>AFNetworking</code></p>\n\n<p>执行下面的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以了</p>\n<h2 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h2><p>用xcode新建一个项目,然后在终端中进入这个文件夹(你也可以手动)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch podfile //生成文件</span><br><span class=\"line\">open podfile</span><br></pre></td></tr></table></figure></p>\n<p>然后填入一些你需要使用的类库信息,这里我使用了AFNetworking来做测试,进入到其github的仓库,里面有需要添加的依赖:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class=\"line\">platform :ios, &apos;8.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">target &apos;TargetName&apos; do</span><br><span class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p>其中,吧TargetName 换成你自己的工程名字,比如我新建的工程叫做test 那么这里就填写test</p>\n<p>接下去进行安装</p>\n<p><code>pod install</code></p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/0622/install.png\" alt=\"安装成功\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>之前的我都成功了很多次了,唯独最后一步使用我一直不能成功,很气,最后自己看博客看书,才找到门道:<br>在执行完<br><figure class=\"highlight plain\"><figcaption><span>install```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">之后项目的根目录会多出来三个文件:test.xcworkspace,pods,podfile.lock</span><br><span class=\"line\">然后之后打开test.xcworkspace这个文件,而不是test.xcodeproj ,很奇怪这到底怎么实现的,最后发现自己太笨了:</span><br><span class=\"line\">1.打开Xcode 选择 open another project</span><br><span class=\"line\">1.然后找到项目,按照下图打开</span><br><span class=\"line\">![打开项目](http://image.honglingqi.cn/blogImages/0622/open.png)</span><br><span class=\"line\">1.接下去就可以使用啦,再头部导入:#import &quot;AFNetWorking.h&quot;,但是在导入的时候没有提示,</span><br><span class=\"line\">不知道为什么,一开始我还以为错了,结果是能build 成功的,照着例子请求了下网址,是能有数据的</span><br><span class=\"line\"></span><br><span class=\"line\">```angular2html</span><br><span class=\"line\">-(void)get</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建会话管理者</span><br><span class=\"line\">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.封装参数</span><br><span class=\"line\">    NSDictionary *dict = @&#123;</span><br><span class=\"line\">                           @&quot;channel&quot;:@&quot;0&quot;,</span><br><span class=\"line\">                           @&quot;pwd&quot;:@&quot;1314&quot;,</span><br><span class=\"line\">                           @&quot;type&quot;:@&quot;JSON&quot;</span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\">    //3.发送GET请求</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     第一个参数:请求路径(NSString)+ 不需要加参数</span><br><span class=\"line\">     第二个参数:发送给服务器的参数数据</span><br><span class=\"line\">     第三个参数:progress 进度回调</span><br><span class=\"line\">     第四个参数:success  成功之后的回调(此处的成功或者是失败指的是整个请求)</span><br><span class=\"line\">     task:请求任务</span><br><span class=\"line\">     responseObject:注意!!!响应体信息---&gt;(json---&gt;oc))</span><br><span class=\"line\">     task.response: 响应头信息</span><br><span class=\"line\">     第五个参数:failure 失败之后的回调</span><br><span class=\"line\">     */</span><br><span class=\"line\">    [manager GET:@&quot;请求的url&quot; parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        NSLog(@&quot;success--%@--%@&quot;,[responseObject class],responseObject);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        NSLog(@&quot;failure--%@&quot;,error);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p> Object-C 真的是让人头大的东西,刚学IOS开发,还有很多不懂的地方啊,学习吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在IOS开发中,也需要导入很多第三方的类库,就比如AFNetworking,用户网络请求,所以自己尝试着去实践了下,真的好多坑啊</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p>如果机器版本太久就需要更新一下ruby<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//更新源操作</span><br><span class=\"line\">gem sources --remove https://rubygems.org/</span><br><span class=\"line\">gem sources -a https://ruby.taobao.org/</span><br><span class=\"line\">gen sources -l</span><br><span class=\"line\"></span><br><span class=\"line\">//安装 cocoapods</span><br><span class=\"line\">sudo gem install cocoapods</span><br><span class=\"line\"></span><br><span class=\"line\">//将Github上的开源库都托管都安装Podspec索引安装到到本地,</span><br><span class=\"line\">pod setup</span><br></pre></td></tr></table></figure></p>\n<p>到此就安装完毕了,如果中途有下载过慢的情况,可以搜索网络替换一下源</p>\n<h2 id=\"2-使用前\"><a href=\"#2-使用前\" class=\"headerlink\" title=\"2.使用前\"></a>2.使用前</h2><p>例如需要使用AFNetworking这个类库,可以搜索一下是否存在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search AFNetworking //可以不区分大小写</span><br></pre></td></tr></table></figure></p>\n<p>如果是下面这这种情况:<br><img src=\"http://image.honglingqi.cn/blogImages/0622/success.png\" alt=\"搜索成功\"><br>那么说明可以使用了</p>\n<p>如果出现了一下错误:</p>\n<p style=\"color:red\">[!] Unable to find a pod with name, author, summary, or description matching <code>AFNetworking</code></p>\n\n<p>执行下面的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以了</p>\n<h2 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h2><p>用xcode新建一个项目,然后在终端中进入这个文件夹(你也可以手动)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch podfile //生成文件</span><br><span class=\"line\">open podfile</span><br></pre></td></tr></table></figure></p>\n<p>然后填入一些你需要使用的类库信息,这里我使用了AFNetworking来做测试,进入到其github的仓库,里面有需要添加的依赖:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class=\"line\">platform :ios, &apos;8.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">target &apos;TargetName&apos; do</span><br><span class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure></p>\n<p>其中,吧TargetName 换成你自己的工程名字,比如我新建的工程叫做test 那么这里就填写test</p>\n<p>接下去进行安装</p>\n<p><code>pod install</code></p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/0622/install.png\" alt=\"安装成功\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>之前的我都成功了很多次了,唯独最后一步使用我一直不能成功,很气,最后自己看博客看书,才找到门道:<br>在执行完<br><figure class=\"highlight plain\"><figcaption><span>install```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">之后项目的根目录会多出来三个文件:test.xcworkspace,pods,podfile.lock</span><br><span class=\"line\">然后之后打开test.xcworkspace这个文件,而不是test.xcodeproj ,很奇怪这到底怎么实现的,最后发现自己太笨了:</span><br><span class=\"line\">1.打开Xcode 选择 open another project</span><br><span class=\"line\">1.然后找到项目,按照下图打开</span><br><span class=\"line\">![打开项目](http://image.honglingqi.cn/blogImages/0622/open.png)</span><br><span class=\"line\">1.接下去就可以使用啦,再头部导入:#import &quot;AFNetWorking.h&quot;,但是在导入的时候没有提示,</span><br><span class=\"line\">不知道为什么,一开始我还以为错了,结果是能build 成功的,照着例子请求了下网址,是能有数据的</span><br><span class=\"line\"></span><br><span class=\"line\">```angular2html</span><br><span class=\"line\">-(void)get</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //1.创建会话管理者</span><br><span class=\"line\">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\"></span><br><span class=\"line\">    //2.封装参数</span><br><span class=\"line\">    NSDictionary *dict = @&#123;</span><br><span class=\"line\">                           @&quot;channel&quot;:@&quot;0&quot;,</span><br><span class=\"line\">                           @&quot;pwd&quot;:@&quot;1314&quot;,</span><br><span class=\"line\">                           @&quot;type&quot;:@&quot;JSON&quot;</span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\">    //3.发送GET请求</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     第一个参数:请求路径(NSString)+ 不需要加参数</span><br><span class=\"line\">     第二个参数:发送给服务器的参数数据</span><br><span class=\"line\">     第三个参数:progress 进度回调</span><br><span class=\"line\">     第四个参数:success  成功之后的回调(此处的成功或者是失败指的是整个请求)</span><br><span class=\"line\">     task:请求任务</span><br><span class=\"line\">     responseObject:注意!!!响应体信息---&gt;(json---&gt;oc))</span><br><span class=\"line\">     task.response: 响应头信息</span><br><span class=\"line\">     第五个参数:failure 失败之后的回调</span><br><span class=\"line\">     */</span><br><span class=\"line\">    [manager GET:@&quot;请求的url&quot; parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        NSLog(@&quot;success--%@--%@&quot;,[responseObject class],responseObject);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        NSLog(@&quot;failure--%@&quot;,error);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p> Object-C 真的是让人头大的东西,刚学IOS开发,还有很多不懂的地方啊,学习吧</p>\n"},{"title":"Java面试","date":"2019-06-15T02:16:15.000Z","_content":"\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        int a=1;\n        test(a);\n        //==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n        System.out.println(\"a2=\"+a); //输出1\n        Integer b1=110,b2=110,f1=400,f2=400;\n        System.out.println(b1==b2);//true\n        System.out.println(f1==f2);//false\n    }\n    private static void test(int a){\n        a++;\n        System.out.println(\"a1=\"+a); //输出2\n    }\n}\n\n\n\n==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n\n\nwait和sleep的区别","source":"_posts/Java面试.md","raw":"---\ntitle: Java面试\ndate: 2019-06-15 10:16:15\ntags:\n---\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        int a=1;\n        test(a);\n        //==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n        System.out.println(\"a2=\"+a); //输出1\n        Integer b1=110,b2=110,f1=400,f2=400;\n        System.out.println(b1==b2);//true\n        System.out.println(f1==f2);//false\n    }\n    private static void test(int a){\n        a++;\n        System.out.println(\"a1=\"+a); //输出2\n    }\n}\n\n\n\n==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n\n\nwait和sleep的区别","slug":"Java面试","published":1,"updated":"2020-03-31T05:41:12.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje6y000d9otsfqho3225","content":"<p>public class Main {</p>\n<pre><code>public static void main(String[] args) {\n    System.out.println(&quot;Hello World!&quot;);\n    int a=1;\n    test(a);\n    //==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n    System.out.println(&quot;a2=&quot;+a); //输出1\n    Integer b1=110,b2=110,f1=400,f2=400;\n    System.out.println(b1==b2);//true\n    System.out.println(f1==f2);//false\n}\nprivate static void test(int a){\n    a++;\n    System.out.println(&quot;a1=&quot;+a); //输出2\n}\n</code></pre><p>}</p>\n<p>==比较的是2个对象的地址，而equals比较的是2个对象的内容。</p>\n<p>wait和sleep的区别</p>\n","site":{"data":{}},"excerpt":"","more":"<p>public class Main {</p>\n<pre><code>public static void main(String[] args) {\n    System.out.println(&quot;Hello World!&quot;);\n    int a=1;\n    test(a);\n    //==比较的是2个对象的地址，而equals比较的是2个对象的内容。\n    System.out.println(&quot;a2=&quot;+a); //输出1\n    Integer b1=110,b2=110,f1=400,f2=400;\n    System.out.println(b1==b2);//true\n    System.out.println(f1==f2);//false\n}\nprivate static void test(int a){\n    a++;\n    System.out.println(&quot;a1=&quot;+a); //输出2\n}\n</code></pre><p>}</p>\n<p>==比较的是2个对象的地址，而equals比较的是2个对象的内容。</p>\n<p>wait和sleep的区别</p>\n"},{"title":"android studio中文候选框不会跟随光标","date":"2018-12-12T08:22:04.000Z","_content":"(百度了IDEA不会跟随和Android studio不会跟随总结出来的方法)\n1.找到Android studio的安装位置,将其jre文件复制一份出来,这时会有jre - 副本(用来防治万一出现问题可以复原)和jre两个文件夹\n2.找到Java安装位置,把其中jre文件夹(比如我电脑上的是jre1.8.0_191)复制到Android studio安装位置中jre的文件夹中,选择覆盖相同的文件\n3.复制java安装目录中的jdk文件夹(比如我电脑上的是jdk1.8.0_121)\\lib下的tool到Android studio安装位置中jre\\lib中,重启as即可\n4.字体会发生改变,我用了consolas 18的字体,看起来比较舒服\n\n取消双击shift搜索全局(来自:[知乎](https://www.zhihu.com/question/266147247/answer/368247772)):\n1.在窗口点击Ctrl+shift+A复合键，如下图，搜索registry,选择action里面的一项\n2.找到ide.suppress.double.click.handler选项，打钩 即可\n","source":"_posts/android-studio中文候选框不会跟随光标.md","raw":"---\ntitle: android studio中文候选框不会跟随光标\ndate: 2018-12-12 16:22:04\ntags:\n- android studio\n---\n(百度了IDEA不会跟随和Android studio不会跟随总结出来的方法)\n1.找到Android studio的安装位置,将其jre文件复制一份出来,这时会有jre - 副本(用来防治万一出现问题可以复原)和jre两个文件夹\n2.找到Java安装位置,把其中jre文件夹(比如我电脑上的是jre1.8.0_191)复制到Android studio安装位置中jre的文件夹中,选择覆盖相同的文件\n3.复制java安装目录中的jdk文件夹(比如我电脑上的是jdk1.8.0_121)\\lib下的tool到Android studio安装位置中jre\\lib中,重启as即可\n4.字体会发生改变,我用了consolas 18的字体,看起来比较舒服\n\n取消双击shift搜索全局(来自:[知乎](https://www.zhihu.com/question/266147247/answer/368247772)):\n1.在窗口点击Ctrl+shift+A复合键，如下图，搜索registry,选择action里面的一项\n2.找到ide.suppress.double.click.handler选项，打钩 即可\n","slug":"android-studio中文候选框不会跟随光标","published":1,"updated":"2020-03-31T05:41:12.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje72000f9otsdz2hiwoz","content":"<p>(百度了IDEA不会跟随和Android studio不会跟随总结出来的方法)<br>1.找到Android studio的安装位置,将其jre文件复制一份出来,这时会有jre - 副本(用来防治万一出现问题可以复原)和jre两个文件夹<br>2.找到Java安装位置,把其中jre文件夹(比如我电脑上的是jre1.8.0_191)复制到Android studio安装位置中jre的文件夹中,选择覆盖相同的文件<br>3.复制java安装目录中的jdk文件夹(比如我电脑上的是jdk1.8.0_121)\\lib下的tool到Android studio安装位置中jre\\lib中,重启as即可<br>4.字体会发生改变,我用了consolas 18的字体,看起来比较舒服</p>\n<p>取消双击shift搜索全局(来自:<a href=\"https://www.zhihu.com/question/266147247/answer/368247772\" target=\"_blank\" rel=\"noopener\">知乎</a>):<br>1.在窗口点击Ctrl+shift+A复合键，如下图，搜索registry,选择action里面的一项<br>2.找到ide.suppress.double.click.handler选项，打钩 即可</p>\n","site":{"data":{}},"excerpt":"","more":"<p>(百度了IDEA不会跟随和Android studio不会跟随总结出来的方法)<br>1.找到Android studio的安装位置,将其jre文件复制一份出来,这时会有jre - 副本(用来防治万一出现问题可以复原)和jre两个文件夹<br>2.找到Java安装位置,把其中jre文件夹(比如我电脑上的是jre1.8.0_191)复制到Android studio安装位置中jre的文件夹中,选择覆盖相同的文件<br>3.复制java安装目录中的jdk文件夹(比如我电脑上的是jdk1.8.0_121)\\lib下的tool到Android studio安装位置中jre\\lib中,重启as即可<br>4.字体会发生改变,我用了consolas 18的字体,看起来比较舒服</p>\n<p>取消双击shift搜索全局(来自:<a href=\"https://www.zhihu.com/question/266147247/answer/368247772\" target=\"_blank\" rel=\"noopener\">知乎</a>):<br>1.在窗口点击Ctrl+shift+A复合键，如下图，搜索registry,选择action里面的一项<br>2.找到ide.suppress.double.click.handler选项，打钩 即可</p>\n"},{"title":"androidt图片保存的坑","date":"2018-07-04T16:24:56.000Z","_content":"很久很久都没写过这一方面的东西了真的太生疏了,都忘记保存图片到本地了,所以写一篇记一下自己的愚昧\n\n首次用最简单的方法BitmapFactory\n\n<span style=\"color:red;\">Unable to decode stream: java.io.FileNotFoundException</span>\n\n报错?很不能理解这是为什么啊,思来想去了很久没找到原因,百度下了,结果发现权限没加,太蠢了,遂加上权限\n\n``\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>``\n\n还是不行,在仔细想想,Android6.0以上权限是需要用户授权的,又加上授权\n``\n  if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED){\n​            ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1);\n​        }\n``\n(具体怎么加就不说了)\n\n在行了吧,还是不行,到底怎么回事呢,到了这一步,还是提示之前的错误,那就不是权限的问题了,是文件真的\n找不到了,看了看路径,我是放在\n``\nEnvironment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \"pics\"+ File.separator;\n``\n\n难道是这个文件夹不存在? 可能是加了几行代码判断了下\n``\n​     File file=new File(DISK_URL);\n​            if(!file.exists())\n​                file.mkdir();\n``\n可以了? 就这样?有点蒙,算是解决了吧,突然意识到Android并没有这么省心,每一个\"/\"代表了一层文件夹路径\n,如果文件夹不存在的话,就要主动去创建(?有没有什么更好的办法?可以找找),那是不是和权限的关系不大?\n\n接着试了吧权限删除\n\n两个字 不行..\n\n还是要加权限啊,不然不让你保存\n\n嗯就这样\n\n2019-03-04 PS:写Android还是会忘记权限的事情,最简单网络访问,还是会把网络权限给忘了添加,更别说权限需要申请了\n","source":"_posts/androidt图片保存的坑.md","raw":"---\ntitle: androidt图片保存的坑\ndate: 2018-07-05 00:24:56\ntags:\n- android\n---\n很久很久都没写过这一方面的东西了真的太生疏了,都忘记保存图片到本地了,所以写一篇记一下自己的愚昧\n\n首次用最简单的方法BitmapFactory\n\n<span style=\"color:red;\">Unable to decode stream: java.io.FileNotFoundException</span>\n\n报错?很不能理解这是为什么啊,思来想去了很久没找到原因,百度下了,结果发现权限没加,太蠢了,遂加上权限\n\n``\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>``\n\n还是不行,在仔细想想,Android6.0以上权限是需要用户授权的,又加上授权\n``\n  if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED){\n​            ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1);\n​        }\n``\n(具体怎么加就不说了)\n\n在行了吧,还是不行,到底怎么回事呢,到了这一步,还是提示之前的错误,那就不是权限的问题了,是文件真的\n找不到了,看了看路径,我是放在\n``\nEnvironment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \"pics\"+ File.separator;\n``\n\n难道是这个文件夹不存在? 可能是加了几行代码判断了下\n``\n​     File file=new File(DISK_URL);\n​            if(!file.exists())\n​                file.mkdir();\n``\n可以了? 就这样?有点蒙,算是解决了吧,突然意识到Android并没有这么省心,每一个\"/\"代表了一层文件夹路径\n,如果文件夹不存在的话,就要主动去创建(?有没有什么更好的办法?可以找找),那是不是和权限的关系不大?\n\n接着试了吧权限删除\n\n两个字 不行..\n\n还是要加权限啊,不然不让你保存\n\n嗯就这样\n\n2019-03-04 PS:写Android还是会忘记权限的事情,最简单网络访问,还是会把网络权限给忘了添加,更别说权限需要申请了\n","slug":"androidt图片保存的坑","published":1,"updated":"2020-03-31T05:41:12.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje78000i9otswndvjj3z","content":"<p>很久很久都没写过这一方面的东西了真的太生疏了,都忘记保存图片到本地了,所以写一篇记一下自己的愚昧</p>\n<p>首次用最简单的方法BitmapFactory</p>\n<p><span style=\"color:red;\">Unable to decode stream: java.io.FileNotFoundException</span></p>\n<p>报错?很不能理解这是为什么啊,思来想去了很久没找到原因,百度下了,结果发现权限没加,太蠢了,遂加上权限</p>\n<p><code></code></p>\n<p><uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"><code></code></uses-permission></p>\n<p>还是不行,在仔细想想,Android6.0以上权限是需要用户授权的,又加上授权<br><code>if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED){\n​            ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1);\n​        }</code><br>(具体怎么加就不说了)</p>\n<p>在行了吧,还是不行,到底怎么回事呢,到了这一步,还是提示之前的错误,那就不是权限的问题了,是文件真的<br>找不到了,看了看路径,我是放在<br><code>Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;pics&quot;+ File.separator;</code></p>\n<p>难道是这个文件夹不存在? 可能是加了几行代码判断了下<br><code>​     File file=new File(DISK_URL);\n​            if(!file.exists())\n​                file.mkdir();</code><br>可以了? 就这样?有点蒙,算是解决了吧,突然意识到Android并没有这么省心,每一个”/“代表了一层文件夹路径<br>,如果文件夹不存在的话,就要主动去创建(?有没有什么更好的办法?可以找找),那是不是和权限的关系不大?</p>\n<p>接着试了吧权限删除</p>\n<p>两个字 不行..</p>\n<p>还是要加权限啊,不然不让你保存</p>\n<p>嗯就这样</p>\n<p>2019-03-04 PS:写Android还是会忘记权限的事情,最简单网络访问,还是会把网络权限给忘了添加,更别说权限需要申请了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很久很久都没写过这一方面的东西了真的太生疏了,都忘记保存图片到本地了,所以写一篇记一下自己的愚昧</p>\n<p>首次用最简单的方法BitmapFactory</p>\n<p><span style=\"color:red;\">Unable to decode stream: java.io.FileNotFoundException</span></p>\n<p>报错?很不能理解这是为什么啊,思来想去了很久没找到原因,百度下了,结果发现权限没加,太蠢了,遂加上权限</p>\n<p><code></code></p>\n<p><uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"><code></code></uses-permission></p>\n<p>还是不行,在仔细想想,Android6.0以上权限是需要用户授权的,又加上授权<br><code>if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED){\n​            ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1);\n​        }</code><br>(具体怎么加就不说了)</p>\n<p>在行了吧,还是不行,到底怎么回事呢,到了这一步,还是提示之前的错误,那就不是权限的问题了,是文件真的<br>找不到了,看了看路径,我是放在<br><code>Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;pics&quot;+ File.separator;</code></p>\n<p>难道是这个文件夹不存在? 可能是加了几行代码判断了下<br><code>​     File file=new File(DISK_URL);\n​            if(!file.exists())\n​                file.mkdir();</code><br>可以了? 就这样?有点蒙,算是解决了吧,突然意识到Android并没有这么省心,每一个”/“代表了一层文件夹路径<br>,如果文件夹不存在的话,就要主动去创建(?有没有什么更好的办法?可以找找),那是不是和权限的关系不大?</p>\n<p>接着试了吧权限删除</p>\n<p>两个字 不行..</p>\n<p>还是要加权限啊,不然不让你保存</p>\n<p>嗯就这样</p>\n<p>2019-03-04 PS:写Android还是会忘记权限的事情,最简单网络访问,还是会把网络权限给忘了添加,更别说权限需要申请了</p>\n"},{"title":"android中文字的绘制","date":"2018-12-12T06:11:15.000Z","_content":"paint中对于绘制文字的函数\n\n\n    //对齐方式 Paint.Align.LEFT:从左边像右边画  Paint.Align.CENTER:从中间像两侧话  Paint.Align.RIGHT:从右像左画 开始位置就是画图的起始位置\n    paint.setTextAlign(Paint.Align.RIGHT);\n    //是否有删除线\n    paint.setStrikeThruText(true);\n    //是否有下划线\n    paint.setUnderlineText(true);\n    //是否粗体\n    paint.setFakeBoldText(true);\n    //水平倾斜角度  负数向右倾斜 正数向左\n    paint.setTextSkewX(-0.25f);\n    //设置水平拉伸\n    paint.setTextScaleX(2);\n    //设置字体样式\n    paint.setTypeface(Typeface typeface)\n\ncanvas中绘制文字:\n\n    void drawText(String text, float x, float y,Paint paint)\n\n\n需要注意的是画图的起始位置X是文字的(对齐方式left:文字的左边 center:文字中间 right:文字右边 ),y是文字的底部\n\n![不同的对齐方式对绘制的影响](http://image.honglingqi.cn/blogImages/1212/20181212151507.jpg)\n\n    void drawText( String text, int start, int end, float x, float y,Paint paint)\n    void drawText( CharSequence text, int start, int end, float x, float y,Paint paint)\n和上面的基本相同,只是加了需要绘制的字符串起始位置和结束位置\nstart:起始绘制文字的索引\nend:完成绘制的索引\n如果start=0,end=text.length() 就和第一个方法没有区别\n\n    void drawText(char[] text, int index, int count, float x, float y,Paint paint)\nindex:起始绘制文字的索引\ncount:需要绘制的长度\n传入的是char数组\n\n    void drawPosText(String text, float[] pos,Paint paint)\n    void drawPosText(char[] text, float[] pos,Paint paint)\n这两个方法可以单独绘制每一个文字的位置\n\nfloat[] pos:表示坐标的数组,格式为{x1,y1,x2,y2......}\n\n    void drawTextOnPath( String text,  Path path, float hOffset,float vOffset,  Paint paint)\n    void drawTextOnPath( char[] text,  Path path, float hOffset,float vOffset,  Paint paint)\n这两个方法可以沿着路径绘制文字\nhOffset:The distance along the path to add to the text's starting position(要添加到文本起始位置的路径的距离);\nvOffset:he distance above(-) or below(+) the path to position the text(他在（-）或低于（+）的路径上进行距离以定位文本);\n简单的理解就是hOffset表示在正常情况下绘制X轴方向的偏移量,vOffset表示Y轴的偏移量\n","source":"_posts/android中文字的绘制.md","raw":"---\ntitle: android中文字的绘制\ndate: 2018-12-12 14:11:15\ntags:\n- android\n---\npaint中对于绘制文字的函数\n\n\n    //对齐方式 Paint.Align.LEFT:从左边像右边画  Paint.Align.CENTER:从中间像两侧话  Paint.Align.RIGHT:从右像左画 开始位置就是画图的起始位置\n    paint.setTextAlign(Paint.Align.RIGHT);\n    //是否有删除线\n    paint.setStrikeThruText(true);\n    //是否有下划线\n    paint.setUnderlineText(true);\n    //是否粗体\n    paint.setFakeBoldText(true);\n    //水平倾斜角度  负数向右倾斜 正数向左\n    paint.setTextSkewX(-0.25f);\n    //设置水平拉伸\n    paint.setTextScaleX(2);\n    //设置字体样式\n    paint.setTypeface(Typeface typeface)\n\ncanvas中绘制文字:\n\n    void drawText(String text, float x, float y,Paint paint)\n\n\n需要注意的是画图的起始位置X是文字的(对齐方式left:文字的左边 center:文字中间 right:文字右边 ),y是文字的底部\n\n![不同的对齐方式对绘制的影响](http://image.honglingqi.cn/blogImages/1212/20181212151507.jpg)\n\n    void drawText( String text, int start, int end, float x, float y,Paint paint)\n    void drawText( CharSequence text, int start, int end, float x, float y,Paint paint)\n和上面的基本相同,只是加了需要绘制的字符串起始位置和结束位置\nstart:起始绘制文字的索引\nend:完成绘制的索引\n如果start=0,end=text.length() 就和第一个方法没有区别\n\n    void drawText(char[] text, int index, int count, float x, float y,Paint paint)\nindex:起始绘制文字的索引\ncount:需要绘制的长度\n传入的是char数组\n\n    void drawPosText(String text, float[] pos,Paint paint)\n    void drawPosText(char[] text, float[] pos,Paint paint)\n这两个方法可以单独绘制每一个文字的位置\n\nfloat[] pos:表示坐标的数组,格式为{x1,y1,x2,y2......}\n\n    void drawTextOnPath( String text,  Path path, float hOffset,float vOffset,  Paint paint)\n    void drawTextOnPath( char[] text,  Path path, float hOffset,float vOffset,  Paint paint)\n这两个方法可以沿着路径绘制文字\nhOffset:The distance along the path to add to the text's starting position(要添加到文本起始位置的路径的距离);\nvOffset:he distance above(-) or below(+) the path to position the text(他在（-）或低于（+）的路径上进行距离以定位文本);\n简单的理解就是hOffset表示在正常情况下绘制X轴方向的偏移量,vOffset表示Y轴的偏移量\n","slug":"android中文字的绘制","published":1,"updated":"2020-03-31T05:41:12.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje7b000k9ots7a0p9r1n","content":"<p>paint中对于绘制文字的函数</p>\n<pre><code>//对齐方式 Paint.Align.LEFT:从左边像右边画  Paint.Align.CENTER:从中间像两侧话  Paint.Align.RIGHT:从右像左画 开始位置就是画图的起始位置\npaint.setTextAlign(Paint.Align.RIGHT);\n//是否有删除线\npaint.setStrikeThruText(true);\n//是否有下划线\npaint.setUnderlineText(true);\n//是否粗体\npaint.setFakeBoldText(true);\n//水平倾斜角度  负数向右倾斜 正数向左\npaint.setTextSkewX(-0.25f);\n//设置水平拉伸\npaint.setTextScaleX(2);\n//设置字体样式\npaint.setTypeface(Typeface typeface)\n</code></pre><p>canvas中绘制文字:</p>\n<pre><code>void drawText(String text, float x, float y,Paint paint)\n</code></pre><p>需要注意的是画图的起始位置X是文字的(对齐方式left:文字的左边 center:文字中间 right:文字右边 ),y是文字的底部</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1212/20181212151507.jpg\" alt=\"不同的对齐方式对绘制的影响\"></p>\n<pre><code>void drawText( String text, int start, int end, float x, float y,Paint paint)\nvoid drawText( CharSequence text, int start, int end, float x, float y,Paint paint)\n</code></pre><p>和上面的基本相同,只是加了需要绘制的字符串起始位置和结束位置<br>start:起始绘制文字的索引<br>end:完成绘制的索引<br>如果start=0,end=text.length() 就和第一个方法没有区别</p>\n<pre><code>void drawText(char[] text, int index, int count, float x, float y,Paint paint)\n</code></pre><p>index:起始绘制文字的索引<br>count:需要绘制的长度<br>传入的是char数组</p>\n<pre><code>void drawPosText(String text, float[] pos,Paint paint)\nvoid drawPosText(char[] text, float[] pos,Paint paint)\n</code></pre><p>这两个方法可以单独绘制每一个文字的位置</p>\n<p>float[] pos:表示坐标的数组,格式为{x1,y1,x2,y2……}</p>\n<pre><code>void drawTextOnPath( String text,  Path path, float hOffset,float vOffset,  Paint paint)\nvoid drawTextOnPath( char[] text,  Path path, float hOffset,float vOffset,  Paint paint)\n</code></pre><p>这两个方法可以沿着路径绘制文字<br>hOffset:The distance along the path to add to the text’s starting position(要添加到文本起始位置的路径的距离);<br>vOffset:he distance above(-) or below(+) the path to position the text(他在（-）或低于（+）的路径上进行距离以定位文本);<br>简单的理解就是hOffset表示在正常情况下绘制X轴方向的偏移量,vOffset表示Y轴的偏移量</p>\n","site":{"data":{}},"excerpt":"","more":"<p>paint中对于绘制文字的函数</p>\n<pre><code>//对齐方式 Paint.Align.LEFT:从左边像右边画  Paint.Align.CENTER:从中间像两侧话  Paint.Align.RIGHT:从右像左画 开始位置就是画图的起始位置\npaint.setTextAlign(Paint.Align.RIGHT);\n//是否有删除线\npaint.setStrikeThruText(true);\n//是否有下划线\npaint.setUnderlineText(true);\n//是否粗体\npaint.setFakeBoldText(true);\n//水平倾斜角度  负数向右倾斜 正数向左\npaint.setTextSkewX(-0.25f);\n//设置水平拉伸\npaint.setTextScaleX(2);\n//设置字体样式\npaint.setTypeface(Typeface typeface)\n</code></pre><p>canvas中绘制文字:</p>\n<pre><code>void drawText(String text, float x, float y,Paint paint)\n</code></pre><p>需要注意的是画图的起始位置X是文字的(对齐方式left:文字的左边 center:文字中间 right:文字右边 ),y是文字的底部</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1212/20181212151507.jpg\" alt=\"不同的对齐方式对绘制的影响\"></p>\n<pre><code>void drawText( String text, int start, int end, float x, float y,Paint paint)\nvoid drawText( CharSequence text, int start, int end, float x, float y,Paint paint)\n</code></pre><p>和上面的基本相同,只是加了需要绘制的字符串起始位置和结束位置<br>start:起始绘制文字的索引<br>end:完成绘制的索引<br>如果start=0,end=text.length() 就和第一个方法没有区别</p>\n<pre><code>void drawText(char[] text, int index, int count, float x, float y,Paint paint)\n</code></pre><p>index:起始绘制文字的索引<br>count:需要绘制的长度<br>传入的是char数组</p>\n<pre><code>void drawPosText(String text, float[] pos,Paint paint)\nvoid drawPosText(char[] text, float[] pos,Paint paint)\n</code></pre><p>这两个方法可以单独绘制每一个文字的位置</p>\n<p>float[] pos:表示坐标的数组,格式为{x1,y1,x2,y2……}</p>\n<pre><code>void drawTextOnPath( String text,  Path path, float hOffset,float vOffset,  Paint paint)\nvoid drawTextOnPath( char[] text,  Path path, float hOffset,float vOffset,  Paint paint)\n</code></pre><p>这两个方法可以沿着路径绘制文字<br>hOffset:The distance along the path to add to the text’s starting position(要添加到文本起始位置的路径的距离);<br>vOffset:he distance above(-) or below(+) the path to position the text(他在（-）或低于（+）的路径上进行距离以定位文本);<br>简单的理解就是hOffset表示在正常情况下绘制X轴方向的偏移量,vOffset表示Y轴的偏移量</p>\n"},{"title":"dataBinding使用小记","date":"2019-02-28T02:02:58.000Z","_content":"因为不可能一次性写完,遇到一点写一点\n## 开启dataBinding\n\n* 在app下的build.gradle中加入:\n     dataBinding.enabled = true\n\n2019-02-28:\n* 实现双向绑定\n\n下面是一个简易的dataBinding的Demo:\n\n\n            User user=new User();\n            ActivityMainBinding binding;\n            boolean flag=false;\n            @Override\n            protected void onCreate(Bundle savedInstanceState) {\n                super.onCreate(savedInstanceState);\n                binding=DataBindingUtil.setContentView(this,R.layout.activity_main);\n\n                user.age=23;\n                user.sex=\"men\";\n                user.name=\"Tony\";\n                binding.setUser(user);\n\n            }\n\n            public void change(View view) {\n                if(flag){\n                    user.setName(\"Tony\");\n                    user.setSex(\"men\");\n                    user.setAge(23);\n                }else {\n                    user.setName(\"Kitty\");\n                    user.setSex(\"women\");\n                    user.setAge(20);\n                }\n                binding.setUser(user);\n                flag=!flag;\n            }\n\n其中change是按钮的点击事件来更新页面上显示的参数,User是一个简单的javaBean\n\n很典型的每次在数据切换时,我们都会调用binding.setUser(user)来设置新数据\n\n重写User\n\n\n        public class User extends BaseObservable {\n            public String name;\n            public int age;\n            public String sex;\n            @Bindable\n            public String getName() {\n                return name;\n            }\n\n            public void setName(String name) {\n                this.name = name;\n                notifyPropertyChanged(BR.name);\n            }\n            @Bindable\n            public int getAge() {\n                return age;\n            }\n\n            public void setAge(int age) {\n                this.age = age;\n                notifyPropertyChanged(BR.age);\n            }\n            @Bindable\n            public String getSex() {\n                return sex;\n            }\n\n            public void setSex(String sex) {\n                this.sex = sex;\n                notifyPropertyChanged(BR.sex);\n            }\n        }\n在每个set方法里面加入了notifyPropertyChanged(),每个get()方法加上注解@Bindable  这样只要每次更新我们关心的数据就好了\n\n上面是针对对象,如果只是某一个数值,那么可以使用ObservableField<T> 来 定义  然后再xml里面使用\n","source":"_posts/dataBinding使用小记.md","raw":"---\ntitle: dataBinding使用小记\ndate: 2019-02-28 10:02:58\ntags:\n- android\n---\n因为不可能一次性写完,遇到一点写一点\n## 开启dataBinding\n\n* 在app下的build.gradle中加入:\n     dataBinding.enabled = true\n\n2019-02-28:\n* 实现双向绑定\n\n下面是一个简易的dataBinding的Demo:\n\n\n            User user=new User();\n            ActivityMainBinding binding;\n            boolean flag=false;\n            @Override\n            protected void onCreate(Bundle savedInstanceState) {\n                super.onCreate(savedInstanceState);\n                binding=DataBindingUtil.setContentView(this,R.layout.activity_main);\n\n                user.age=23;\n                user.sex=\"men\";\n                user.name=\"Tony\";\n                binding.setUser(user);\n\n            }\n\n            public void change(View view) {\n                if(flag){\n                    user.setName(\"Tony\");\n                    user.setSex(\"men\");\n                    user.setAge(23);\n                }else {\n                    user.setName(\"Kitty\");\n                    user.setSex(\"women\");\n                    user.setAge(20);\n                }\n                binding.setUser(user);\n                flag=!flag;\n            }\n\n其中change是按钮的点击事件来更新页面上显示的参数,User是一个简单的javaBean\n\n很典型的每次在数据切换时,我们都会调用binding.setUser(user)来设置新数据\n\n重写User\n\n\n        public class User extends BaseObservable {\n            public String name;\n            public int age;\n            public String sex;\n            @Bindable\n            public String getName() {\n                return name;\n            }\n\n            public void setName(String name) {\n                this.name = name;\n                notifyPropertyChanged(BR.name);\n            }\n            @Bindable\n            public int getAge() {\n                return age;\n            }\n\n            public void setAge(int age) {\n                this.age = age;\n                notifyPropertyChanged(BR.age);\n            }\n            @Bindable\n            public String getSex() {\n                return sex;\n            }\n\n            public void setSex(String sex) {\n                this.sex = sex;\n                notifyPropertyChanged(BR.sex);\n            }\n        }\n在每个set方法里面加入了notifyPropertyChanged(),每个get()方法加上注解@Bindable  这样只要每次更新我们关心的数据就好了\n\n上面是针对对象,如果只是某一个数值,那么可以使用ObservableField<T> 来 定义  然后再xml里面使用\n","slug":"dataBinding使用小记","published":1,"updated":"2020-03-31T05:41:12.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje8f000q9otswkdqaqbk","content":"<p>因为不可能一次性写完,遇到一点写一点</p>\n<h2 id=\"开启dataBinding\"><a href=\"#开启dataBinding\" class=\"headerlink\" title=\"开启dataBinding\"></a>开启dataBinding</h2><ul>\n<li>在app下的build.gradle中加入:<br>   dataBinding.enabled = true</li>\n</ul>\n<p>2019-02-28:</p>\n<ul>\n<li>实现双向绑定</li>\n</ul>\n<p>下面是一个简易的dataBinding的Demo:</p>\n<pre><code>User user=new User();\nActivityMainBinding binding;\nboolean flag=false;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    binding=DataBindingUtil.setContentView(this,R.layout.activity_main);\n\n    user.age=23;\n    user.sex=&quot;men&quot;;\n    user.name=&quot;Tony&quot;;\n    binding.setUser(user);\n\n}\n\npublic void change(View view) {\n    if(flag){\n        user.setName(&quot;Tony&quot;);\n        user.setSex(&quot;men&quot;);\n        user.setAge(23);\n    }else {\n        user.setName(&quot;Kitty&quot;);\n        user.setSex(&quot;women&quot;);\n        user.setAge(20);\n    }\n    binding.setUser(user);\n    flag=!flag;\n}\n</code></pre><p>其中change是按钮的点击事件来更新页面上显示的参数,User是一个简单的javaBean</p>\n<p>很典型的每次在数据切换时,我们都会调用binding.setUser(user)来设置新数据</p>\n<p>重写User</p>\n<pre><code>public class User extends BaseObservable {\n    public String name;\n    public int age;\n    public String sex;\n    @Bindable\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n        notifyPropertyChanged(BR.name);\n    }\n    @Bindable\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n        notifyPropertyChanged(BR.age);\n    }\n    @Bindable\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n        notifyPropertyChanged(BR.sex);\n    }\n}\n</code></pre><p>在每个set方法里面加入了notifyPropertyChanged(),每个get()方法加上注解@Bindable  这样只要每次更新我们关心的数据就好了</p>\n<p>上面是针对对象,如果只是某一个数值,那么可以使用ObservableField<t> 来 定义  然后再xml里面使用</t></p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为不可能一次性写完,遇到一点写一点</p>\n<h2 id=\"开启dataBinding\"><a href=\"#开启dataBinding\" class=\"headerlink\" title=\"开启dataBinding\"></a>开启dataBinding</h2><ul>\n<li>在app下的build.gradle中加入:<br>   dataBinding.enabled = true</li>\n</ul>\n<p>2019-02-28:</p>\n<ul>\n<li>实现双向绑定</li>\n</ul>\n<p>下面是一个简易的dataBinding的Demo:</p>\n<pre><code>User user=new User();\nActivityMainBinding binding;\nboolean flag=false;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    binding=DataBindingUtil.setContentView(this,R.layout.activity_main);\n\n    user.age=23;\n    user.sex=&quot;men&quot;;\n    user.name=&quot;Tony&quot;;\n    binding.setUser(user);\n\n}\n\npublic void change(View view) {\n    if(flag){\n        user.setName(&quot;Tony&quot;);\n        user.setSex(&quot;men&quot;);\n        user.setAge(23);\n    }else {\n        user.setName(&quot;Kitty&quot;);\n        user.setSex(&quot;women&quot;);\n        user.setAge(20);\n    }\n    binding.setUser(user);\n    flag=!flag;\n}\n</code></pre><p>其中change是按钮的点击事件来更新页面上显示的参数,User是一个简单的javaBean</p>\n<p>很典型的每次在数据切换时,我们都会调用binding.setUser(user)来设置新数据</p>\n<p>重写User</p>\n<pre><code>public class User extends BaseObservable {\n    public String name;\n    public int age;\n    public String sex;\n    @Bindable\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n        notifyPropertyChanged(BR.name);\n    }\n    @Bindable\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n        notifyPropertyChanged(BR.age);\n    }\n    @Bindable\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n        notifyPropertyChanged(BR.sex);\n    }\n}\n</code></pre><p>在每个set方法里面加入了notifyPropertyChanged(),每个get()方法加上注解@Bindable  这样只要每次更新我们关心的数据就好了</p>\n<p>上面是针对对象,如果只是某一个数值,那么可以使用ObservableField<t> 来 定义  然后再xml里面使用</t></p>\n"},{"title":"android路由","date":"2019-02-24T12:12:04.000Z","_content":"感想:\n\n1.找了差不多两周的工作了吧,面试的十几家,都快自闭了,也不是没人要我,但是就是不满意薪资,谢谢这家公司可以给我这个机会\n去开发Android,加油吧\n\n2.看了这个代码,我才发现,自己之前写的Android代码都是什么辣鸡,就这一个项目够我学的了\n\n回归正题:\n\n在之前的面试就很奇怪,有人问我Android无协议跳转有没有用过,我一脸懵逼,这到底是个什么东西,知道看到了这个项目,我才反应过来,哦,原来如此\n\n路由的由来:Android之前的页面跳转,都是用intent来实现的,而且大家也都是这么做的,但是一旦项目庞大起来,页面越来越来\n利用intent来构建跳转会变得会变得越来越难维护,比如有多个页面需要跳转到MainActivity,那么一般的形式会\n\n\n        Intent intent=new Intent(context,MainActivity.class);\n        startActivity(intent)\n现在需求改变,统一跳转到MainActivity2页面,那么就需要在这些页面里面都要把MainActivity.class改成MainActivity2.class\n,非常麻烦,而且像我这么粗心的程序员,还可能改错或者漏改\n\n为了解决这种问题,相当于给页面之间解耦,降低页面之间的依赖,所以就出现了路由的方式:\n\n页面统一都打上一个标签,表明需要跳转到哪一个页面,采用统一的方式进行跳转,然后传的参数就是标签,也可以带上自己的参数\n这样的话,需要改变跳转的页面,只需要改变页面的标签就好了,\n\n说了很多,下面看看实例,我采用的是[ActivityRouter](https://github.com/mzule/ActivityRouter)框架\n\n1.引入 在app下的build.gradle添加如下\n\n     compile 'com.github.mzule.activityrouter:activityrouter:1.2.2'\n     annotationProcessor 'com.github.mzule.activityrouter:compiler:1.1.7'\n\n2.集成框架:在AndroidManifest.xml加入如下\n\n\n        <activity\n            android:name=\"com.github.mzule.activityrouter.router.RouterActivity\"\n            android:theme=\"@android:style/Theme.NoDisplay\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"mzule\" /><!--改成自己的scheme-->\n            </intent-filter>\n        </activity>\n\nPS:一开始非常诧异为什么他可以做到这么跳转,直到看到这个,我想应该就是统一跳转到RouterActivity页面,然后再根据路由表(就是页面和标签的配对文件)\n去找,然后在进行二次跳转并关闭这个页面\n","source":"_posts/android路由.md","raw":"---\ntitle: android路由\ndate: 2019-02-24 20:12:04\ntags:\n- android\n---\n感想:\n\n1.找了差不多两周的工作了吧,面试的十几家,都快自闭了,也不是没人要我,但是就是不满意薪资,谢谢这家公司可以给我这个机会\n去开发Android,加油吧\n\n2.看了这个代码,我才发现,自己之前写的Android代码都是什么辣鸡,就这一个项目够我学的了\n\n回归正题:\n\n在之前的面试就很奇怪,有人问我Android无协议跳转有没有用过,我一脸懵逼,这到底是个什么东西,知道看到了这个项目,我才反应过来,哦,原来如此\n\n路由的由来:Android之前的页面跳转,都是用intent来实现的,而且大家也都是这么做的,但是一旦项目庞大起来,页面越来越来\n利用intent来构建跳转会变得会变得越来越难维护,比如有多个页面需要跳转到MainActivity,那么一般的形式会\n\n\n        Intent intent=new Intent(context,MainActivity.class);\n        startActivity(intent)\n现在需求改变,统一跳转到MainActivity2页面,那么就需要在这些页面里面都要把MainActivity.class改成MainActivity2.class\n,非常麻烦,而且像我这么粗心的程序员,还可能改错或者漏改\n\n为了解决这种问题,相当于给页面之间解耦,降低页面之间的依赖,所以就出现了路由的方式:\n\n页面统一都打上一个标签,表明需要跳转到哪一个页面,采用统一的方式进行跳转,然后传的参数就是标签,也可以带上自己的参数\n这样的话,需要改变跳转的页面,只需要改变页面的标签就好了,\n\n说了很多,下面看看实例,我采用的是[ActivityRouter](https://github.com/mzule/ActivityRouter)框架\n\n1.引入 在app下的build.gradle添加如下\n\n     compile 'com.github.mzule.activityrouter:activityrouter:1.2.2'\n     annotationProcessor 'com.github.mzule.activityrouter:compiler:1.1.7'\n\n2.集成框架:在AndroidManifest.xml加入如下\n\n\n        <activity\n            android:name=\"com.github.mzule.activityrouter.router.RouterActivity\"\n            android:theme=\"@android:style/Theme.NoDisplay\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"mzule\" /><!--改成自己的scheme-->\n            </intent-filter>\n        </activity>\n\nPS:一开始非常诧异为什么他可以做到这么跳转,直到看到这个,我想应该就是统一跳转到RouterActivity页面,然后再根据路由表(就是页面和标签的配对文件)\n去找,然后在进行二次跳转并关闭这个页面\n","slug":"android路由","published":1,"updated":"2020-03-31T05:41:12.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje8m000s9otschkryha4","content":"<p>感想:</p>\n<p>1.找了差不多两周的工作了吧,面试的十几家,都快自闭了,也不是没人要我,但是就是不满意薪资,谢谢这家公司可以给我这个机会<br>去开发Android,加油吧</p>\n<p>2.看了这个代码,我才发现,自己之前写的Android代码都是什么辣鸡,就这一个项目够我学的了</p>\n<p>回归正题:</p>\n<p>在之前的面试就很奇怪,有人问我Android无协议跳转有没有用过,我一脸懵逼,这到底是个什么东西,知道看到了这个项目,我才反应过来,哦,原来如此</p>\n<p>路由的由来:Android之前的页面跳转,都是用intent来实现的,而且大家也都是这么做的,但是一旦项目庞大起来,页面越来越来<br>利用intent来构建跳转会变得会变得越来越难维护,比如有多个页面需要跳转到MainActivity,那么一般的形式会</p>\n<pre><code>Intent intent=new Intent(context,MainActivity.class);\nstartActivity(intent)\n</code></pre><p>现在需求改变,统一跳转到MainActivity2页面,那么就需要在这些页面里面都要把MainActivity.class改成MainActivity2.class<br>,非常麻烦,而且像我这么粗心的程序员,还可能改错或者漏改</p>\n<p>为了解决这种问题,相当于给页面之间解耦,降低页面之间的依赖,所以就出现了路由的方式:</p>\n<p>页面统一都打上一个标签,表明需要跳转到哪一个页面,采用统一的方式进行跳转,然后传的参数就是标签,也可以带上自己的参数<br>这样的话,需要改变跳转的页面,只需要改变页面的标签就好了,</p>\n<p>说了很多,下面看看实例,我采用的是<a href=\"https://github.com/mzule/ActivityRouter\">ActivityRouter</a>框架</p>\n<p>1.引入 在app下的build.gradle添加如下</p>\n<pre><code>compile &apos;com.github.mzule.activityrouter:activityrouter:1.2.2&apos;\nannotationProcessor &apos;com.github.mzule.activityrouter:compiler:1.1.7&apos;\n</code></pre><p>2.集成框架:在AndroidManifest.xml加入如下</p>\n<pre><code>&lt;activity\n    android:name=&quot;com.github.mzule.activityrouter.router.RouterActivity&quot;\n    android:theme=&quot;@android:style/Theme.NoDisplay&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;\n        &lt;data android:scheme=&quot;mzule&quot; /&gt;&lt;!--改成自己的scheme--&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre><p>PS:一开始非常诧异为什么他可以做到这么跳转,直到看到这个,我想应该就是统一跳转到RouterActivity页面,然后再根据路由表(就是页面和标签的配对文件)<br>去找,然后在进行二次跳转并关闭这个页面</p>\n","site":{"data":{}},"excerpt":"","more":"<p>感想:</p>\n<p>1.找了差不多两周的工作了吧,面试的十几家,都快自闭了,也不是没人要我,但是就是不满意薪资,谢谢这家公司可以给我这个机会<br>去开发Android,加油吧</p>\n<p>2.看了这个代码,我才发现,自己之前写的Android代码都是什么辣鸡,就这一个项目够我学的了</p>\n<p>回归正题:</p>\n<p>在之前的面试就很奇怪,有人问我Android无协议跳转有没有用过,我一脸懵逼,这到底是个什么东西,知道看到了这个项目,我才反应过来,哦,原来如此</p>\n<p>路由的由来:Android之前的页面跳转,都是用intent来实现的,而且大家也都是这么做的,但是一旦项目庞大起来,页面越来越来<br>利用intent来构建跳转会变得会变得越来越难维护,比如有多个页面需要跳转到MainActivity,那么一般的形式会</p>\n<pre><code>Intent intent=new Intent(context,MainActivity.class);\nstartActivity(intent)\n</code></pre><p>现在需求改变,统一跳转到MainActivity2页面,那么就需要在这些页面里面都要把MainActivity.class改成MainActivity2.class<br>,非常麻烦,而且像我这么粗心的程序员,还可能改错或者漏改</p>\n<p>为了解决这种问题,相当于给页面之间解耦,降低页面之间的依赖,所以就出现了路由的方式:</p>\n<p>页面统一都打上一个标签,表明需要跳转到哪一个页面,采用统一的方式进行跳转,然后传的参数就是标签,也可以带上自己的参数<br>这样的话,需要改变跳转的页面,只需要改变页面的标签就好了,</p>\n<p>说了很多,下面看看实例,我采用的是<a href=\"https://github.com/mzule/ActivityRouter\">ActivityRouter</a>框架</p>\n<p>1.引入 在app下的build.gradle添加如下</p>\n<pre><code>compile &apos;com.github.mzule.activityrouter:activityrouter:1.2.2&apos;\nannotationProcessor &apos;com.github.mzule.activityrouter:compiler:1.1.7&apos;\n</code></pre><p>2.集成框架:在AndroidManifest.xml加入如下</p>\n<pre><code>&lt;activity\n    android:name=&quot;com.github.mzule.activityrouter.router.RouterActivity&quot;\n    android:theme=&quot;@android:style/Theme.NoDisplay&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;\n        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;\n        &lt;data android:scheme=&quot;mzule&quot; /&gt;&lt;!--改成自己的scheme--&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre><p>PS:一开始非常诧异为什么他可以做到这么跳转,直到看到这个,我想应该就是统一跳转到RouterActivity页面,然后再根据路由表(就是页面和标签的配对文件)<br>去找,然后在进行二次跳转并关闭这个页面</p>\n"},{"title":"kotlin学习笔记","date":"2018-12-28T07:50:21.000Z","_content":"### ?:\nBoolean和Boolean?的区别:\nvar x:Boolean  x的取值可以为:true,false\nvar x:Boolean? x的取值可以为:true,false,null\n所以不能用Boolean?来判断if条件,如果要使用,那么可以用:\n\n        var x:Boolean?= null\n        if(x==true){\n\n        }\n来判断\n\n ### ?和!!的区别:\n?:\n\n    kotlin:a?.foo()\n    java: if(a!=null){\n       a.foo();\n      }\n\n!!:\n\n       kotlin:a!!.foo()\n       java: if(a!=null){\n          a.foo();\n        }else{\n          throw new KotlinNullPointException();\n        }\n\n?不会抛出空指针异常而!!会,\n\n?会使该类型多一个null的值,而!!不会\n\n### kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)\n\ninterface A{\n fun a()\n}\n\n要实现有两种方式\n\n1. 继承实现\n\n        class B :A{\n            fun a(){\n            }\n        }\nval test=B()\n2. 匿名内部类\n\n        val test=object:A{\n            fun a(){\n            }\n        }\n必须使用object,不能用其他代替,否则报错\n\n### until和..的区别\n\nfor(i in 0..10){}\nfor(i in 0 until 10){}\n两者区别在于 前者 [0,10] 后者[0,10)\n\n\n### kotlin中的类\n\n#### 多个构造函数\n\n\n```kotlin\n//第一种写法  使用super关键字\nclass A : View {\n    constructor(context: Context?):super(context)\n    constructor(context: Context?, attrs: AttributeSet?):super(context,attrs)\n    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int):super(context,attrs,defStyleAttr)\n}\n\n//第二种写法  \nclass A(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) :\n    LinearLayout(context, attrs, defStyleAttr) {\n    constructor(context: Context?):super(context,null,0)\n    constructor(context: Context?, attrs: AttributeSet?):this(context,attrs,0)\n}\n```\n第一种写法更加简洁明了\n\n#### 类初始化方法\nclass A{\n  init {\n       //初始化代码放在此处进行\n    }\n}","source":"_posts/kotlin学习笔记.md","raw":"---\ntitle: kotlin学习笔记\ndate: 2018-12-28 15:50:21\ntags:\n- kotlin\n---\n### ?:\nBoolean和Boolean?的区别:\nvar x:Boolean  x的取值可以为:true,false\nvar x:Boolean? x的取值可以为:true,false,null\n所以不能用Boolean?来判断if条件,如果要使用,那么可以用:\n\n        var x:Boolean?= null\n        if(x==true){\n\n        }\n来判断\n\n ### ?和!!的区别:\n?:\n\n    kotlin:a?.foo()\n    java: if(a!=null){\n       a.foo();\n      }\n\n!!:\n\n       kotlin:a!!.foo()\n       java: if(a!=null){\n          a.foo();\n        }else{\n          throw new KotlinNullPointException();\n        }\n\n?不会抛出空指针异常而!!会,\n\n?会使该类型多一个null的值,而!!不会\n\n### kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)\n\ninterface A{\n fun a()\n}\n\n要实现有两种方式\n\n1. 继承实现\n\n        class B :A{\n            fun a(){\n            }\n        }\nval test=B()\n2. 匿名内部类\n\n        val test=object:A{\n            fun a(){\n            }\n        }\n必须使用object,不能用其他代替,否则报错\n\n### until和..的区别\n\nfor(i in 0..10){}\nfor(i in 0 until 10){}\n两者区别在于 前者 [0,10] 后者[0,10)\n\n\n### kotlin中的类\n\n#### 多个构造函数\n\n\n```kotlin\n//第一种写法  使用super关键字\nclass A : View {\n    constructor(context: Context?):super(context)\n    constructor(context: Context?, attrs: AttributeSet?):super(context,attrs)\n    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int):super(context,attrs,defStyleAttr)\n}\n\n//第二种写法  \nclass A(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) :\n    LinearLayout(context, attrs, defStyleAttr) {\n    constructor(context: Context?):super(context,null,0)\n    constructor(context: Context?, attrs: AttributeSet?):this(context,attrs,0)\n}\n```\n第一种写法更加简洁明了\n\n#### 类初始化方法\nclass A{\n  init {\n       //初始化代码放在此处进行\n    }\n}","slug":"kotlin学习笔记","published":1,"updated":"2020-03-31T05:41:12.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje8t000v9otsnr5qhprh","content":"<h3 id><a href=\"#\" class=\"headerlink\" title=\"?:\"></a>?:</h3><p>Boolean和Boolean?的区别:<br>var x:Boolean  x的取值可以为:true,false<br>var x:Boolean? x的取值可以为:true,false,null<br>所以不能用Boolean?来判断if条件,如果要使用,那么可以用:</p>\n<pre><code>var x:Boolean?= null\nif(x==true){\n\n}\n</code></pre><p>来判断</p>\n<h3 id=\"和-的区别\"><a href=\"#和-的区别\" class=\"headerlink\" title=\"?和!!的区别:\"></a>?和!!的区别:</h3><p>?:</p>\n<pre><code>kotlin:a?.foo()\njava: if(a!=null){\n   a.foo();\n  }\n</code></pre><p>!!:</p>\n<pre><code>kotlin:a!!.foo()\njava: if(a!=null){\n   a.foo();\n }else{\n   throw new KotlinNullPointException();\n }\n</code></pre><p>?不会抛出空指针异常而!!会,</p>\n<p>?会使该类型多一个null的值,而!!不会</p>\n<h3 id=\"kotlin中接口使用-kotlin中不能直接按照使用类的方式来使用接口\"><a href=\"#kotlin中接口使用-kotlin中不能直接按照使用类的方式来使用接口\" class=\"headerlink\" title=\"kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)\"></a>kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)</h3><p>interface A{<br> fun a()<br>}</p>\n<p>要实现有两种方式</p>\n<ol>\n<li><p>继承实现</p>\n<pre><code>class B :A{\n    fun a(){\n    }\n}\n</code></pre><p>val test=B()</p>\n</li>\n<li><p>匿名内部类</p>\n<pre><code>val test=object:A{\n    fun a(){\n    }\n}\n</code></pre><p>必须使用object,不能用其他代替,否则报错</p>\n</li>\n</ol>\n<h3 id=\"until和-的区别\"><a href=\"#until和-的区别\" class=\"headerlink\" title=\"until和..的区别\"></a>until和..的区别</h3><p>for(i in 0..10){}<br>for(i in 0 until 10){}<br>两者区别在于 前者 [0,10] 后者[0,10)</p>\n<h3 id=\"kotlin中的类\"><a href=\"#kotlin中的类\" class=\"headerlink\" title=\"kotlin中的类\"></a>kotlin中的类</h3><h4 id=\"多个构造函数\"><a href=\"#多个构造函数\" class=\"headerlink\" title=\"多个构造函数\"></a>多个构造函数</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种写法  使用super关键字</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"type\">View &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?):<span class=\"keyword\">super</span>(context)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?):<span class=\"keyword\">super</span>(context,attrs)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class=\"built_in\">Int</span>):<span class=\"keyword\">super</span>(context,attrs,defStyleAttr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种写法  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class=\"built_in\">Int</span>) :</span><br><span class=\"line\">    LinearLayout(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?):<span class=\"keyword\">super</span>(context,<span class=\"literal\">null</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?):<span class=\"keyword\">this</span>(context,attrs,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一种写法更加简洁明了</p>\n<h4 id=\"类初始化方法\"><a href=\"#类初始化方法\" class=\"headerlink\" title=\"类初始化方法\"></a>类初始化方法</h4><p>class A{<br>  init {<br>       //初始化代码放在此处进行<br>    }<br>}</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id><a href=\"#\" class=\"headerlink\" title=\"?:\"></a>?:</h3><p>Boolean和Boolean?的区别:<br>var x:Boolean  x的取值可以为:true,false<br>var x:Boolean? x的取值可以为:true,false,null<br>所以不能用Boolean?来判断if条件,如果要使用,那么可以用:</p>\n<pre><code>var x:Boolean?= null\nif(x==true){\n\n}\n</code></pre><p>来判断</p>\n<h3 id=\"和-的区别\"><a href=\"#和-的区别\" class=\"headerlink\" title=\"?和!!的区别:\"></a>?和!!的区别:</h3><p>?:</p>\n<pre><code>kotlin:a?.foo()\njava: if(a!=null){\n   a.foo();\n  }\n</code></pre><p>!!:</p>\n<pre><code>kotlin:a!!.foo()\njava: if(a!=null){\n   a.foo();\n }else{\n   throw new KotlinNullPointException();\n }\n</code></pre><p>?不会抛出空指针异常而!!会,</p>\n<p>?会使该类型多一个null的值,而!!不会</p>\n<h3 id=\"kotlin中接口使用-kotlin中不能直接按照使用类的方式来使用接口\"><a href=\"#kotlin中接口使用-kotlin中不能直接按照使用类的方式来使用接口\" class=\"headerlink\" title=\"kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)\"></a>kotlin中接口使用(kotlin中不能直接按照使用类的方式来使用接口)</h3><p>interface A{<br> fun a()<br>}</p>\n<p>要实现有两种方式</p>\n<ol>\n<li><p>继承实现</p>\n<pre><code>class B :A{\n    fun a(){\n    }\n}\n</code></pre><p>val test=B()</p>\n</li>\n<li><p>匿名内部类</p>\n<pre><code>val test=object:A{\n    fun a(){\n    }\n}\n</code></pre><p>必须使用object,不能用其他代替,否则报错</p>\n</li>\n</ol>\n<h3 id=\"until和-的区别\"><a href=\"#until和-的区别\" class=\"headerlink\" title=\"until和..的区别\"></a>until和..的区别</h3><p>for(i in 0..10){}<br>for(i in 0 until 10){}<br>两者区别在于 前者 [0,10] 后者[0,10)</p>\n<h3 id=\"kotlin中的类\"><a href=\"#kotlin中的类\" class=\"headerlink\" title=\"kotlin中的类\"></a>kotlin中的类</h3><h4 id=\"多个构造函数\"><a href=\"#多个构造函数\" class=\"headerlink\" title=\"多个构造函数\"></a>多个构造函数</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种写法  使用super关键字</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> : <span class=\"type\">View &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?):<span class=\"keyword\">super</span>(context)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?):<span class=\"keyword\">super</span>(context,attrs)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class=\"built_in\">Int</span>):<span class=\"keyword\">super</span>(context,attrs,defStyleAttr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种写法  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class=\"built_in\">Int</span>) :</span><br><span class=\"line\">    LinearLayout(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?):<span class=\"keyword\">super</span>(context,<span class=\"literal\">null</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(context: Context?, attrs: AttributeSet?):<span class=\"keyword\">this</span>(context,attrs,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一种写法更加简洁明了</p>\n<h4 id=\"类初始化方法\"><a href=\"#类初始化方法\" class=\"headerlink\" title=\"类初始化方法\"></a>类初始化方法</h4><p>class A{<br>  init {<br>       //初始化代码放在此处进行<br>    }<br>}</p>\n"},{"title":"recyclerView分割线的源码阅读","date":"2018-09-02T12:20:15.000Z","_content":" recyclerview分割线是比较常用的功能吧,自己也想尝试一下如何添加,就想着去学习一下,看了网上的博客自己照着写了一下,但是发现还是阅读源码的方式稍微好一点把,因为Android\n 自己实现了分割线的方法, DividerItemDecoration继承自 RecyclerView.ItemDecoration,,一步一步下去发现一些很好玩的东西,所以想着写一篇博客记录一下\n\n 1.recyclerview能添加多个ItemDecoration\n\n ```angular2html\n public void addItemDecoration(ItemDecoration decor) {\n        addItemDecoration(decor, -1);\n    }\n\n public void addItemDecoration(ItemDecoration decor, int index) {\n           if (mLayout != null) {\n               mLayout.assertNotInLayoutOrScroll(\"Cannot add item decoration during a scroll  or\"\n                       + \" layout\");\n           }\n           if (mItemDecorations.isEmpty()) {\n               setWillNotDraw(false);\n           }\n           if (index < 0) {\n               mItemDecorations.add(decor);\n           } else {\n               mItemDecorations.add(index, decor);\n           }\n           markItemDecorInsetsDirty();\n           requestLayout();\n       }\n ```\n\n所以如果需要实现GridLayoutManager网格布局的时候只需要添加两个DividerItemDecoration,其布局不相同就可以了\n\n2.在DividerItemDecoration中看到一个方法:parent.getDecoratedBoundsWithMargins(child, mBounds),mBounds是一个新的Rect(),在此方式中,调用的又是   getDecoratedBoundsWithMarginsInt(view, outBounds)\n列出getDecoratedBoundsWithMarginsInt的方法\n\n```angular2html\nstatic void getDecoratedBoundsWithMarginsInt(View view, Rect outBounds) {\n        final LayoutParams lp = (LayoutParams) view.getLayoutParams();\n        final Rect insets = lp.mDecorInsets;\n        outBounds.set(view.getLeft() - insets.left - lp.leftMargin,\n                view.getTop() - insets.top - lp.topMargin,\n                view.getRight() + insets.right + lp.rightMargin,\n                view.getBottom() + insets.bottom + lp.bottomMargin);\n    }\n```\n\n可以看到的是该方法中把传入的mBounds设置top,left,right,bottom的值,关注到的是mDecorInsets这个值,接下去看getLayoutParams中有关这个值的数据:\n\n\n\n```angular2html\n  final Rect mDecorInsets = new Rect();\n        boolean mInsetsDirty = true;\n        // Flag is set to true if the view is bound while it is detached from RV.\n```\n\n搜索mDecorInsets这个值,发现在getItemDecorInsetsForChild方法中赋值:\n\n```angular2html\n\n Rect getItemDecorInsetsForChild(View child) {\n        final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n        if (!lp.mInsetsDirty) {\n            return lp.mDecorInsets;\n        }\n\n        if (mState.isPreLayout() && (lp.isItemChanged() || lp.isViewInvalid())) {\n            // changed/invalid items should not be updated until they are rebound.\n            return lp.mDecorInsets;\n        }\n        final Rect insets = lp.mDecorInsets;\n        insets.set(0, 0, 0, 0);\n        final int decorCount = mItemDecorations.size();\n        for (int i = 0; i < decorCount; i++) {\n            mTempRect.set(0, 0, 0, 0);\n            mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);\n            insets.left += mTempRect.left;\n            insets.top += mTempRect.top;\n            insets.right += mTempRect.right;\n            insets.bottom += mTempRect.bottom;\n        }\n        lp.mInsetsDirty = false;\n        return insets;\n    }\n```\n\nmInsetsDirty就是一个flag来判断是否完成这个方法,这个方法就是在添加ItemDecoration的值到mDecorInsets中,可以看到调用了getItemOffsets这个方法,getItemOffsets就是我们在重写分割线的时候\n必须要重写的一个方法,\n","source":"_posts/recyclerView分割线的源码阅读.md","raw":"---\ntitle: recyclerView分割线的源码阅读\ndate: 2018-09-02 20:20:15\ntags:\n- android\n---\n recyclerview分割线是比较常用的功能吧,自己也想尝试一下如何添加,就想着去学习一下,看了网上的博客自己照着写了一下,但是发现还是阅读源码的方式稍微好一点把,因为Android\n 自己实现了分割线的方法, DividerItemDecoration继承自 RecyclerView.ItemDecoration,,一步一步下去发现一些很好玩的东西,所以想着写一篇博客记录一下\n\n 1.recyclerview能添加多个ItemDecoration\n\n ```angular2html\n public void addItemDecoration(ItemDecoration decor) {\n        addItemDecoration(decor, -1);\n    }\n\n public void addItemDecoration(ItemDecoration decor, int index) {\n           if (mLayout != null) {\n               mLayout.assertNotInLayoutOrScroll(\"Cannot add item decoration during a scroll  or\"\n                       + \" layout\");\n           }\n           if (mItemDecorations.isEmpty()) {\n               setWillNotDraw(false);\n           }\n           if (index < 0) {\n               mItemDecorations.add(decor);\n           } else {\n               mItemDecorations.add(index, decor);\n           }\n           markItemDecorInsetsDirty();\n           requestLayout();\n       }\n ```\n\n所以如果需要实现GridLayoutManager网格布局的时候只需要添加两个DividerItemDecoration,其布局不相同就可以了\n\n2.在DividerItemDecoration中看到一个方法:parent.getDecoratedBoundsWithMargins(child, mBounds),mBounds是一个新的Rect(),在此方式中,调用的又是   getDecoratedBoundsWithMarginsInt(view, outBounds)\n列出getDecoratedBoundsWithMarginsInt的方法\n\n```angular2html\nstatic void getDecoratedBoundsWithMarginsInt(View view, Rect outBounds) {\n        final LayoutParams lp = (LayoutParams) view.getLayoutParams();\n        final Rect insets = lp.mDecorInsets;\n        outBounds.set(view.getLeft() - insets.left - lp.leftMargin,\n                view.getTop() - insets.top - lp.topMargin,\n                view.getRight() + insets.right + lp.rightMargin,\n                view.getBottom() + insets.bottom + lp.bottomMargin);\n    }\n```\n\n可以看到的是该方法中把传入的mBounds设置top,left,right,bottom的值,关注到的是mDecorInsets这个值,接下去看getLayoutParams中有关这个值的数据:\n\n\n\n```angular2html\n  final Rect mDecorInsets = new Rect();\n        boolean mInsetsDirty = true;\n        // Flag is set to true if the view is bound while it is detached from RV.\n```\n\n搜索mDecorInsets这个值,发现在getItemDecorInsetsForChild方法中赋值:\n\n```angular2html\n\n Rect getItemDecorInsetsForChild(View child) {\n        final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n        if (!lp.mInsetsDirty) {\n            return lp.mDecorInsets;\n        }\n\n        if (mState.isPreLayout() && (lp.isItemChanged() || lp.isViewInvalid())) {\n            // changed/invalid items should not be updated until they are rebound.\n            return lp.mDecorInsets;\n        }\n        final Rect insets = lp.mDecorInsets;\n        insets.set(0, 0, 0, 0);\n        final int decorCount = mItemDecorations.size();\n        for (int i = 0; i < decorCount; i++) {\n            mTempRect.set(0, 0, 0, 0);\n            mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);\n            insets.left += mTempRect.left;\n            insets.top += mTempRect.top;\n            insets.right += mTempRect.right;\n            insets.bottom += mTempRect.bottom;\n        }\n        lp.mInsetsDirty = false;\n        return insets;\n    }\n```\n\nmInsetsDirty就是一个flag来判断是否完成这个方法,这个方法就是在添加ItemDecoration的值到mDecorInsets中,可以看到调用了getItemOffsets这个方法,getItemOffsets就是我们在重写分割线的时候\n必须要重写的一个方法,\n","slug":"recyclerView分割线的源码阅读","published":1,"updated":"2020-03-31T05:41:12.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje8x000y9ots6olk675v","content":"<p> recyclerview分割线是比较常用的功能吧,自己也想尝试一下如何添加,就想着去学习一下,看了网上的博客自己照着写了一下,但是发现还是阅读源码的方式稍微好一点把,因为Android<br> 自己实现了分割线的方法, DividerItemDecoration继承自 RecyclerView.ItemDecoration,,一步一步下去发现一些很好玩的东西,所以想着写一篇博客记录一下</p>\n<p> 1.recyclerview能添加多个ItemDecoration</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void addItemDecoration(ItemDecoration decor) &#123;</span><br><span class=\"line\">       addItemDecoration(decor, -1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void addItemDecoration(ItemDecoration decor, int index) &#123;</span><br><span class=\"line\">          if (mLayout != null) &#123;</span><br><span class=\"line\">              mLayout.assertNotInLayoutOrScroll(&quot;Cannot add item decoration during a scroll  or&quot;</span><br><span class=\"line\">                      + &quot; layout&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (mItemDecorations.isEmpty()) &#123;</span><br><span class=\"line\">              setWillNotDraw(false);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (index &lt; 0) &#123;</span><br><span class=\"line\">              mItemDecorations.add(decor);</span><br><span class=\"line\">          &#125; else &#123;</span><br><span class=\"line\">              mItemDecorations.add(index, decor);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          markItemDecorInsetsDirty();</span><br><span class=\"line\">          requestLayout();</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>所以如果需要实现GridLayoutManager网格布局的时候只需要添加两个DividerItemDecoration,其布局不相同就可以了</p>\n<p>2.在DividerItemDecoration中看到一个方法:parent.getDecoratedBoundsWithMargins(child, mBounds),mBounds是一个新的Rect(),在此方式中,调用的又是   getDecoratedBoundsWithMarginsInt(view, outBounds)<br>列出getDecoratedBoundsWithMarginsInt的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void getDecoratedBoundsWithMarginsInt(View view, Rect outBounds) &#123;</span><br><span class=\"line\">        final LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class=\"line\">        final Rect insets = lp.mDecorInsets;</span><br><span class=\"line\">        outBounds.set(view.getLeft() - insets.left - lp.leftMargin,</span><br><span class=\"line\">                view.getTop() - insets.top - lp.topMargin,</span><br><span class=\"line\">                view.getRight() + insets.right + lp.rightMargin,</span><br><span class=\"line\">                view.getBottom() + insets.bottom + lp.bottomMargin);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到的是该方法中把传入的mBounds设置top,left,right,bottom的值,关注到的是mDecorInsets这个值,接下去看getLayoutParams中有关这个值的数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Rect mDecorInsets = new Rect();</span><br><span class=\"line\">      boolean mInsetsDirty = true;</span><br><span class=\"line\">      // Flag is set to true if the view is bound while it is detached from RV.</span><br></pre></td></tr></table></figure>\n<p>搜索mDecorInsets这个值,发现在getItemDecorInsetsForChild方法中赋值:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Rect getItemDecorInsetsForChild(View child) &#123;</span><br><span class=\"line\">       final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">       if (!lp.mInsetsDirty) &#123;</span><br><span class=\"line\">           return lp.mDecorInsets;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if (mState.isPreLayout() &amp;&amp; (lp.isItemChanged() || lp.isViewInvalid())) &#123;</span><br><span class=\"line\">           // changed/invalid items should not be updated until they are rebound.</span><br><span class=\"line\">           return lp.mDecorInsets;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       final Rect insets = lp.mDecorInsets;</span><br><span class=\"line\">       insets.set(0, 0, 0, 0);</span><br><span class=\"line\">       final int decorCount = mItemDecorations.size();</span><br><span class=\"line\">       for (int i = 0; i &lt; decorCount; i++) &#123;</span><br><span class=\"line\">           mTempRect.set(0, 0, 0, 0);</span><br><span class=\"line\">           mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);</span><br><span class=\"line\">           insets.left += mTempRect.left;</span><br><span class=\"line\">           insets.top += mTempRect.top;</span><br><span class=\"line\">           insets.right += mTempRect.right;</span><br><span class=\"line\">           insets.bottom += mTempRect.bottom;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       lp.mInsetsDirty = false;</span><br><span class=\"line\">       return insets;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>mInsetsDirty就是一个flag来判断是否完成这个方法,这个方法就是在添加ItemDecoration的值到mDecorInsets中,可以看到调用了getItemOffsets这个方法,getItemOffsets就是我们在重写分割线的时候<br>必须要重写的一个方法,</p>\n","site":{"data":{}},"excerpt":"","more":"<p> recyclerview分割线是比较常用的功能吧,自己也想尝试一下如何添加,就想着去学习一下,看了网上的博客自己照着写了一下,但是发现还是阅读源码的方式稍微好一点把,因为Android<br> 自己实现了分割线的方法, DividerItemDecoration继承自 RecyclerView.ItemDecoration,,一步一步下去发现一些很好玩的东西,所以想着写一篇博客记录一下</p>\n<p> 1.recyclerview能添加多个ItemDecoration</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void addItemDecoration(ItemDecoration decor) &#123;</span><br><span class=\"line\">       addItemDecoration(decor, -1);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void addItemDecoration(ItemDecoration decor, int index) &#123;</span><br><span class=\"line\">          if (mLayout != null) &#123;</span><br><span class=\"line\">              mLayout.assertNotInLayoutOrScroll(&quot;Cannot add item decoration during a scroll  or&quot;</span><br><span class=\"line\">                      + &quot; layout&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (mItemDecorations.isEmpty()) &#123;</span><br><span class=\"line\">              setWillNotDraw(false);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (index &lt; 0) &#123;</span><br><span class=\"line\">              mItemDecorations.add(decor);</span><br><span class=\"line\">          &#125; else &#123;</span><br><span class=\"line\">              mItemDecorations.add(index, decor);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          markItemDecorInsetsDirty();</span><br><span class=\"line\">          requestLayout();</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>所以如果需要实现GridLayoutManager网格布局的时候只需要添加两个DividerItemDecoration,其布局不相同就可以了</p>\n<p>2.在DividerItemDecoration中看到一个方法:parent.getDecoratedBoundsWithMargins(child, mBounds),mBounds是一个新的Rect(),在此方式中,调用的又是   getDecoratedBoundsWithMarginsInt(view, outBounds)<br>列出getDecoratedBoundsWithMarginsInt的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void getDecoratedBoundsWithMarginsInt(View view, Rect outBounds) &#123;</span><br><span class=\"line\">        final LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class=\"line\">        final Rect insets = lp.mDecorInsets;</span><br><span class=\"line\">        outBounds.set(view.getLeft() - insets.left - lp.leftMargin,</span><br><span class=\"line\">                view.getTop() - insets.top - lp.topMargin,</span><br><span class=\"line\">                view.getRight() + insets.right + lp.rightMargin,</span><br><span class=\"line\">                view.getBottom() + insets.bottom + lp.bottomMargin);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到的是该方法中把传入的mBounds设置top,left,right,bottom的值,关注到的是mDecorInsets这个值,接下去看getLayoutParams中有关这个值的数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Rect mDecorInsets = new Rect();</span><br><span class=\"line\">      boolean mInsetsDirty = true;</span><br><span class=\"line\">      // Flag is set to true if the view is bound while it is detached from RV.</span><br></pre></td></tr></table></figure>\n<p>搜索mDecorInsets这个值,发现在getItemDecorInsetsForChild方法中赋值:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Rect getItemDecorInsetsForChild(View child) &#123;</span><br><span class=\"line\">       final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">       if (!lp.mInsetsDirty) &#123;</span><br><span class=\"line\">           return lp.mDecorInsets;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if (mState.isPreLayout() &amp;&amp; (lp.isItemChanged() || lp.isViewInvalid())) &#123;</span><br><span class=\"line\">           // changed/invalid items should not be updated until they are rebound.</span><br><span class=\"line\">           return lp.mDecorInsets;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       final Rect insets = lp.mDecorInsets;</span><br><span class=\"line\">       insets.set(0, 0, 0, 0);</span><br><span class=\"line\">       final int decorCount = mItemDecorations.size();</span><br><span class=\"line\">       for (int i = 0; i &lt; decorCount; i++) &#123;</span><br><span class=\"line\">           mTempRect.set(0, 0, 0, 0);</span><br><span class=\"line\">           mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);</span><br><span class=\"line\">           insets.left += mTempRect.left;</span><br><span class=\"line\">           insets.top += mTempRect.top;</span><br><span class=\"line\">           insets.right += mTempRect.right;</span><br><span class=\"line\">           insets.bottom += mTempRect.bottom;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       lp.mInsetsDirty = false;</span><br><span class=\"line\">       return insets;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>mInsetsDirty就是一个flag来判断是否完成这个方法,这个方法就是在添加ItemDecoration的值到mDecorInsets中,可以看到调用了getItemOffsets这个方法,getItemOffsets就是我们在重写分割线的时候<br>必须要重写的一个方法,</p>\n"},{"title":"nginx服务器搭建","date":"2018-08-15T22:24:26.000Z","_content":"闲来无事想写一个博客,因为自己有了 [域名](www.honglingqi.cn) ,但是想着写博客的话怎么也得用[博客](blog.honglingqi.cn)这个blog二级域名吧,博客也应该用hexo来写比较好,那怎么分配这个二级域名呢,查了半天发现nginx可以很好的实现,那还用什么apache啊,赶紧的nginx装起来,但是这个真的是个大坑......\n\n首先安装nignx\n`\nsudo apt-get install nginx\n`\n能在站点上看到如下信息\n\n![安装成功](http://image.honglingqi.cn/blogImages/web.png)\n\n 接着安装php\n\n`\n  sudo apt-get install php7.0`\n\n  输入 `php -v` 出现版本信息就代表安装成功了\n\n  为什么是7.0的版本的  因为在nginx的配置文件里php的版本就是7.0的版本,为了方便\n\n  但是在站点下新建php文件,然后访问 你会发现它会把文件下载下来,这是因为nginx不能编译php文件,必须安装对应的插件\n\n\n  php低版本貌似要自己安装  7.0的版本好像自己有了 可能镜像不同会有差异 最好还是安装下一\n\n  `sudo apt-get install php7.0-fpm\n  `\n\n  不确定这个是否是真的需要,我也没验证\n\n  `sudo apt-get install php7.0-cgi\n  `\n\n   然后启动php服务\n\n   `\n   service php7.0-fpm start`\n\n   接着修改nginx的配置文件\n\n   `sudo nano /etc/nginx/sites-available/default\n   `\n\n\n  ```angular2html\n  #location ~ \\.php$ {\n\n          #       include snippets/fastcgi-php.conf;\n          #\n          #       # With php7.0-cgi alone:\n          #       fastcgi_pass 127.0.0.1:9000;\n          #       # With php7.0-fpm:\n          #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n          #}\n\n  ```\n  替换成\n\n  ```\n  location ~ \\.php$ {\n                  include snippets/fastcgi-php.conf;\n\n\n                  # With php7.0-cgi alone:\n           #       fastcgi_pass 127.0.0.1:9000;\n                  # With php7.0-fpm:\n                  fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n           }\n  ```\n\n然后重启nginx\n\n``\nsudo service nginx restart\n``\n\n至此php也可以解析了,然后就是配置二级域名了\n\n安装 node\n\n```angular2html\nsudo apt-get update\n\nsudo apt-get install nodejs\n\nsudo apt-get install nodejs-legacy\n\n```\n\n```angular2html\n\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    response.end('Hello World\\n');\n\n}).listen(8888);\n\nconsole.log('Server running at http://127.0.0.1:8888/');\n```\n\n然后访问8888端口,自然会出现Hello World\n\n接下去就是要配置二级域名了,还是打开nginx的配置文件,拉到最后,加入如下代码\n\n```angular2html\n\n\nserver {\n            listen 80;\n            server_name blog.honglingqi.cn;\n            location / {\n                 proxy_pass http://127.0.0.1:8888;\n           }\n         }\n\n\n```\n保存退出,然后重启就可以访问了\n\n\n最后说一下php的CI框架,放在网站目录后你会发现无法访问,之前在apache上是使用rewrite模块和.hatccess文件重写路径访问\n百度了下只要在配置文件中加入这个文件的路径就好了\n\n```angular2html\ninclude (路径).hatccess;\n```\n但是我自己试了一下发现一只报错,然后用了一个方法完美解决:\n就是在一级域名的server下面添加如下代码:\n```angular2html\n location /(CI框架的名字){\n                try_files $uri $uri/ /(CI框架的名字)/index.php?$args;\n        }\n\n```\n我看了下之前的配置文件 然后照着写了一个,发现真的可以用,那也挺好的\n\n总的来说nginx的配置真的比较简单,而且建站也比较方便,强烈推荐使用\n","source":"_posts/nginx服务器搭建.md","raw":"---\ntitle: nginx服务器搭建\ndate: 2018-08-16 06:24:26\ntags:\n- 服务器\n---\n闲来无事想写一个博客,因为自己有了 [域名](www.honglingqi.cn) ,但是想着写博客的话怎么也得用[博客](blog.honglingqi.cn)这个blog二级域名吧,博客也应该用hexo来写比较好,那怎么分配这个二级域名呢,查了半天发现nginx可以很好的实现,那还用什么apache啊,赶紧的nginx装起来,但是这个真的是个大坑......\n\n首先安装nignx\n`\nsudo apt-get install nginx\n`\n能在站点上看到如下信息\n\n![安装成功](http://image.honglingqi.cn/blogImages/web.png)\n\n 接着安装php\n\n`\n  sudo apt-get install php7.0`\n\n  输入 `php -v` 出现版本信息就代表安装成功了\n\n  为什么是7.0的版本的  因为在nginx的配置文件里php的版本就是7.0的版本,为了方便\n\n  但是在站点下新建php文件,然后访问 你会发现它会把文件下载下来,这是因为nginx不能编译php文件,必须安装对应的插件\n\n\n  php低版本貌似要自己安装  7.0的版本好像自己有了 可能镜像不同会有差异 最好还是安装下一\n\n  `sudo apt-get install php7.0-fpm\n  `\n\n  不确定这个是否是真的需要,我也没验证\n\n  `sudo apt-get install php7.0-cgi\n  `\n\n   然后启动php服务\n\n   `\n   service php7.0-fpm start`\n\n   接着修改nginx的配置文件\n\n   `sudo nano /etc/nginx/sites-available/default\n   `\n\n\n  ```angular2html\n  #location ~ \\.php$ {\n\n          #       include snippets/fastcgi-php.conf;\n          #\n          #       # With php7.0-cgi alone:\n          #       fastcgi_pass 127.0.0.1:9000;\n          #       # With php7.0-fpm:\n          #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n          #}\n\n  ```\n  替换成\n\n  ```\n  location ~ \\.php$ {\n                  include snippets/fastcgi-php.conf;\n\n\n                  # With php7.0-cgi alone:\n           #       fastcgi_pass 127.0.0.1:9000;\n                  # With php7.0-fpm:\n                  fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n           }\n  ```\n\n然后重启nginx\n\n``\nsudo service nginx restart\n``\n\n至此php也可以解析了,然后就是配置二级域名了\n\n安装 node\n\n```angular2html\nsudo apt-get update\n\nsudo apt-get install nodejs\n\nsudo apt-get install nodejs-legacy\n\n```\n\n```angular2html\n\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    response.end('Hello World\\n');\n\n}).listen(8888);\n\nconsole.log('Server running at http://127.0.0.1:8888/');\n```\n\n然后访问8888端口,自然会出现Hello World\n\n接下去就是要配置二级域名了,还是打开nginx的配置文件,拉到最后,加入如下代码\n\n```angular2html\n\n\nserver {\n            listen 80;\n            server_name blog.honglingqi.cn;\n            location / {\n                 proxy_pass http://127.0.0.1:8888;\n           }\n         }\n\n\n```\n保存退出,然后重启就可以访问了\n\n\n最后说一下php的CI框架,放在网站目录后你会发现无法访问,之前在apache上是使用rewrite模块和.hatccess文件重写路径访问\n百度了下只要在配置文件中加入这个文件的路径就好了\n\n```angular2html\ninclude (路径).hatccess;\n```\n但是我自己试了一下发现一只报错,然后用了一个方法完美解决:\n就是在一级域名的server下面添加如下代码:\n```angular2html\n location /(CI框架的名字){\n                try_files $uri $uri/ /(CI框架的名字)/index.php?$args;\n        }\n\n```\n我看了下之前的配置文件 然后照着写了一个,发现真的可以用,那也挺好的\n\n总的来说nginx的配置真的比较简单,而且建站也比较方便,强烈推荐使用\n","slug":"nginx服务器搭建","published":1,"updated":"2020-03-31T05:41:12.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9000119ots1pbcwbyl","content":"<p>闲来无事想写一个博客,因为自己有了 <a href=\"www.honglingqi.cn\">域名</a> ,但是想着写博客的话怎么也得用<a href=\"blog.honglingqi.cn\">博客</a>这个blog二级域名吧,博客也应该用hexo来写比较好,那怎么分配这个二级域名呢,查了半天发现nginx可以很好的实现,那还用什么apache啊,赶紧的nginx装起来,但是这个真的是个大坑……</p>\n<p>首先安装nignx<br><code>sudo apt-get install nginx</code><br>能在站点上看到如下信息</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/web.png\" alt=\"安装成功\"></p>\n<p> 接着安装php</p>\n<p><code>sudo apt-get install php7.0</code></p>\n<p>  输入 <code>php -v</code> 出现版本信息就代表安装成功了</p>\n<p>  为什么是7.0的版本的  因为在nginx的配置文件里php的版本就是7.0的版本,为了方便</p>\n<p>  但是在站点下新建php文件,然后访问 你会发现它会把文件下载下来,这是因为nginx不能编译php文件,必须安装对应的插件</p>\n<p>  php低版本貌似要自己安装  7.0的版本好像自己有了 可能镜像不同会有差异 最好还是安装下一</p>\n<p>  <code>sudo apt-get install php7.0-fpm</code></p>\n<p>  不确定这个是否是真的需要,我也没验证</p>\n<p>  <code>sudo apt-get install php7.0-cgi</code></p>\n<p>   然后启动php服务</p>\n<p>   <code>service php7.0-fpm start</code></p>\n<p>   接着修改nginx的配置文件</p>\n<p>   <code>sudo nano /etc/nginx/sites-available/default</code></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#location ~ \\.php$ &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        #       include snippets/fastcgi-php.conf;</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #       # With php7.0-cgi alone:</span><br><span class=\"line\">        #       fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        #       # With php7.0-fpm:</span><br><span class=\"line\">        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">        #&#125;</span><br></pre></td></tr></table></figure>\n<p>  替换成</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">                include snippets/fastcgi-php.conf;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                # With php7.0-cgi alone:</span><br><span class=\"line\">         #       fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">                # With php7.0-fpm:</span><br><span class=\"line\">                fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启nginx</p>\n<p><code>sudo service nginx restart</code></p>\n<p>至此php也可以解析了,然后就是配置二级域名了</p>\n<p>安装 node</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(function (request, response) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    response.end(&apos;Hello World\\n&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(8888);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后访问8888端口,自然会出现Hello World</p>\n<p>接下去就是要配置二级域名了,还是打开nginx的配置文件,拉到最后,加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">            listen 80;</span><br><span class=\"line\">            server_name blog.honglingqi.cn;</span><br><span class=\"line\">            location / &#123;</span><br><span class=\"line\">                 proxy_pass http://127.0.0.1:8888;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<p>保存退出,然后重启就可以访问了</p>\n<p>最后说一下php的CI框架,放在网站目录后你会发现无法访问,之前在apache上是使用rewrite模块和.hatccess文件重写路径访问<br>百度了下只要在配置文件中加入这个文件的路径就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include (路径).hatccess;</span><br></pre></td></tr></table></figure>\n<p>但是我自己试了一下发现一只报错,然后用了一个方法完美解决:<br>就是在一级域名的server下面添加如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /(CI框架的名字)&#123;</span><br><span class=\"line\">               try_files $uri $uri/ /(CI框架的名字)/index.php?$args;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我看了下之前的配置文件 然后照着写了一个,发现真的可以用,那也挺好的</p>\n<p>总的来说nginx的配置真的比较简单,而且建站也比较方便,强烈推荐使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>闲来无事想写一个博客,因为自己有了 <a href=\"www.honglingqi.cn\">域名</a> ,但是想着写博客的话怎么也得用<a href=\"blog.honglingqi.cn\">博客</a>这个blog二级域名吧,博客也应该用hexo来写比较好,那怎么分配这个二级域名呢,查了半天发现nginx可以很好的实现,那还用什么apache啊,赶紧的nginx装起来,但是这个真的是个大坑……</p>\n<p>首先安装nignx<br><code>sudo apt-get install nginx</code><br>能在站点上看到如下信息</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/web.png\" alt=\"安装成功\"></p>\n<p> 接着安装php</p>\n<p><code>sudo apt-get install php7.0</code></p>\n<p>  输入 <code>php -v</code> 出现版本信息就代表安装成功了</p>\n<p>  为什么是7.0的版本的  因为在nginx的配置文件里php的版本就是7.0的版本,为了方便</p>\n<p>  但是在站点下新建php文件,然后访问 你会发现它会把文件下载下来,这是因为nginx不能编译php文件,必须安装对应的插件</p>\n<p>  php低版本貌似要自己安装  7.0的版本好像自己有了 可能镜像不同会有差异 最好还是安装下一</p>\n<p>  <code>sudo apt-get install php7.0-fpm</code></p>\n<p>  不确定这个是否是真的需要,我也没验证</p>\n<p>  <code>sudo apt-get install php7.0-cgi</code></p>\n<p>   然后启动php服务</p>\n<p>   <code>service php7.0-fpm start</code></p>\n<p>   接着修改nginx的配置文件</p>\n<p>   <code>sudo nano /etc/nginx/sites-available/default</code></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#location ~ \\.php$ &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        #       include snippets/fastcgi-php.conf;</span><br><span class=\"line\">        #</span><br><span class=\"line\">        #       # With php7.0-cgi alone:</span><br><span class=\"line\">        #       fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        #       # With php7.0-fpm:</span><br><span class=\"line\">        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">        #&#125;</span><br></pre></td></tr></table></figure>\n<p>  替换成</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">                include snippets/fastcgi-php.conf;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                # With php7.0-cgi alone:</span><br><span class=\"line\">         #       fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">                # With php7.0-fpm:</span><br><span class=\"line\">                fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<p>然后重启nginx</p>\n<p><code>sudo service nginx restart</code></p>\n<p>至此php也可以解析了,然后就是配置二级域名了</p>\n<p>安装 node</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(function (request, response) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    response.end(&apos;Hello World\\n&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).listen(8888);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后访问8888端口,自然会出现Hello World</p>\n<p>接下去就是要配置二级域名了,还是打开nginx的配置文件,拉到最后,加入如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">            listen 80;</span><br><span class=\"line\">            server_name blog.honglingqi.cn;</span><br><span class=\"line\">            location / &#123;</span><br><span class=\"line\">                 proxy_pass http://127.0.0.1:8888;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<p>保存退出,然后重启就可以访问了</p>\n<p>最后说一下php的CI框架,放在网站目录后你会发现无法访问,之前在apache上是使用rewrite模块和.hatccess文件重写路径访问<br>百度了下只要在配置文件中加入这个文件的路径就好了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include (路径).hatccess;</span><br></pre></td></tr></table></figure>\n<p>但是我自己试了一下发现一只报错,然后用了一个方法完美解决:<br>就是在一级域名的server下面添加如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /(CI框架的名字)&#123;</span><br><span class=\"line\">               try_files $uri $uri/ /(CI框架的名字)/index.php?$args;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<p>我看了下之前的配置文件 然后照着写了一个,发现真的可以用,那也挺好的</p>\n<p>总的来说nginx的配置真的比较简单,而且建站也比较方便,强烈推荐使用</p>\n"},{"title":"okhttp和retrofit网络框架的使用","date":"2018-07-16T17:27:03.000Z","_content":"```\n OkHttpClient client= new OkHttpClient.Builder().addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n\n                        //获取到request\n                        Request request = chain.request();\n                        HttpUrl.Builder builder=request.url().newBuilder().\n                                scheme(request.url().scheme()).host(request.url().host());\n                        //添加公共参数\n                        builder.addQueryParameter(\"\",\"\");\n\n                        request = request.newBuilder().method(request.method(),request.body()).url(builder.build()).build();\n                        Tool.log(request.url().toString());\n                        return chain.proceed(request);\n                    }\n                }).build();\n                mRetrofit=new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()).\n                       client(client).\n                        baseUrl(BASE_URL).build();\n```\n","source":"_posts/retrofit添加公共参数.md","raw":"---\ntitle: okhttp和retrofit网络框架的使用\ndate: 2018-07-17 01:27:03\ntags:\n- android\n---\n```\n OkHttpClient client= new OkHttpClient.Builder().addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n\n                        //获取到request\n                        Request request = chain.request();\n                        HttpUrl.Builder builder=request.url().newBuilder().\n                                scheme(request.url().scheme()).host(request.url().host());\n                        //添加公共参数\n                        builder.addQueryParameter(\"\",\"\");\n\n                        request = request.newBuilder().method(request.method(),request.body()).url(builder.build()).build();\n                        Tool.log(request.url().toString());\n                        return chain.proceed(request);\n                    }\n                }).build();\n                mRetrofit=new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()).\n                       client(client).\n                        baseUrl(BASE_URL).build();\n```\n","slug":"retrofit添加公共参数","published":1,"updated":"2020-03-31T05:41:12.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9200149ots7x63mrsq","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client= new OkHttpClient.Builder().addInterceptor(new Interceptor() &#123;</span><br><span class=\"line\">                   @Override</span><br><span class=\"line\">                   public okhttp3.Response intercept(Chain chain) throws IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                       //获取到request</span><br><span class=\"line\">                       Request request = chain.request();</span><br><span class=\"line\">                       HttpUrl.Builder builder=request.url().newBuilder().</span><br><span class=\"line\">                               scheme(request.url().scheme()).host(request.url().host());</span><br><span class=\"line\">                       //添加公共参数</span><br><span class=\"line\">                       builder.addQueryParameter(&quot;&quot;,&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                       request = request.newBuilder().method(request.method(),request.body()).url(builder.build()).build();</span><br><span class=\"line\">                       Tool.log(request.url().toString());</span><br><span class=\"line\">                       return chain.proceed(request);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;).build();</span><br><span class=\"line\">               mRetrofit=new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()).</span><br><span class=\"line\">                      client(client).</span><br><span class=\"line\">                       baseUrl(BASE_URL).build();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client= new OkHttpClient.Builder().addInterceptor(new Interceptor() &#123;</span><br><span class=\"line\">                   @Override</span><br><span class=\"line\">                   public okhttp3.Response intercept(Chain chain) throws IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                       //获取到request</span><br><span class=\"line\">                       Request request = chain.request();</span><br><span class=\"line\">                       HttpUrl.Builder builder=request.url().newBuilder().</span><br><span class=\"line\">                               scheme(request.url().scheme()).host(request.url().host());</span><br><span class=\"line\">                       //添加公共参数</span><br><span class=\"line\">                       builder.addQueryParameter(&quot;&quot;,&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">                       request = request.newBuilder().method(request.method(),request.body()).url(builder.build()).build();</span><br><span class=\"line\">                       Tool.log(request.url().toString());</span><br><span class=\"line\">                       return chain.proceed(request);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;).build();</span><br><span class=\"line\">               mRetrofit=new Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()).</span><br><span class=\"line\">                      client(client).</span><br><span class=\"line\">                       baseUrl(BASE_URL).build();</span><br></pre></td></tr></table></figure>\n"},{"title":"xcode导入第三方库","date":"2018-08-21T08:10:21.000Z","_content":"我真的觉得有些程序员真的太懒了(虽然我也很懒),关键是懒就算了,还不动脑子,一模一样的文章从别人那里Ctrl+C然后Ctrl+V有意思吗?自己也不去试试又没有用就直接当作自己的博客了,也是醉了.然后不排除是我自己用不来这些方法的原因\n但是我自己研究出来更好的了,XCODE导入第三方库,就比如导入AFNetworking\n\n1.点击xcode左上方file->选择add Files to \"项目名称\"\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/one.jpg)\n\n2.选择AFNetworking路径,选中需要导入的两个文件夹\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/two.png)\n\n3.导入成功,接下去就可以引用了\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/three.png)\n\n可能是我自己不会用或者太笨的问题,网上的方法找这种方法:\n\n```angular2html\n1、点击项目名；\n\n2、选择TARGETS，选中对应的target；\n\n3、选中Build Phrases选项卡；\n\n4、选中Link Binary With Libraries；\n\n5、展开该条目，点击左下角的加号；\n\n6、在列表中选择需要的Framework，即可以导入当前可用的Framework。\n```\n我找不到,所以只能用这种笨办法手动导入了\n\n貌似用CocoaPods管理也挺方便的,有兴趣的可以去试试,不用手动导入了\n","source":"_posts/xcode导入第三方库.md","raw":"---\ntitle: xcode导入第三方库\ndate: 2018-08-21 16:10:21\ntags:\n- ios\n---\n我真的觉得有些程序员真的太懒了(虽然我也很懒),关键是懒就算了,还不动脑子,一模一样的文章从别人那里Ctrl+C然后Ctrl+V有意思吗?自己也不去试试又没有用就直接当作自己的博客了,也是醉了.然后不排除是我自己用不来这些方法的原因\n但是我自己研究出来更好的了,XCODE导入第三方库,就比如导入AFNetworking\n\n1.点击xcode左上方file->选择add Files to \"项目名称\"\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/one.jpg)\n\n2.选择AFNetworking路径,选中需要导入的两个文件夹\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/two.png)\n\n3.导入成功,接下去就可以引用了\n\n![图片一](http://image.honglingqi.cn/blogImages/1808/xcode/three.png)\n\n可能是我自己不会用或者太笨的问题,网上的方法找这种方法:\n\n```angular2html\n1、点击项目名；\n\n2、选择TARGETS，选中对应的target；\n\n3、选中Build Phrases选项卡；\n\n4、选中Link Binary With Libraries；\n\n5、展开该条目，点击左下角的加号；\n\n6、在列表中选择需要的Framework，即可以导入当前可用的Framework。\n```\n我找不到,所以只能用这种笨办法手动导入了\n\n貌似用CocoaPods管理也挺方便的,有兴趣的可以去试试,不用手动导入了\n","slug":"xcode导入第三方库","published":1,"updated":"2020-03-31T05:41:12.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9400159otsbqtdbve6","content":"<p>我真的觉得有些程序员真的太懒了(虽然我也很懒),关键是懒就算了,还不动脑子,一模一样的文章从别人那里Ctrl+C然后Ctrl+V有意思吗?自己也不去试试又没有用就直接当作自己的博客了,也是醉了.然后不排除是我自己用不来这些方法的原因<br>但是我自己研究出来更好的了,XCODE导入第三方库,就比如导入AFNetworking</p>\n<p>1.点击xcode左上方file-&gt;选择add Files to “项目名称”</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/one.jpg\" alt=\"图片一\"></p>\n<p>2.选择AFNetworking路径,选中需要导入的两个文件夹</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/two.png\" alt=\"图片一\"></p>\n<p>3.导入成功,接下去就可以引用了</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/three.png\" alt=\"图片一\"></p>\n<p>可能是我自己不会用或者太笨的问题,网上的方法找这种方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、点击项目名；</span><br><span class=\"line\"></span><br><span class=\"line\">2、选择TARGETS，选中对应的target；</span><br><span class=\"line\"></span><br><span class=\"line\">3、选中Build Phrases选项卡；</span><br><span class=\"line\"></span><br><span class=\"line\">4、选中Link Binary With Libraries；</span><br><span class=\"line\"></span><br><span class=\"line\">5、展开该条目，点击左下角的加号；</span><br><span class=\"line\"></span><br><span class=\"line\">6、在列表中选择需要的Framework，即可以导入当前可用的Framework。</span><br></pre></td></tr></table></figure>\n<p>我找不到,所以只能用这种笨办法手动导入了</p>\n<p>貌似用CocoaPods管理也挺方便的,有兴趣的可以去试试,不用手动导入了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我真的觉得有些程序员真的太懒了(虽然我也很懒),关键是懒就算了,还不动脑子,一模一样的文章从别人那里Ctrl+C然后Ctrl+V有意思吗?自己也不去试试又没有用就直接当作自己的博客了,也是醉了.然后不排除是我自己用不来这些方法的原因<br>但是我自己研究出来更好的了,XCODE导入第三方库,就比如导入AFNetworking</p>\n<p>1.点击xcode左上方file-&gt;选择add Files to “项目名称”</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/one.jpg\" alt=\"图片一\"></p>\n<p>2.选择AFNetworking路径,选中需要导入的两个文件夹</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/two.png\" alt=\"图片一\"></p>\n<p>3.导入成功,接下去就可以引用了</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1808/xcode/three.png\" alt=\"图片一\"></p>\n<p>可能是我自己不会用或者太笨的问题,网上的方法找这种方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、点击项目名；</span><br><span class=\"line\"></span><br><span class=\"line\">2、选择TARGETS，选中对应的target；</span><br><span class=\"line\"></span><br><span class=\"line\">3、选中Build Phrases选项卡；</span><br><span class=\"line\"></span><br><span class=\"line\">4、选中Link Binary With Libraries；</span><br><span class=\"line\"></span><br><span class=\"line\">5、展开该条目，点击左下角的加号；</span><br><span class=\"line\"></span><br><span class=\"line\">6、在列表中选择需要的Framework，即可以导入当前可用的Framework。</span><br></pre></td></tr></table></figure>\n<p>我找不到,所以只能用这种笨办法手动导入了</p>\n<p>貌似用CocoaPods管理也挺方便的,有兴趣的可以去试试,不用手动导入了</p>\n"},{"title":"你会用git吗","date":"2019-06-26T03:25:31.000Z","_content":"1.git版本回退\n\n刚来公司,用的是码云 git的方式管理项目,然后发现自己提交错了,还好可以回退\n\n```git\ngit reset --hard <版本号>\n// 注意使用 --hard 参数会抛弃当前工作区的修改\n// 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交\n\n\ngit push origin <分支名> --force 远程仓库就回退版本了\n\nps:虽然回退了版本,但是推送记录中还是存在你之前推送的记录\n\n````\n\n2. git 分支提交\n\n\n#查看当前所有分支\ngit brach\n\n\n#查看远程所有分支\ngit branch -r\n\n#查看所有分支 (包括远程和当前)\ngit branch -a\n\n","source":"_posts/你会用git吗.md","raw":"---\ntitle: 你会用git吗\ndate: 2019-06-26 11:25:31\ntags:\n---\n1.git版本回退\n\n刚来公司,用的是码云 git的方式管理项目,然后发现自己提交错了,还好可以回退\n\n```git\ngit reset --hard <版本号>\n// 注意使用 --hard 参数会抛弃当前工作区的修改\n// 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交\n\n\ngit push origin <分支名> --force 远程仓库就回退版本了\n\nps:虽然回退了版本,但是推送记录中还是存在你之前推送的记录\n\n````\n\n2. git 分支提交\n\n\n#查看当前所有分支\ngit brach\n\n\n#查看远程所有分支\ngit branch -r\n\n#查看所有分支 (包括远程和当前)\ngit branch -a\n\n","slug":"你会用git吗","published":1,"updated":"2020-03-31T05:41:12.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9600189otsomk1azt5","content":"<p>1.git版本回退</p>\n<p>刚来公司,用的是码云 git的方式管理项目,然后发现自己提交错了,还好可以回退</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard &lt;版本号&gt;</span><br><span class=\"line\">// 注意使用 --hard 参数会抛弃当前工作区的修改</span><br><span class=\"line\">// 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git push origin &lt;分支名&gt; --force 远程仓库就回退版本了</span><br><span class=\"line\"></span><br><span class=\"line\">ps:虽然回退了版本,但是推送记录中还是存在你之前推送的记录</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>git 分支提交</li>\n</ol>\n<p>#查看当前所有分支<br>git brach</p>\n<p>#查看远程所有分支<br>git branch -r</p>\n<p>#查看所有分支 (包括远程和当前)<br>git branch -a</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.git版本回退</p>\n<p>刚来公司,用的是码云 git的方式管理项目,然后发现自己提交错了,还好可以回退</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard &lt;版本号&gt;</span><br><span class=\"line\">// 注意使用 --hard 参数会抛弃当前工作区的修改</span><br><span class=\"line\">// 使用 --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git push origin &lt;分支名&gt; --force 远程仓库就回退版本了</span><br><span class=\"line\"></span><br><span class=\"line\">ps:虽然回退了版本,但是推送记录中还是存在你之前推送的记录</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>git 分支提交</li>\n</ol>\n<p>#查看当前所有分支<br>git brach</p>\n<p>#查看远程所有分支<br>git branch -r</p>\n<p>#查看所有分支 (包括远程和当前)<br>git branch -a</p>\n"},{"title":"ubuntu服务器开启rewrite","date":"2018-07-04T16:49:00.000Z","_content":"自己部署了一个小项目到自己的服务器上,准备写几个接口写一个app练练手,用了php的CI框架,但是传上去发现不能用?\n一直提示我路径不存在?传了N多次还是这样,开始思考到底哪里出问题了,下载了一个新的CI框架部署在本地,写了与i个测试界面\n也是进不去,对比了一下,发现少了一个 .htaccess 文件,原来是它搞的鬼,但是看了看服务器上的项目根目录是有的啊\n一脸好奇,有问题找百度,发现是rewrite模块没打开(但是百度的很多方法都是没用的,你们抄来抄去有意思吗?)\n\n终端输入:sudo a2enmod\n接着输入: rewrite\n\n然后编辑配置文件,修改www目录下的权限\ncd /etc/apache2\nsudo vim apache2.conf\n\n\n``\n<Directory /var/www/>\n​    Options Indexes FollowSymlinks\n​    AllowOverride None\n​    Require all granted\n</Directory>\n\n``\n\n把 AllowOverride None 修改为 AllowOverride All\n\n重启apache2  sudo /etc/init.d/apache2 restart\n\n完成\n","source":"_posts/ubuntu服务器开启rewrite.md","raw":"---\ntitle: ubuntu服务器开启rewrite\ndate: 2018-07-05 00:49:00\ntags: \n- 服务器\n---\n自己部署了一个小项目到自己的服务器上,准备写几个接口写一个app练练手,用了php的CI框架,但是传上去发现不能用?\n一直提示我路径不存在?传了N多次还是这样,开始思考到底哪里出问题了,下载了一个新的CI框架部署在本地,写了与i个测试界面\n也是进不去,对比了一下,发现少了一个 .htaccess 文件,原来是它搞的鬼,但是看了看服务器上的项目根目录是有的啊\n一脸好奇,有问题找百度,发现是rewrite模块没打开(但是百度的很多方法都是没用的,你们抄来抄去有意思吗?)\n\n终端输入:sudo a2enmod\n接着输入: rewrite\n\n然后编辑配置文件,修改www目录下的权限\ncd /etc/apache2\nsudo vim apache2.conf\n\n\n``\n<Directory /var/www/>\n​    Options Indexes FollowSymlinks\n​    AllowOverride None\n​    Require all granted\n</Directory>\n\n``\n\n把 AllowOverride None 修改为 AllowOverride All\n\n重启apache2  sudo /etc/init.d/apache2 restart\n\n完成\n","slug":"ubuntu服务器开启rewrite","published":1,"updated":"2020-03-31T05:41:12.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje98001a9ots30xlo04b","content":"<p>自己部署了一个小项目到自己的服务器上,准备写几个接口写一个app练练手,用了php的CI框架,但是传上去发现不能用?<br>一直提示我路径不存在?传了N多次还是这样,开始思考到底哪里出问题了,下载了一个新的CI框架部署在本地,写了与i个测试界面<br>也是进不去,对比了一下,发现少了一个 .htaccess 文件,原来是它搞的鬼,但是看了看服务器上的项目根目录是有的啊<br>一脸好奇,有问题找百度,发现是rewrite模块没打开(但是百度的很多方法都是没用的,你们抄来抄去有意思吗?)</p>\n<p>终端输入:sudo a2enmod<br>接着输入: rewrite</p>\n<p>然后编辑配置文件,修改www目录下的权限<br>cd /etc/apache2<br>sudo vim apache2.conf</p>\n<p><code></code></p>\n&lt;Directory /var/www/&gt;<br>​    Options Indexes FollowSymlinks<br>​    AllowOverride None<br>​    Require all granted<br>\n\n<p><code></code></p>\n<p>把 AllowOverride None 修改为 AllowOverride All</p>\n<p>重启apache2  sudo /etc/init.d/apache2 restart</p>\n<p>完成</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自己部署了一个小项目到自己的服务器上,准备写几个接口写一个app练练手,用了php的CI框架,但是传上去发现不能用?<br>一直提示我路径不存在?传了N多次还是这样,开始思考到底哪里出问题了,下载了一个新的CI框架部署在本地,写了与i个测试界面<br>也是进不去,对比了一下,发现少了一个 .htaccess 文件,原来是它搞的鬼,但是看了看服务器上的项目根目录是有的啊<br>一脸好奇,有问题找百度,发现是rewrite模块没打开(但是百度的很多方法都是没用的,你们抄来抄去有意思吗?)</p>\n<p>终端输入:sudo a2enmod<br>接着输入: rewrite</p>\n<p>然后编辑配置文件,修改www目录下的权限<br>cd /etc/apache2<br>sudo vim apache2.conf</p>\n<p><code></code></p>\n&lt;Directory /var/www/&gt;<br>​    Options Indexes FollowSymlinks<br>​    AllowOverride None<br>​    Require all granted<br>\n\n<p><code></code></p>\n<p>把 AllowOverride None 修改为 AllowOverride All</p>\n<p>重启apache2  sudo /etc/init.d/apache2 restart</p>\n<p>完成</p>\n"},{"title":"会换行的ViewGroup","date":"2018-09-29T14:27:58.000Z","_content":"\n碰到一个需求,就是在不知道有多少个标签的情况下全部显示它们,如果放不下就需要换行,但是Horizontal的linearLayout不会自动换行,所以这里只能重写ViewGroup来实现这一个需求.\n\n\n首先需要确定的由于是超出宽度自动换行,那么它的高度肯定是不确定的(在一般情况下),即我们需要计算整个的高度,所以不仅要重写onLayout,还要重写omMeasure,一开始尝试继承ViewGroup,但是因为计算位置需要使用到margin值,而ViewGroup.LayoutParams没有margin值,所以这里选择继承了LinearLayout\n\n\n首先需要计算高度\n\n```\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int measureWidth=MeasureSpec.getSize(widthMeasureSpec);\n        int count=getChildCount();\n        int width=0;\n        int height=0;\n        int lineHeight=0;\n        for (int i = 0; i < count; i++) {\n            View child=getChildAt(i);\n            measureChild(child,widthMeasureSpec,heightMeasureSpec);\n            LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();\n            //获取子View的高度和宽度 需要加上Margin值\n            int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;\n            int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;\n            if(childWidth+width>measureWidth){\n                //如果当前View加上之前累加的View的宽度大于父元素的宽度,那么需要换行\n                //而且下一行重新开始计算需要将width置为0,然后父View加上这一行的高度\n                height+=lineHeight;\n                lineHeight=childHeight;\n                width=childWidth;\n            }else {\n                //若没有超过父View的宽度,那么需要将宽度累加,然后该行的高度取最高的子\n                //View的高度\n                width+=childWidth;\n                lineHeight=Math.max(lineHeight,childHeight);\n            }\n            //特殊处理\n            if(i==count-1)\n                height+=lineHeight;\n        }\n        setMeasuredDimension(measureWidth,height);\n    }\n```\n\n\n首先需要遍历计算子元素的高度,既然是自动换行,那么就表示当累加的宽度大于或等于父元素的宽度时,就需要在下一行重新开始,而这一行的高度取该行高度最大的子元素的值作为该行的高度,一次类推相加,最后一个View需要单独处理因为如果加上最后一个View,还没有超过父元素的宽度,那么就不会执行\n```\n    width+=childWidth;\n    lineHeight=Math.max(lineHeight,childHeight);\n```\n这两行代码,如果刚好超出,那么更需要加上这个View的高度了,否则刚好将最后一个View隐藏了,最后\n```\nsetMeasuredDimension(measureWidth,height);\n```\n重新设置宽高(宽度不变,但是高度会随之改变)\n\n\n\n![没有变化](http://image.honglingqi.cn/blogImages/1001/two.png)\n\n\n![高度改变](http://image.honglingqi.cn/blogImages/1001/three.png)\n\n\n很明显的看得出来高度发生了变化(背景颜色),但是布局还是没有改变,所以接下去要重写onLayout布局这些子View\n,首先还是要遍历子View(其实代码比较简单)\n\n```\n\n int count=getChildCount();\n        int left=0,top=0,height=0;\n        for (int i = 0; i < count; i++) {\n            View child=getChildAt(i);\n            LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();\n            int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;\n            int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;\n            if(left+childWidth>=getMeasuredWidth()){\n                //left代表View的左坐标 每当需要换行时,那么left必定是0\n                left=0;\n                //换行之后改行的top需要重新计算高度,\n                top+=height;\n                //代表该行最高的高度需要重新\n                height=childHeight;\n            }else {\n                //如果没有超过,还在这一行,那么这一行的高度需要改变,去最大值\n                height=Math.max(height,childHeight);\n            }\n            //View开始布局,需要注意的是要加上leftMargin和topMargin值,因为我们是把它//们算到整个子View中去的,如果不加上,那么这些margin值会成为子View的额外\n            //宽高\n            child.layout(left+layoutParams.leftMargin,top+layoutParams.topMargin,left+childWidth,top+childHeight);\n            //left值更新\n            left+=childWidth;\n        }\n```\n\nView.layout四个参数分辨是左上右下的坐标值,还是一样获取到子View的数据,然后在给他们布局,具体含义写在注释中了,至此就完成了自动换行的需求了\n\n\n\n![自动换行](http://image.honglingqi.cn/blogImages/1001/one.png)\n\n\n\n大半夜写的不够好, 脑子也不是很清楚 也不知道怎么写才能表述清楚,表达可能是我的软肋把,如何去把这个功能和思路描述完整.希望慢慢变好\n","source":"_posts/会换行的ViewGroup.md","raw":"---\ntitle: 会换行的ViewGroup\ndate: 2018-09-29 22:27:58\ntags:\n- android\n---\n\n碰到一个需求,就是在不知道有多少个标签的情况下全部显示它们,如果放不下就需要换行,但是Horizontal的linearLayout不会自动换行,所以这里只能重写ViewGroup来实现这一个需求.\n\n\n首先需要确定的由于是超出宽度自动换行,那么它的高度肯定是不确定的(在一般情况下),即我们需要计算整个的高度,所以不仅要重写onLayout,还要重写omMeasure,一开始尝试继承ViewGroup,但是因为计算位置需要使用到margin值,而ViewGroup.LayoutParams没有margin值,所以这里选择继承了LinearLayout\n\n\n首先需要计算高度\n\n```\n @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int measureWidth=MeasureSpec.getSize(widthMeasureSpec);\n        int count=getChildCount();\n        int width=0;\n        int height=0;\n        int lineHeight=0;\n        for (int i = 0; i < count; i++) {\n            View child=getChildAt(i);\n            measureChild(child,widthMeasureSpec,heightMeasureSpec);\n            LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();\n            //获取子View的高度和宽度 需要加上Margin值\n            int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;\n            int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;\n            if(childWidth+width>measureWidth){\n                //如果当前View加上之前累加的View的宽度大于父元素的宽度,那么需要换行\n                //而且下一行重新开始计算需要将width置为0,然后父View加上这一行的高度\n                height+=lineHeight;\n                lineHeight=childHeight;\n                width=childWidth;\n            }else {\n                //若没有超过父View的宽度,那么需要将宽度累加,然后该行的高度取最高的子\n                //View的高度\n                width+=childWidth;\n                lineHeight=Math.max(lineHeight,childHeight);\n            }\n            //特殊处理\n            if(i==count-1)\n                height+=lineHeight;\n        }\n        setMeasuredDimension(measureWidth,height);\n    }\n```\n\n\n首先需要遍历计算子元素的高度,既然是自动换行,那么就表示当累加的宽度大于或等于父元素的宽度时,就需要在下一行重新开始,而这一行的高度取该行高度最大的子元素的值作为该行的高度,一次类推相加,最后一个View需要单独处理因为如果加上最后一个View,还没有超过父元素的宽度,那么就不会执行\n```\n    width+=childWidth;\n    lineHeight=Math.max(lineHeight,childHeight);\n```\n这两行代码,如果刚好超出,那么更需要加上这个View的高度了,否则刚好将最后一个View隐藏了,最后\n```\nsetMeasuredDimension(measureWidth,height);\n```\n重新设置宽高(宽度不变,但是高度会随之改变)\n\n\n\n![没有变化](http://image.honglingqi.cn/blogImages/1001/two.png)\n\n\n![高度改变](http://image.honglingqi.cn/blogImages/1001/three.png)\n\n\n很明显的看得出来高度发生了变化(背景颜色),但是布局还是没有改变,所以接下去要重写onLayout布局这些子View\n,首先还是要遍历子View(其实代码比较简单)\n\n```\n\n int count=getChildCount();\n        int left=0,top=0,height=0;\n        for (int i = 0; i < count; i++) {\n            View child=getChildAt(i);\n            LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();\n            int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;\n            int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;\n            if(left+childWidth>=getMeasuredWidth()){\n                //left代表View的左坐标 每当需要换行时,那么left必定是0\n                left=0;\n                //换行之后改行的top需要重新计算高度,\n                top+=height;\n                //代表该行最高的高度需要重新\n                height=childHeight;\n            }else {\n                //如果没有超过,还在这一行,那么这一行的高度需要改变,去最大值\n                height=Math.max(height,childHeight);\n            }\n            //View开始布局,需要注意的是要加上leftMargin和topMargin值,因为我们是把它//们算到整个子View中去的,如果不加上,那么这些margin值会成为子View的额外\n            //宽高\n            child.layout(left+layoutParams.leftMargin,top+layoutParams.topMargin,left+childWidth,top+childHeight);\n            //left值更新\n            left+=childWidth;\n        }\n```\n\nView.layout四个参数分辨是左上右下的坐标值,还是一样获取到子View的数据,然后在给他们布局,具体含义写在注释中了,至此就完成了自动换行的需求了\n\n\n\n![自动换行](http://image.honglingqi.cn/blogImages/1001/one.png)\n\n\n\n大半夜写的不够好, 脑子也不是很清楚 也不知道怎么写才能表述清楚,表达可能是我的软肋把,如何去把这个功能和思路描述完整.希望慢慢变好\n","slug":"会换行的ViewGroup","published":1,"updated":"2020-03-31T05:41:12.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9b001c9otslxxdzkwm","content":"<p>碰到一个需求,就是在不知道有多少个标签的情况下全部显示它们,如果放不下就需要换行,但是Horizontal的linearLayout不会自动换行,所以这里只能重写ViewGroup来实现这一个需求.</p>\n<p>首先需要确定的由于是超出宽度自动换行,那么它的高度肯定是不确定的(在一般情况下),即我们需要计算整个的高度,所以不仅要重写onLayout,还要重写omMeasure,一开始尝试继承ViewGroup,但是因为计算位置需要使用到margin值,而ViewGroup.LayoutParams没有margin值,所以这里选择继承了LinearLayout</p>\n<p>首先需要计算高度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">       int measureWidth=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">       int count=getChildCount();</span><br><span class=\"line\">       int width=0;</span><br><span class=\"line\">       int height=0;</span><br><span class=\"line\">       int lineHeight=0;</span><br><span class=\"line\">       for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">           View child=getChildAt(i);</span><br><span class=\"line\">           measureChild(child,widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\">           LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">           //获取子View的高度和宽度 需要加上Margin值</span><br><span class=\"line\">           int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;</span><br><span class=\"line\">           int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;</span><br><span class=\"line\">           if(childWidth+width&gt;measureWidth)&#123;</span><br><span class=\"line\">               //如果当前View加上之前累加的View的宽度大于父元素的宽度,那么需要换行</span><br><span class=\"line\">               //而且下一行重新开始计算需要将width置为0,然后父View加上这一行的高度</span><br><span class=\"line\">               height+=lineHeight;</span><br><span class=\"line\">               lineHeight=childHeight;</span><br><span class=\"line\">               width=childWidth;</span><br><span class=\"line\">           &#125;else &#123;</span><br><span class=\"line\">               //若没有超过父View的宽度,那么需要将宽度累加,然后该行的高度取最高的子</span><br><span class=\"line\">               //View的高度</span><br><span class=\"line\">               width+=childWidth;</span><br><span class=\"line\">               lineHeight=Math.max(lineHeight,childHeight);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           //特殊处理</span><br><span class=\"line\">           if(i==count-1)</span><br><span class=\"line\">               height+=lineHeight;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       setMeasuredDimension(measureWidth,height);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先需要遍历计算子元素的高度,既然是自动换行,那么就表示当累加的宽度大于或等于父元素的宽度时,就需要在下一行重新开始,而这一行的高度取该行高度最大的子元素的值作为该行的高度,一次类推相加,最后一个View需要单独处理因为如果加上最后一个View,还没有超过父元素的宽度,那么就不会执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width+=childWidth;</span><br><span class=\"line\">lineHeight=Math.max(lineHeight,childHeight);</span><br></pre></td></tr></table></figure></p>\n<p>这两行代码,如果刚好超出,那么更需要加上这个View的高度了,否则刚好将最后一个View隐藏了,最后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMeasuredDimension(measureWidth,height);</span><br></pre></td></tr></table></figure></p>\n<p>重新设置宽高(宽度不变,但是高度会随之改变)</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/two.png\" alt=\"没有变化\"></p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/three.png\" alt=\"高度改变\"></p>\n<p>很明显的看得出来高度发生了变化(背景颜色),但是布局还是没有改变,所以接下去要重写onLayout布局这些子View<br>,首先还是要遍历子View(其实代码比较简单)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int count=getChildCount();</span><br><span class=\"line\">       int left=0,top=0,height=0;</span><br><span class=\"line\">       for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">           View child=getChildAt(i);</span><br><span class=\"line\">           LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">           int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;</span><br><span class=\"line\">           int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;</span><br><span class=\"line\">           if(left+childWidth&gt;=getMeasuredWidth())&#123;</span><br><span class=\"line\">               //left代表View的左坐标 每当需要换行时,那么left必定是0</span><br><span class=\"line\">               left=0;</span><br><span class=\"line\">               //换行之后改行的top需要重新计算高度,</span><br><span class=\"line\">               top+=height;</span><br><span class=\"line\">               //代表该行最高的高度需要重新</span><br><span class=\"line\">               height=childHeight;</span><br><span class=\"line\">           &#125;else &#123;</span><br><span class=\"line\">               //如果没有超过,还在这一行,那么这一行的高度需要改变,去最大值</span><br><span class=\"line\">               height=Math.max(height,childHeight);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           //View开始布局,需要注意的是要加上leftMargin和topMargin值,因为我们是把它//们算到整个子View中去的,如果不加上,那么这些margin值会成为子View的额外</span><br><span class=\"line\">           //宽高</span><br><span class=\"line\">           child.layout(left+layoutParams.leftMargin,top+layoutParams.topMargin,left+childWidth,top+childHeight);</span><br><span class=\"line\">           //left值更新</span><br><span class=\"line\">           left+=childWidth;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>View.layout四个参数分辨是左上右下的坐标值,还是一样获取到子View的数据,然后在给他们布局,具体含义写在注释中了,至此就完成了自动换行的需求了</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/one.png\" alt=\"自动换行\"></p>\n<p>大半夜写的不够好, 脑子也不是很清楚 也不知道怎么写才能表述清楚,表达可能是我的软肋把,如何去把这个功能和思路描述完整.希望慢慢变好</p>\n","site":{"data":{}},"excerpt":"","more":"<p>碰到一个需求,就是在不知道有多少个标签的情况下全部显示它们,如果放不下就需要换行,但是Horizontal的linearLayout不会自动换行,所以这里只能重写ViewGroup来实现这一个需求.</p>\n<p>首先需要确定的由于是超出宽度自动换行,那么它的高度肯定是不确定的(在一般情况下),即我们需要计算整个的高度,所以不仅要重写onLayout,还要重写omMeasure,一开始尝试继承ViewGroup,但是因为计算位置需要使用到margin值,而ViewGroup.LayoutParams没有margin值,所以这里选择继承了LinearLayout</p>\n<p>首先需要计算高度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">       int measureWidth=MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">       int count=getChildCount();</span><br><span class=\"line\">       int width=0;</span><br><span class=\"line\">       int height=0;</span><br><span class=\"line\">       int lineHeight=0;</span><br><span class=\"line\">       for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">           View child=getChildAt(i);</span><br><span class=\"line\">           measureChild(child,widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\">           LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">           //获取子View的高度和宽度 需要加上Margin值</span><br><span class=\"line\">           int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;</span><br><span class=\"line\">           int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;</span><br><span class=\"line\">           if(childWidth+width&gt;measureWidth)&#123;</span><br><span class=\"line\">               //如果当前View加上之前累加的View的宽度大于父元素的宽度,那么需要换行</span><br><span class=\"line\">               //而且下一行重新开始计算需要将width置为0,然后父View加上这一行的高度</span><br><span class=\"line\">               height+=lineHeight;</span><br><span class=\"line\">               lineHeight=childHeight;</span><br><span class=\"line\">               width=childWidth;</span><br><span class=\"line\">           &#125;else &#123;</span><br><span class=\"line\">               //若没有超过父View的宽度,那么需要将宽度累加,然后该行的高度取最高的子</span><br><span class=\"line\">               //View的高度</span><br><span class=\"line\">               width+=childWidth;</span><br><span class=\"line\">               lineHeight=Math.max(lineHeight,childHeight);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           //特殊处理</span><br><span class=\"line\">           if(i==count-1)</span><br><span class=\"line\">               height+=lineHeight;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       setMeasuredDimension(measureWidth,height);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>首先需要遍历计算子元素的高度,既然是自动换行,那么就表示当累加的宽度大于或等于父元素的宽度时,就需要在下一行重新开始,而这一行的高度取该行高度最大的子元素的值作为该行的高度,一次类推相加,最后一个View需要单独处理因为如果加上最后一个View,还没有超过父元素的宽度,那么就不会执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width+=childWidth;</span><br><span class=\"line\">lineHeight=Math.max(lineHeight,childHeight);</span><br></pre></td></tr></table></figure></p>\n<p>这两行代码,如果刚好超出,那么更需要加上这个View的高度了,否则刚好将最后一个View隐藏了,最后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setMeasuredDimension(measureWidth,height);</span><br></pre></td></tr></table></figure></p>\n<p>重新设置宽高(宽度不变,但是高度会随之改变)</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/two.png\" alt=\"没有变化\"></p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/three.png\" alt=\"高度改变\"></p>\n<p>很明显的看得出来高度发生了变化(背景颜色),但是布局还是没有改变,所以接下去要重写onLayout布局这些子View<br>,首先还是要遍历子View(其实代码比较简单)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int count=getChildCount();</span><br><span class=\"line\">       int left=0,top=0,height=0;</span><br><span class=\"line\">       for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">           View child=getChildAt(i);</span><br><span class=\"line\">           LinearLayout.LayoutParams layoutParams= (LayoutParams) child.getLayoutParams();</span><br><span class=\"line\">           int childWidth=child.getMeasuredWidth()+layoutParams.leftMargin+layoutParams.rightMargin;</span><br><span class=\"line\">           int childHeight=child.getMeasuredHeight()+layoutParams.topMargin+layoutParams.bottomMargin;</span><br><span class=\"line\">           if(left+childWidth&gt;=getMeasuredWidth())&#123;</span><br><span class=\"line\">               //left代表View的左坐标 每当需要换行时,那么left必定是0</span><br><span class=\"line\">               left=0;</span><br><span class=\"line\">               //换行之后改行的top需要重新计算高度,</span><br><span class=\"line\">               top+=height;</span><br><span class=\"line\">               //代表该行最高的高度需要重新</span><br><span class=\"line\">               height=childHeight;</span><br><span class=\"line\">           &#125;else &#123;</span><br><span class=\"line\">               //如果没有超过,还在这一行,那么这一行的高度需要改变,去最大值</span><br><span class=\"line\">               height=Math.max(height,childHeight);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           //View开始布局,需要注意的是要加上leftMargin和topMargin值,因为我们是把它//们算到整个子View中去的,如果不加上,那么这些margin值会成为子View的额外</span><br><span class=\"line\">           //宽高</span><br><span class=\"line\">           child.layout(left+layoutParams.leftMargin,top+layoutParams.topMargin,left+childWidth,top+childHeight);</span><br><span class=\"line\">           //left值更新</span><br><span class=\"line\">           left+=childWidth;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>View.layout四个参数分辨是左上右下的坐标值,还是一样获取到子View的数据,然后在给他们布局,具体含义写在注释中了,至此就完成了自动换行的需求了</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/1001/one.png\" alt=\"自动换行\"></p>\n<p>大半夜写的不够好, 脑子也不是很清楚 也不知道怎么写才能表述清楚,表达可能是我的软肋把,如何去把这个功能和思路描述完整.希望慢慢变好</p>\n"},{"title":"圆形View","date":"2018-11-29T08:14:10.000Z","_content":"\n圆形的图片在APP中是非常的常见的,之前就学习过了怎么处理自定义的View来实现圆形的图片,过了好久又忘记了\n,所以来写一篇文章记录一下:\n\n使用BitmapShader来设置圆形或者圆角的图片:\n在官方的定义是:Shader used to draw a bitmap as a texture BitmapShader  使用特定的图片来作为纹理来使用\n在Paint.setShader来使用\n\n       构造函数: public BitmapShader(@NonNull Bitmap bitmap, TileMode tileX, TileMode tileY)\n\nbitmap:需要变化的图片\ntileX:在X轴上的变化方式\ntileY:在Y轴上的变化方式\n变化方式有三个值可以选择:\n\n1. CLAMP 拉伸:横向的最后一个横行像素，不断的重复，纵项的那一列像素，不断的重复；\n1. REPEAT 重复:就是横向、纵向不断重复这个bitmap\n1. MIRROR 镜像:横向不断翻转重复，纵向不断翻转重复；\n\n为了防止图片过大或者过小,可以通过给BitmapShader设置Matrix来控制缩放\n\n     Matrix mMatrix = new Matrix();\n     mMatrix.setScale(float sx, float sy);\n\n分别是X轴和Y轴的缩放倍数 然后用shader.setLocalMatrix(Matrix matrix);来实现\n然后再Paint中设置setShader(Shader shader)\n最后用canvas.drawCircle()来画一个圆并使用设置了BitmapShader的Paint来绘制就可以完成圆形的ImageView了\n也可以使用canvas.drawRoundRect()来绘制圆角的矩形\n","source":"_posts/圆形View.md","raw":"---\ntitle: 圆形View\ndate: 2018-11-29 16:14:10\ntags:\n- android\n---\n\n圆形的图片在APP中是非常的常见的,之前就学习过了怎么处理自定义的View来实现圆形的图片,过了好久又忘记了\n,所以来写一篇文章记录一下:\n\n使用BitmapShader来设置圆形或者圆角的图片:\n在官方的定义是:Shader used to draw a bitmap as a texture BitmapShader  使用特定的图片来作为纹理来使用\n在Paint.setShader来使用\n\n       构造函数: public BitmapShader(@NonNull Bitmap bitmap, TileMode tileX, TileMode tileY)\n\nbitmap:需要变化的图片\ntileX:在X轴上的变化方式\ntileY:在Y轴上的变化方式\n变化方式有三个值可以选择:\n\n1. CLAMP 拉伸:横向的最后一个横行像素，不断的重复，纵项的那一列像素，不断的重复；\n1. REPEAT 重复:就是横向、纵向不断重复这个bitmap\n1. MIRROR 镜像:横向不断翻转重复，纵向不断翻转重复；\n\n为了防止图片过大或者过小,可以通过给BitmapShader设置Matrix来控制缩放\n\n     Matrix mMatrix = new Matrix();\n     mMatrix.setScale(float sx, float sy);\n\n分别是X轴和Y轴的缩放倍数 然后用shader.setLocalMatrix(Matrix matrix);来实现\n然后再Paint中设置setShader(Shader shader)\n最后用canvas.drawCircle()来画一个圆并使用设置了BitmapShader的Paint来绘制就可以完成圆形的ImageView了\n也可以使用canvas.drawRoundRect()来绘制圆角的矩形\n","slug":"圆形View","published":1,"updated":"2020-03-31T05:41:12.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9d001e9ots26mnfhc3","content":"<p>圆形的图片在APP中是非常的常见的,之前就学习过了怎么处理自定义的View来实现圆形的图片,过了好久又忘记了<br>,所以来写一篇文章记录一下:</p>\n<p>使用BitmapShader来设置圆形或者圆角的图片:<br>在官方的定义是:Shader used to draw a bitmap as a texture BitmapShader  使用特定的图片来作为纹理来使用<br>在Paint.setShader来使用</p>\n<pre><code>构造函数: public BitmapShader(@NonNull Bitmap bitmap, TileMode tileX, TileMode tileY)\n</code></pre><p>bitmap:需要变化的图片<br>tileX:在X轴上的变化方式<br>tileY:在Y轴上的变化方式<br>变化方式有三个值可以选择:</p>\n<ol>\n<li>CLAMP 拉伸:横向的最后一个横行像素，不断的重复，纵项的那一列像素，不断的重复；</li>\n<li>REPEAT 重复:就是横向、纵向不断重复这个bitmap</li>\n<li>MIRROR 镜像:横向不断翻转重复，纵向不断翻转重复；</li>\n</ol>\n<p>为了防止图片过大或者过小,可以通过给BitmapShader设置Matrix来控制缩放</p>\n<pre><code>Matrix mMatrix = new Matrix();\nmMatrix.setScale(float sx, float sy);\n</code></pre><p>分别是X轴和Y轴的缩放倍数 然后用shader.setLocalMatrix(Matrix matrix);来实现<br>然后再Paint中设置setShader(Shader shader)<br>最后用canvas.drawCircle()来画一个圆并使用设置了BitmapShader的Paint来绘制就可以完成圆形的ImageView了<br>也可以使用canvas.drawRoundRect()来绘制圆角的矩形</p>\n","site":{"data":{}},"excerpt":"","more":"<p>圆形的图片在APP中是非常的常见的,之前就学习过了怎么处理自定义的View来实现圆形的图片,过了好久又忘记了<br>,所以来写一篇文章记录一下:</p>\n<p>使用BitmapShader来设置圆形或者圆角的图片:<br>在官方的定义是:Shader used to draw a bitmap as a texture BitmapShader  使用特定的图片来作为纹理来使用<br>在Paint.setShader来使用</p>\n<pre><code>构造函数: public BitmapShader(@NonNull Bitmap bitmap, TileMode tileX, TileMode tileY)\n</code></pre><p>bitmap:需要变化的图片<br>tileX:在X轴上的变化方式<br>tileY:在Y轴上的变化方式<br>变化方式有三个值可以选择:</p>\n<ol>\n<li>CLAMP 拉伸:横向的最后一个横行像素，不断的重复，纵项的那一列像素，不断的重复；</li>\n<li>REPEAT 重复:就是横向、纵向不断重复这个bitmap</li>\n<li>MIRROR 镜像:横向不断翻转重复，纵向不断翻转重复；</li>\n</ol>\n<p>为了防止图片过大或者过小,可以通过给BitmapShader设置Matrix来控制缩放</p>\n<pre><code>Matrix mMatrix = new Matrix();\nmMatrix.setScale(float sx, float sy);\n</code></pre><p>分别是X轴和Y轴的缩放倍数 然后用shader.setLocalMatrix(Matrix matrix);来实现<br>然后再Paint中设置setShader(Shader shader)<br>最后用canvas.drawCircle()来画一个圆并使用设置了BitmapShader的Paint来绘制就可以完成圆形的ImageView了<br>也可以使用canvas.drawRoundRect()来绘制圆角的矩形</p>\n"},{"title":"多种f线程方式上传图片的区别","date":"2019-06-27T06:11:09.000Z","_content":"","source":"_posts/多种线程方式上传图片的区别.md","raw":"---\ntitle: 多种f线程方式上传图片的区别\ndate: 2019-06-27 14:11:09\ntags:\n---\n","slug":"多种线程方式上传图片的区别","published":1,"updated":"2020-03-31T05:41:12.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9e001g9otsm8xcdpyg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"开发艺术第一章笔记","date":"2019-05-22T12:55:38.000Z","_content":"## Activity生命周期\n\n### 正常Activity生命周期\n\n特别说明:\n1. Activity第一次启动时 需要经历的是onCreate->onStart->onResume\n2. 用户打开新的Activity或者回到桌面时 都会调用onPause,但是不一定调用onStop,比如新打开的Activity是透明的时候,onStop不会执行\n3. 用户回到Activity的时候 onRestart->onStart->onResume\n4. back键返回时 执行 onPause->onStop->onDestroy\n5. onStop、onStart与onPuase、onResume区别:前者是从Activity是否可见的角度,后者是Activity是否在前台的角度,就如同3中打开一个透明的Activity,它是可见的,但是没有位于前台(因为它上面还有一个Activity),所以调用了onPause而没有调用onStop\n\n6. 当前在ActivityA,现在打开ActivityB,那么先调用ActivityA的onPause,然后在调用ActivityB的onCreate->onStart->onResume这时确定ActivityA不可见了,然后调用ActivityA的onStop,\n这也意外了,不能再onPause和onStop中操作复杂的逻辑,尤其是在onPause中,如果时必须的,尽量放在onStop中执行\n\n\n\n### 异常情况下Activity的生命周期\n\n\n* 资源相关的系统配置发生改变导致Activity被杀死并重新创建\n\n最常见的是横屏和竖屏相互切换,默认情况下Activity会销毁并重建,不过我们也可以阻止系统重新创建Activity\n\n1. 系统会调用onSaveInstanceState来保存销毁前的数据(保存在bundle中)(保存的数据有当前的视图结构,用户输入的数据,View滑动的位置等,因为View也由这两个方法),然后在新建是调用onRestoreInstanceState来恢复数据\n2. onSaveInstanceState会在onStop之前调用,但是它不和onPause有联系,既可能在它之前也可能在之后,但是onRestoreInstanceState会在onStart后调用\n\n\n\n\n\n阻止系统重新创建Activity:修改系统的配置项,常见的配置项有三个\n\n* locale:设备的本地位置发生了改变,一般是指切换了系统语言\n* orientation:屏幕方向发生了改变\n* keyboardHidden:键盘的访问性发生了改变,比如用户调出了键盘\n* screenSize:屏幕尺寸发生了改变,当旋转屏幕时或者屏幕尺寸发生变化,只争对minSdhVersion和targetSdkVersion有一个高于13的情况\n\n\n在AndroidManifest.xml中设置Activity如下,代表我们制定了configChanges的属性,Activity就不会创建了,取而代之的值调用Activity中onConfigurationChanged方法\n```\n android:configChanges=\"orientation|screenSize\"\n```\n\n\n* 资源内存不足导致低优先级的Activity被杀死\n优先级从高到底\n1. 前台Activity -- 正在和用户交互的Activity\n2. 可见但不是前台Activity -- 例如上面提到的透明的Activity,或者有弹窗在Activity之上\n3. 后台Activity --已经被暂停的Activity,比如执行了onStop\n\n当内存不足时,系统会从优先级最低的开始销毁Activity,并保存他们的状态,然后等他们可见时再恢复他们的状态\n<<<<<<< HEAD\n=======\n\n\n## Activity启动模式\n\nActivity采用后进先出的栈结构\n\n一共分为四种启动模式\n1. standard\n\nActivity的标准启动模式,不管该Activity是否存在实例,每次都会生成一个新的Activity(会经历onCreate->onStart->onResume),而且它存在的任务栈和启动的他的Activity是同一个\n tips:采用ApplicationContext启动Activity会报错,因为ApplicationContext无法实例化成一个Activity,所以系统不知道将这个启动的Activity放入哪一个任务栈,导致报错\n\n2. singleTop\n\n栈顶复用模式,如果要启动的Activity位于栈顶,那么就不会重新创建该Activity,而是直接复用,并且会调用他的onNewIntent方法,但是如果该Activity实例不是在栈顶,那么还是会新建Activity实例并压入栈顶\n\n3. singleTask\n栈内复用模式,是一种单实例模式的思想,如果要启动的Activity在栈内存在实例,那么就会直接使用这个实例,如果不存在,那么就会创建实例并压入栈内\n tips: \n \n * 如果栈内存在直接调用的话,如果在栈顶,那么类似singleTop模式,如果不是栈顶,那么根据Activity后进先出的规则,位于该Activity之上的Activity将全部出栈被销毁(适用于返回首页操作)\n * 启动一个该模式的Activity,首先系统回去寻找是否存在A的任务栈,如果不存在,比如我在S1中存在该Activity实例,但是我想在S2中启动该Activity,那么系统就新建该Activity并压入S2任务栈;\n 如果存在,那么就直接使用,如果任务栈不存在,那么久直接新建并压入该栈\n\n4. singleInstance\n 比singleTask更加极端的单实例模式,该模式启动的Activity会单独位于一个任务栈内,由于栈内复用的特性,那么之后重复调用该Activity都不会又新的实例出现,除非该任务栈被销毁了\n>>>>>>> ea1402fa77e258cb7f4ab3d6e20896f0eb8edca7\n","source":"_posts/开发艺术第一章笔记.md","raw":"---\ntitle: 开发艺术第一章笔记\ndate: 2019-05-22 20:55:38\ntags:\n---\n## Activity生命周期\n\n### 正常Activity生命周期\n\n特别说明:\n1. Activity第一次启动时 需要经历的是onCreate->onStart->onResume\n2. 用户打开新的Activity或者回到桌面时 都会调用onPause,但是不一定调用onStop,比如新打开的Activity是透明的时候,onStop不会执行\n3. 用户回到Activity的时候 onRestart->onStart->onResume\n4. back键返回时 执行 onPause->onStop->onDestroy\n5. onStop、onStart与onPuase、onResume区别:前者是从Activity是否可见的角度,后者是Activity是否在前台的角度,就如同3中打开一个透明的Activity,它是可见的,但是没有位于前台(因为它上面还有一个Activity),所以调用了onPause而没有调用onStop\n\n6. 当前在ActivityA,现在打开ActivityB,那么先调用ActivityA的onPause,然后在调用ActivityB的onCreate->onStart->onResume这时确定ActivityA不可见了,然后调用ActivityA的onStop,\n这也意外了,不能再onPause和onStop中操作复杂的逻辑,尤其是在onPause中,如果时必须的,尽量放在onStop中执行\n\n\n\n### 异常情况下Activity的生命周期\n\n\n* 资源相关的系统配置发生改变导致Activity被杀死并重新创建\n\n最常见的是横屏和竖屏相互切换,默认情况下Activity会销毁并重建,不过我们也可以阻止系统重新创建Activity\n\n1. 系统会调用onSaveInstanceState来保存销毁前的数据(保存在bundle中)(保存的数据有当前的视图结构,用户输入的数据,View滑动的位置等,因为View也由这两个方法),然后在新建是调用onRestoreInstanceState来恢复数据\n2. onSaveInstanceState会在onStop之前调用,但是它不和onPause有联系,既可能在它之前也可能在之后,但是onRestoreInstanceState会在onStart后调用\n\n\n\n\n\n阻止系统重新创建Activity:修改系统的配置项,常见的配置项有三个\n\n* locale:设备的本地位置发生了改变,一般是指切换了系统语言\n* orientation:屏幕方向发生了改变\n* keyboardHidden:键盘的访问性发生了改变,比如用户调出了键盘\n* screenSize:屏幕尺寸发生了改变,当旋转屏幕时或者屏幕尺寸发生变化,只争对minSdhVersion和targetSdkVersion有一个高于13的情况\n\n\n在AndroidManifest.xml中设置Activity如下,代表我们制定了configChanges的属性,Activity就不会创建了,取而代之的值调用Activity中onConfigurationChanged方法\n```\n android:configChanges=\"orientation|screenSize\"\n```\n\n\n* 资源内存不足导致低优先级的Activity被杀死\n优先级从高到底\n1. 前台Activity -- 正在和用户交互的Activity\n2. 可见但不是前台Activity -- 例如上面提到的透明的Activity,或者有弹窗在Activity之上\n3. 后台Activity --已经被暂停的Activity,比如执行了onStop\n\n当内存不足时,系统会从优先级最低的开始销毁Activity,并保存他们的状态,然后等他们可见时再恢复他们的状态\n<<<<<<< HEAD\n=======\n\n\n## Activity启动模式\n\nActivity采用后进先出的栈结构\n\n一共分为四种启动模式\n1. standard\n\nActivity的标准启动模式,不管该Activity是否存在实例,每次都会生成一个新的Activity(会经历onCreate->onStart->onResume),而且它存在的任务栈和启动的他的Activity是同一个\n tips:采用ApplicationContext启动Activity会报错,因为ApplicationContext无法实例化成一个Activity,所以系统不知道将这个启动的Activity放入哪一个任务栈,导致报错\n\n2. singleTop\n\n栈顶复用模式,如果要启动的Activity位于栈顶,那么就不会重新创建该Activity,而是直接复用,并且会调用他的onNewIntent方法,但是如果该Activity实例不是在栈顶,那么还是会新建Activity实例并压入栈顶\n\n3. singleTask\n栈内复用模式,是一种单实例模式的思想,如果要启动的Activity在栈内存在实例,那么就会直接使用这个实例,如果不存在,那么就会创建实例并压入栈内\n tips: \n \n * 如果栈内存在直接调用的话,如果在栈顶,那么类似singleTop模式,如果不是栈顶,那么根据Activity后进先出的规则,位于该Activity之上的Activity将全部出栈被销毁(适用于返回首页操作)\n * 启动一个该模式的Activity,首先系统回去寻找是否存在A的任务栈,如果不存在,比如我在S1中存在该Activity实例,但是我想在S2中启动该Activity,那么系统就新建该Activity并压入S2任务栈;\n 如果存在,那么就直接使用,如果任务栈不存在,那么久直接新建并压入该栈\n\n4. singleInstance\n 比singleTask更加极端的单实例模式,该模式启动的Activity会单独位于一个任务栈内,由于栈内复用的特性,那么之后重复调用该Activity都不会又新的实例出现,除非该任务栈被销毁了\n>>>>>>> ea1402fa77e258cb7f4ab3d6e20896f0eb8edca7\n","slug":"开发艺术第一章笔记","published":1,"updated":"2020-03-31T05:41:12.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9h001i9ots5wvkxhc1","content":"<h2 id=\"Activity生命周期\"><a href=\"#Activity生命周期\" class=\"headerlink\" title=\"Activity生命周期\"></a>Activity生命周期</h2><h3 id=\"正常Activity生命周期\"><a href=\"#正常Activity生命周期\" class=\"headerlink\" title=\"正常Activity生命周期\"></a>正常Activity生命周期</h3><p>特别说明:</p>\n<ol>\n<li>Activity第一次启动时 需要经历的是onCreate-&gt;onStart-&gt;onResume</li>\n<li>用户打开新的Activity或者回到桌面时 都会调用onPause,但是不一定调用onStop,比如新打开的Activity是透明的时候,onStop不会执行</li>\n<li>用户回到Activity的时候 onRestart-&gt;onStart-&gt;onResume</li>\n<li>back键返回时 执行 onPause-&gt;onStop-&gt;onDestroy</li>\n<li><p>onStop、onStart与onPuase、onResume区别:前者是从Activity是否可见的角度,后者是Activity是否在前台的角度,就如同3中打开一个透明的Activity,它是可见的,但是没有位于前台(因为它上面还有一个Activity),所以调用了onPause而没有调用onStop</p>\n</li>\n<li><p>当前在ActivityA,现在打开ActivityB,那么先调用ActivityA的onPause,然后在调用ActivityB的onCreate-&gt;onStart-&gt;onResume这时确定ActivityA不可见了,然后调用ActivityA的onStop,<br>这也意外了,不能再onPause和onStop中操作复杂的逻辑,尤其是在onPause中,如果时必须的,尽量放在onStop中执行</p>\n</li>\n</ol>\n<h3 id=\"异常情况下Activity的生命周期\"><a href=\"#异常情况下Activity的生命周期\" class=\"headerlink\" title=\"异常情况下Activity的生命周期\"></a>异常情况下Activity的生命周期</h3><ul>\n<li>资源相关的系统配置发生改变导致Activity被杀死并重新创建</li>\n</ul>\n<p>最常见的是横屏和竖屏相互切换,默认情况下Activity会销毁并重建,不过我们也可以阻止系统重新创建Activity</p>\n<ol>\n<li>系统会调用onSaveInstanceState来保存销毁前的数据(保存在bundle中)(保存的数据有当前的视图结构,用户输入的数据,View滑动的位置等,因为View也由这两个方法),然后在新建是调用onRestoreInstanceState来恢复数据</li>\n<li>onSaveInstanceState会在onStop之前调用,但是它不和onPause有联系,既可能在它之前也可能在之后,但是onRestoreInstanceState会在onStart后调用</li>\n</ol>\n<p>阻止系统重新创建Activity:修改系统的配置项,常见的配置项有三个</p>\n<ul>\n<li>locale:设备的本地位置发生了改变,一般是指切换了系统语言</li>\n<li>orientation:屏幕方向发生了改变</li>\n<li>keyboardHidden:键盘的访问性发生了改变,比如用户调出了键盘</li>\n<li>screenSize:屏幕尺寸发生了改变,当旋转屏幕时或者屏幕尺寸发生变化,只争对minSdhVersion和targetSdkVersion有一个高于13的情况</li>\n</ul>\n<p>在AndroidManifest.xml中设置Activity如下,代表我们制定了configChanges的属性,Activity就不会创建了,取而代之的值调用Activity中onConfigurationChanged方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=&quot;orientation|screenSize&quot;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>资源内存不足导致低优先级的Activity被杀死<br>优先级从高到底</li>\n</ul>\n<ol>\n<li>前台Activity – 正在和用户交互的Activity</li>\n<li>可见但不是前台Activity – 例如上面提到的透明的Activity,或者有弹窗在Activity之上</li>\n<li>后台Activity –已经被暂停的Activity,比如执行了onStop</li>\n</ol>\n<p>当内存不足时,系统会从优先级最低的开始销毁Activity,并保存他们的状态,然后等他们可见时再恢复他们的状态</p>\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h2 id=\"Activity启动模式\"><a href=\"#Activity启动模式\" class=\"headerlink\" title=\"Activity启动模式\"></a>Activity启动模式</h2><p>Activity采用后进先出的栈结构</p>\n<p>一共分为四种启动模式</p>\n<ol>\n<li>standard</li>\n</ol>\n<p>Activity的标准启动模式,不管该Activity是否存在实例,每次都会生成一个新的Activity(会经历onCreate-&gt;onStart-&gt;onResume),而且它存在的任务栈和启动的他的Activity是同一个<br> tips:采用ApplicationContext启动Activity会报错,因为ApplicationContext无法实例化成一个Activity,所以系统不知道将这个启动的Activity放入哪一个任务栈,导致报错</p>\n<ol start=\"2\">\n<li>singleTop</li>\n</ol>\n<p>栈顶复用模式,如果要启动的Activity位于栈顶,那么就不会重新创建该Activity,而是直接复用,并且会调用他的onNewIntent方法,但是如果该Activity实例不是在栈顶,那么还是会新建Activity实例并压入栈顶</p>\n<ol start=\"3\">\n<li><p>singleTask<br>栈内复用模式,是一种单实例模式的思想,如果要启动的Activity在栈内存在实例,那么就会直接使用这个实例,如果不存在,那么就会创建实例并压入栈内<br>tips: </p>\n<ul>\n<li>如果栈内存在直接调用的话,如果在栈顶,那么类似singleTop模式,如果不是栈顶,那么根据Activity后进先出的规则,位于该Activity之上的Activity将全部出栈被销毁(适用于返回首页操作)</li>\n<li>启动一个该模式的Activity,首先系统回去寻找是否存在A的任务栈,如果不存在,比如我在S1中存在该Activity实例,但是我想在S2中启动该Activity,那么系统就新建该Activity并压入S2任务栈;<br>如果存在,那么就直接使用,如果任务栈不存在,那么久直接新建并压入该栈</li>\n</ul>\n</li>\n<li><p>singleInstance<br>比singleTask更加极端的单实例模式,该模式启动的Activity会单独位于一个任务栈内,由于栈内复用的特性,那么之后重复调用该Activity都不会又新的实例出现,除非该任务栈被销毁了</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ea1402fa77e258cb7f4ab3d6e20896f0eb8edca7</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Activity生命周期\"><a href=\"#Activity生命周期\" class=\"headerlink\" title=\"Activity生命周期\"></a>Activity生命周期</h2><h3 id=\"正常Activity生命周期\"><a href=\"#正常Activity生命周期\" class=\"headerlink\" title=\"正常Activity生命周期\"></a>正常Activity生命周期</h3><p>特别说明:</p>\n<ol>\n<li>Activity第一次启动时 需要经历的是onCreate-&gt;onStart-&gt;onResume</li>\n<li>用户打开新的Activity或者回到桌面时 都会调用onPause,但是不一定调用onStop,比如新打开的Activity是透明的时候,onStop不会执行</li>\n<li>用户回到Activity的时候 onRestart-&gt;onStart-&gt;onResume</li>\n<li>back键返回时 执行 onPause-&gt;onStop-&gt;onDestroy</li>\n<li><p>onStop、onStart与onPuase、onResume区别:前者是从Activity是否可见的角度,后者是Activity是否在前台的角度,就如同3中打开一个透明的Activity,它是可见的,但是没有位于前台(因为它上面还有一个Activity),所以调用了onPause而没有调用onStop</p>\n</li>\n<li><p>当前在ActivityA,现在打开ActivityB,那么先调用ActivityA的onPause,然后在调用ActivityB的onCreate-&gt;onStart-&gt;onResume这时确定ActivityA不可见了,然后调用ActivityA的onStop,<br>这也意外了,不能再onPause和onStop中操作复杂的逻辑,尤其是在onPause中,如果时必须的,尽量放在onStop中执行</p>\n</li>\n</ol>\n<h3 id=\"异常情况下Activity的生命周期\"><a href=\"#异常情况下Activity的生命周期\" class=\"headerlink\" title=\"异常情况下Activity的生命周期\"></a>异常情况下Activity的生命周期</h3><ul>\n<li>资源相关的系统配置发生改变导致Activity被杀死并重新创建</li>\n</ul>\n<p>最常见的是横屏和竖屏相互切换,默认情况下Activity会销毁并重建,不过我们也可以阻止系统重新创建Activity</p>\n<ol>\n<li>系统会调用onSaveInstanceState来保存销毁前的数据(保存在bundle中)(保存的数据有当前的视图结构,用户输入的数据,View滑动的位置等,因为View也由这两个方法),然后在新建是调用onRestoreInstanceState来恢复数据</li>\n<li>onSaveInstanceState会在onStop之前调用,但是它不和onPause有联系,既可能在它之前也可能在之后,但是onRestoreInstanceState会在onStart后调用</li>\n</ol>\n<p>阻止系统重新创建Activity:修改系统的配置项,常见的配置项有三个</p>\n<ul>\n<li>locale:设备的本地位置发生了改变,一般是指切换了系统语言</li>\n<li>orientation:屏幕方向发生了改变</li>\n<li>keyboardHidden:键盘的访问性发生了改变,比如用户调出了键盘</li>\n<li>screenSize:屏幕尺寸发生了改变,当旋转屏幕时或者屏幕尺寸发生变化,只争对minSdhVersion和targetSdkVersion有一个高于13的情况</li>\n</ul>\n<p>在AndroidManifest.xml中设置Activity如下,代表我们制定了configChanges的属性,Activity就不会创建了,取而代之的值调用Activity中onConfigurationChanged方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=&quot;orientation|screenSize&quot;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>资源内存不足导致低优先级的Activity被杀死<br>优先级从高到底</li>\n</ul>\n<ol>\n<li>前台Activity – 正在和用户交互的Activity</li>\n<li>可见但不是前台Activity – 例如上面提到的透明的Activity,或者有弹窗在Activity之上</li>\n<li>后台Activity –已经被暂停的Activity,比如执行了onStop</li>\n</ol>\n<p>当内存不足时,系统会从优先级最低的开始销毁Activity,并保存他们的状态,然后等他们可见时再恢复他们的状态</p>\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h2 id=\"Activity启动模式\"><a href=\"#Activity启动模式\" class=\"headerlink\" title=\"Activity启动模式\"></a>Activity启动模式</h2><p>Activity采用后进先出的栈结构</p>\n<p>一共分为四种启动模式</p>\n<ol>\n<li>standard</li>\n</ol>\n<p>Activity的标准启动模式,不管该Activity是否存在实例,每次都会生成一个新的Activity(会经历onCreate-&gt;onStart-&gt;onResume),而且它存在的任务栈和启动的他的Activity是同一个<br> tips:采用ApplicationContext启动Activity会报错,因为ApplicationContext无法实例化成一个Activity,所以系统不知道将这个启动的Activity放入哪一个任务栈,导致报错</p>\n<ol start=\"2\">\n<li>singleTop</li>\n</ol>\n<p>栈顶复用模式,如果要启动的Activity位于栈顶,那么就不会重新创建该Activity,而是直接复用,并且会调用他的onNewIntent方法,但是如果该Activity实例不是在栈顶,那么还是会新建Activity实例并压入栈顶</p>\n<ol start=\"3\">\n<li><p>singleTask<br>栈内复用模式,是一种单实例模式的思想,如果要启动的Activity在栈内存在实例,那么就会直接使用这个实例,如果不存在,那么就会创建实例并压入栈内<br>tips: </p>\n<ul>\n<li>如果栈内存在直接调用的话,如果在栈顶,那么类似singleTop模式,如果不是栈顶,那么根据Activity后进先出的规则,位于该Activity之上的Activity将全部出栈被销毁(适用于返回首页操作)</li>\n<li>启动一个该模式的Activity,首先系统回去寻找是否存在A的任务栈,如果不存在,比如我在S1中存在该Activity实例,但是我想在S2中启动该Activity,那么系统就新建该Activity并压入S2任务栈;<br>如果存在,那么就直接使用,如果任务栈不存在,那么久直接新建并压入该栈</li>\n</ul>\n</li>\n<li><p>singleInstance<br>比singleTask更加极端的单实例模式,该模式启动的Activity会单独位于一个任务栈内,由于栈内复用的特性,那么之后重复调用该Activity都不会又新的实例出现,除非该任务栈被销毁了</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ea1402fa77e258cb7f4ab3d6e20896f0eb8edca7</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n"},{"title":"搭建自己的博客","date":"2018-08-16T23:09:10.000Z","_content":"# 搭建属于自己的博客\n\n想写博客很久了,想着记录自己打代码的点点滴滴也挺好的.但是一直由于懒,一直没开始,最近终于定下心来把博客弄好,我选的是基于nodejs的hexo,简单方便,而且高效\n\n安装nodejs\n\n```angular2html\nsudo apt-get update\n\nsudo apt-get install nodejs\n\nsudo apt-get install nodejs-legacy\n\n```\n\n国内的服务器(腾讯云)好像这样安装起来的版本很低用不了,换了种方式终于可以了\n\n下载最近新版的node源代码到目录,比如我是在/var/www/node/中\n\n```angular2html\nwget http://cdn.npm.taobao.org/dist/node/v8.9.0/node-v8.9.0-linux-x64.tar.xz\n```\n\n解压\n\n```angular2html\ntar xvJf node-v8.9.0-linux-x64.tar.xz(大写的J)\n```\n\n更改环境变量\n\n```angular2html\nsudo nano ~/.bashrc\n//然后再最后面加入下面代码（路径根据自己解压的路径自行修改）\nexport PATH=/var/www/node/node-v8.9.0-linux-x64/bin:$PATH\nsource ~/.bashrc\n```\n\n安装 npm模块\n\n```\nsudo apt-get install npm\n```\n\n安装 hexo\n\n```\n npm install -g hexo-cli\n\n```\n\n使用hexo\n\n```\n hexo init folder //如果在当前文件夹下 就直接 hexo init;\n npm install\n```\n\n运行 hexo\n\n```\nhexo s\n```\n\n然后访问4000端口\n\n\n![安装成功](http://image.honglingqi.cn/blogImages/hexo.png)\n\n\n连接自己的github\n\n设置用户名和邮箱\n```angular2html\ngit config --global user.name \"name\"\n\ngit config --global user.email \"email@gmail.com\"\n\n```\n\n进入文件夹创建密钥\n\n```angular2html\n\n cd ~/.ssh (如果没有就创建或者文件夹)\n\n ssh-keygen -t rsa -C \"email@gmail.com\"\n\n```\n\n确认名字和密码后,多出来id_rsa和id_rsa.pub两个文件,其中后者是公钥,将公钥添加到github上:登陆Github网站，选择 Settings –> SSH and GPG keys 菜单，点击 New SSH key 按钮。粘贴你的密钥到 Key 输入框中并设置 Title 信息，点击 Add SSH key 按钮完成。\n\n使用\n```\nssh -T git@github.com\n```\n进行测试,如果出现 'You've successfully authenticated, but GitHub does not provide shell access.'表示连接成功\n\n将博客部署到github\n\n首先创建一个在github上仓库,仓库的名字必须是name(github用户名).github.io,比如你叫tony,那么创建tony.github.io\n\n安装 插件\n\n```angular2html\nnpm install hexo-deployer-git --save\n```\n然后修改配置文件\n```angular2html\n\nnano _config.yml\n添加如:\n\n\ndeploy:\n  type: git\n  repo: git@github.com:(你github的名字)/okcpalyerduke.github.io.git\n  branch: master\n  (注意每个都要有空格,不然不能生效)\n```\n\n最后依次执行\n\n````\nhexo clean\nhexo g\nhexo d\n\n````\n\n\n然后就可以访问  https://(你github的名字).github.io/\n\n到此结束了\n\n\n\n今天七夕耶,买了几本Android的书给自己庆祝下,看不看随缘吧,希望明年可以和女朋友一起过","source":"_posts/搭建自己的博客.md","raw":"---\ntitle: 搭建自己的博客\ndate: 2018-08-17 07:09:10\ntags:\n- node \n---\n# 搭建属于自己的博客\n\n想写博客很久了,想着记录自己打代码的点点滴滴也挺好的.但是一直由于懒,一直没开始,最近终于定下心来把博客弄好,我选的是基于nodejs的hexo,简单方便,而且高效\n\n安装nodejs\n\n```angular2html\nsudo apt-get update\n\nsudo apt-get install nodejs\n\nsudo apt-get install nodejs-legacy\n\n```\n\n国内的服务器(腾讯云)好像这样安装起来的版本很低用不了,换了种方式终于可以了\n\n下载最近新版的node源代码到目录,比如我是在/var/www/node/中\n\n```angular2html\nwget http://cdn.npm.taobao.org/dist/node/v8.9.0/node-v8.9.0-linux-x64.tar.xz\n```\n\n解压\n\n```angular2html\ntar xvJf node-v8.9.0-linux-x64.tar.xz(大写的J)\n```\n\n更改环境变量\n\n```angular2html\nsudo nano ~/.bashrc\n//然后再最后面加入下面代码（路径根据自己解压的路径自行修改）\nexport PATH=/var/www/node/node-v8.9.0-linux-x64/bin:$PATH\nsource ~/.bashrc\n```\n\n安装 npm模块\n\n```\nsudo apt-get install npm\n```\n\n安装 hexo\n\n```\n npm install -g hexo-cli\n\n```\n\n使用hexo\n\n```\n hexo init folder //如果在当前文件夹下 就直接 hexo init;\n npm install\n```\n\n运行 hexo\n\n```\nhexo s\n```\n\n然后访问4000端口\n\n\n![安装成功](http://image.honglingqi.cn/blogImages/hexo.png)\n\n\n连接自己的github\n\n设置用户名和邮箱\n```angular2html\ngit config --global user.name \"name\"\n\ngit config --global user.email \"email@gmail.com\"\n\n```\n\n进入文件夹创建密钥\n\n```angular2html\n\n cd ~/.ssh (如果没有就创建或者文件夹)\n\n ssh-keygen -t rsa -C \"email@gmail.com\"\n\n```\n\n确认名字和密码后,多出来id_rsa和id_rsa.pub两个文件,其中后者是公钥,将公钥添加到github上:登陆Github网站，选择 Settings –> SSH and GPG keys 菜单，点击 New SSH key 按钮。粘贴你的密钥到 Key 输入框中并设置 Title 信息，点击 Add SSH key 按钮完成。\n\n使用\n```\nssh -T git@github.com\n```\n进行测试,如果出现 'You've successfully authenticated, but GitHub does not provide shell access.'表示连接成功\n\n将博客部署到github\n\n首先创建一个在github上仓库,仓库的名字必须是name(github用户名).github.io,比如你叫tony,那么创建tony.github.io\n\n安装 插件\n\n```angular2html\nnpm install hexo-deployer-git --save\n```\n然后修改配置文件\n```angular2html\n\nnano _config.yml\n添加如:\n\n\ndeploy:\n  type: git\n  repo: git@github.com:(你github的名字)/okcpalyerduke.github.io.git\n  branch: master\n  (注意每个都要有空格,不然不能生效)\n```\n\n最后依次执行\n\n````\nhexo clean\nhexo g\nhexo d\n\n````\n\n\n然后就可以访问  https://(你github的名字).github.io/\n\n到此结束了\n\n\n\n今天七夕耶,买了几本Android的书给自己庆祝下,看不看随缘吧,希望明年可以和女朋友一起过","slug":"搭建自己的博客","published":1,"updated":"2020-03-31T06:24:43.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9l001k9otsvuzeg433","content":"<h1 id=\"搭建属于自己的博客\"><a href=\"#搭建属于自己的博客\" class=\"headerlink\" title=\"搭建属于自己的博客\"></a>搭建属于自己的博客</h1><p>想写博客很久了,想着记录自己打代码的点点滴滴也挺好的.但是一直由于懒,一直没开始,最近终于定下心来把博客弄好,我选的是基于nodejs的hexo,简单方便,而且高效</p>\n<p>安装nodejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>\n<p>国内的服务器(腾讯云)好像这样安装起来的版本很低用不了,换了种方式终于可以了</p>\n<p>下载最近新版的node源代码到目录,比如我是在/var/www/node/中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cdn.npm.taobao.org/dist/node/v8.9.0/node-v8.9.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n<p>解压</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xvJf node-v8.9.0-linux-x64.tar.xz(大写的J)</span><br></pre></td></tr></table></figure>\n<p>更改环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano ~/.bashrc</span><br><span class=\"line\">//然后再最后面加入下面代码（路径根据自己解压的路径自行修改）</span><br><span class=\"line\">export PATH=/var/www/node/node-v8.9.0-linux-x64/bin:$PATH</span><br><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>安装 npm模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install npm</span><br></pre></td></tr></table></figure>\n<p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>使用hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init folder //如果在当前文件夹下 就直接 hexo init;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<p>运行 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>然后访问4000端口</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/hexo.png\" alt=\"安装成功\"></p>\n<p>连接自己的github</p>\n<p>设置用户名和邮箱<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;name&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.email &quot;email@gmail.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>进入文件夹创建密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">cd ~/.ssh (如果没有就创建或者文件夹)</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;email@gmail.com&quot;</span><br></pre></td></tr></table></figure>\n<p>确认名字和密码后,多出来id_rsa和id_rsa.pub两个文件,其中后者是公钥,将公钥添加到github上:登陆Github网站，选择 Settings –&gt; SSH and GPG keys 菜单，点击 New SSH key 按钮。粘贴你的密钥到 Key 输入框中并设置 Title 信息，点击 Add SSH key 按钮完成。</p>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>\n<p>进行测试,如果出现 ‘You’ve successfully authenticated, but GitHub does not provide shell access.’表示连接成功</p>\n<p>将博客部署到github</p>\n<p>首先创建一个在github上仓库,仓库的名字必须是name(github用户名).github.io,比如你叫tony,那么创建tony.github.io</p>\n<p>安装 插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>然后修改配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">nano _config.yml</span><br><span class=\"line\">添加如:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:(你github的名字)/okcpalyerduke.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  (注意每个都要有空格,不然不能生效)</span><br></pre></td></tr></table></figure></p>\n<p>最后依次执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>然后就可以访问  https://(你github的名字).github.io/</p>\n<p>到此结束了</p>\n<p>今天七夕耶,买了几本Android的书给自己庆祝下,看不看随缘吧,希望明年可以和女朋友一起过</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"搭建属于自己的博客\"><a href=\"#搭建属于自己的博客\" class=\"headerlink\" title=\"搭建属于自己的博客\"></a>搭建属于自己的博客</h1><p>想写博客很久了,想着记录自己打代码的点点滴滴也挺好的.但是一直由于懒,一直没开始,最近终于定下心来把博客弄好,我选的是基于nodejs的hexo,简单方便,而且高效</p>\n<p>安装nodejs</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>\n<p>国内的服务器(腾讯云)好像这样安装起来的版本很低用不了,换了种方式终于可以了</p>\n<p>下载最近新版的node源代码到目录,比如我是在/var/www/node/中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cdn.npm.taobao.org/dist/node/v8.9.0/node-v8.9.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n<p>解压</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xvJf node-v8.9.0-linux-x64.tar.xz(大写的J)</span><br></pre></td></tr></table></figure>\n<p>更改环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano ~/.bashrc</span><br><span class=\"line\">//然后再最后面加入下面代码（路径根据自己解压的路径自行修改）</span><br><span class=\"line\">export PATH=/var/www/node/node-v8.9.0-linux-x64/bin:$PATH</span><br><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>安装 npm模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install npm</span><br></pre></td></tr></table></figure>\n<p>安装 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>使用hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init folder //如果在当前文件夹下 就直接 hexo init;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<p>运行 hexo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>然后访问4000端口</p>\n<p><img src=\"http://image.honglingqi.cn/blogImages/hexo.png\" alt=\"安装成功\"></p>\n<p>连接自己的github</p>\n<p>设置用户名和邮箱<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;name&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.email &quot;email@gmail.com&quot;</span><br></pre></td></tr></table></figure></p>\n<p>进入文件夹创建密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">cd ~/.ssh (如果没有就创建或者文件夹)</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;email@gmail.com&quot;</span><br></pre></td></tr></table></figure>\n<p>确认名字和密码后,多出来id_rsa和id_rsa.pub两个文件,其中后者是公钥,将公钥添加到github上:登陆Github网站，选择 Settings –&gt; SSH and GPG keys 菜单，点击 New SSH key 按钮。粘贴你的密钥到 Key 输入框中并设置 Title 信息，点击 Add SSH key 按钮完成。</p>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>\n<p>进行测试,如果出现 ‘You’ve successfully authenticated, but GitHub does not provide shell access.’表示连接成功</p>\n<p>将博客部署到github</p>\n<p>首先创建一个在github上仓库,仓库的名字必须是name(github用户名).github.io,比如你叫tony,那么创建tony.github.io</p>\n<p>安装 插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>然后修改配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">nano _config.yml</span><br><span class=\"line\">添加如:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:(你github的名字)/okcpalyerduke.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  (注意每个都要有空格,不然不能生效)</span><br></pre></td></tr></table></figure></p>\n<p>最后依次执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>然后就可以访问  https://(你github的名字).github.io/</p>\n<p>到此结束了</p>\n<p>今天七夕耶,买了几本Android的书给自己庆祝下,看不看随缘吧,希望明年可以和女朋友一起过</p>\n"},{"title":"注意事项","date":"2019-04-30T06:50:39.000Z","_content":"* 权限申请时,权限必须要在AndroidManifest.xml中申明,否则会报错\n* FragmentTransaction配合Fragment使用时,hide()和show()方法切换Fragment时不会调用onPause()和onResume()方法,\n这两个方法是跟着Activity的onPause()和onResume()方法一起执行的.调用Fragment中onHiddenChanged(boolean hidden)来判断Fragment是否显示\n\n\n\n新建项目的时候targetSdhVersion指定为了28,然后在自己Android6.0上测试一直没有问题,但是用同事的小米8,Android版本为8.0的时候,却发现无论如何连接不上网络,一开始我以为是出bug了,但是重新安装过,还是会出现同样的同样的问题,也无关后台是否重启了项目,然后硬着头皮在error里面找错开始Google,然后发现了一片新天地:\n\n* 关于无法访问网络:\n\n我用的是okhttp请求网络,打印了下面的错误:\n```\njava.net.UnknownServiceException: CLEARTEXT communication to (ip地址) not permitted by network security policy\n```\n\n\nAndroid8.0开始,APP限制了http请求,推荐更加安全的https,所以不采取伊谢措施,你使用http的是无论如何都不能访问不了接口的\n解决方法:\n1.叫后端同学升级,改成https(但是不太现实,https证书啥的超级贵,增加成本)\n2.将targetSdkVersion降低到28一下(简单方便,但是不符合开发者规范)\n3.在res文件夹下新建xml文件,然后新建network_security_config.xml文件,写入一下配置:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\" />\n</network-security-config>\n```\n然后在AndroidManifest.xml中的application标签中加入\n```\nandroid:networkSecurityConfig=\"@xml/network_security_config\"\n```\n然后就可以愉快的访问了\n\n\ntargetSdhVersion为29时\n\n\n\n\n//\ncom.android.internal.policy.DecorContext cannot be cast to Activity\n\n\n7.0以上报错 :\n\n\npublic static Activity getActivity(View view) {\n    Activity activity = null;\n    if (view.getContext().getClass().getName().contains(\"com.android.internal.policy.DecorContext\")) {\n        try {\n            Field field = view.getContext().getClass().getDeclaredField(\"mPhoneWindow\");\n            field.setAccessible(true);\n            Object obj = field.get(view.getContext());\n            java.lang.reflect.Method m1 = obj.getClass().getMethod(\"getContext\");\n            activity = (Activity) (m1.invoke(obj));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } else {\n        activity = (Activity) view.getContext();\n    }\n    return activity;\n}","source":"_posts/注意事项.md","raw":"---\ntitle: 注意事项\ndate: 2019-04-30 14:50:39\ntags:\n---\n* 权限申请时,权限必须要在AndroidManifest.xml中申明,否则会报错\n* FragmentTransaction配合Fragment使用时,hide()和show()方法切换Fragment时不会调用onPause()和onResume()方法,\n这两个方法是跟着Activity的onPause()和onResume()方法一起执行的.调用Fragment中onHiddenChanged(boolean hidden)来判断Fragment是否显示\n\n\n\n新建项目的时候targetSdhVersion指定为了28,然后在自己Android6.0上测试一直没有问题,但是用同事的小米8,Android版本为8.0的时候,却发现无论如何连接不上网络,一开始我以为是出bug了,但是重新安装过,还是会出现同样的同样的问题,也无关后台是否重启了项目,然后硬着头皮在error里面找错开始Google,然后发现了一片新天地:\n\n* 关于无法访问网络:\n\n我用的是okhttp请求网络,打印了下面的错误:\n```\njava.net.UnknownServiceException: CLEARTEXT communication to (ip地址) not permitted by network security policy\n```\n\n\nAndroid8.0开始,APP限制了http请求,推荐更加安全的https,所以不采取伊谢措施,你使用http的是无论如何都不能访问不了接口的\n解决方法:\n1.叫后端同学升级,改成https(但是不太现实,https证书啥的超级贵,增加成本)\n2.将targetSdkVersion降低到28一下(简单方便,但是不符合开发者规范)\n3.在res文件夹下新建xml文件,然后新建network_security_config.xml文件,写入一下配置:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\" />\n</network-security-config>\n```\n然后在AndroidManifest.xml中的application标签中加入\n```\nandroid:networkSecurityConfig=\"@xml/network_security_config\"\n```\n然后就可以愉快的访问了\n\n\ntargetSdhVersion为29时\n\n\n\n\n//\ncom.android.internal.policy.DecorContext cannot be cast to Activity\n\n\n7.0以上报错 :\n\n\npublic static Activity getActivity(View view) {\n    Activity activity = null;\n    if (view.getContext().getClass().getName().contains(\"com.android.internal.policy.DecorContext\")) {\n        try {\n            Field field = view.getContext().getClass().getDeclaredField(\"mPhoneWindow\");\n            field.setAccessible(true);\n            Object obj = field.get(view.getContext());\n            java.lang.reflect.Method m1 = obj.getClass().getMethod(\"getContext\");\n            activity = (Activity) (m1.invoke(obj));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    } else {\n        activity = (Activity) view.getContext();\n    }\n    return activity;\n}","slug":"注意事项","published":1,"updated":"2020-03-31T05:41:12.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9t001l9ots59s2uosj","content":"<ul>\n<li>权限申请时,权限必须要在AndroidManifest.xml中申明,否则会报错</li>\n<li>FragmentTransaction配合Fragment使用时,hide()和show()方法切换Fragment时不会调用onPause()和onResume()方法,<br>这两个方法是跟着Activity的onPause()和onResume()方法一起执行的.调用Fragment中onHiddenChanged(boolean hidden)来判断Fragment是否显示</li>\n</ul>\n<p>新建项目的时候targetSdhVersion指定为了28,然后在自己Android6.0上测试一直没有问题,但是用同事的小米8,Android版本为8.0的时候,却发现无论如何连接不上网络,一开始我以为是出bug了,但是重新安装过,还是会出现同样的同样的问题,也无关后台是否重启了项目,然后硬着头皮在error里面找错开始Google,然后发现了一片新天地:</p>\n<ul>\n<li>关于无法访问网络:</li>\n</ul>\n<p>我用的是okhttp请求网络,打印了下面的错误:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.UnknownServiceException: CLEARTEXT communication to (ip地址) not permitted by network security policy</span><br></pre></td></tr></table></figure></p>\n<p>Android8.0开始,APP限制了http请求,推荐更加安全的https,所以不采取伊谢措施,你使用http的是无论如何都不能访问不了接口的<br>解决方法:<br>1.叫后端同学升级,改成https(但是不太现实,https证书啥的超级贵,增加成本)<br>2.将targetSdkVersion降低到28一下(简单方便,但是不符合开发者规范)<br>3.在res文件夹下新建xml文件,然后新建network_security_config.xml文件,写入一下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;network-security-config&gt;</span><br><span class=\"line\">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;</span><br><span class=\"line\">&lt;/network-security-config&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在AndroidManifest.xml中的application标签中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:networkSecurityConfig=&quot;@xml/network_security_config&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以愉快的访问了</p>\n<p>targetSdhVersion为29时</p>\n<p>//<br>com.android.internal.policy.DecorContext cannot be cast to Activity</p>\n<p>7.0以上报错 :</p>\n<p>public static Activity getActivity(View view) {<br>    Activity activity = null;<br>    if (view.getContext().getClass().getName().contains(“com.android.internal.policy.DecorContext”)) {<br>        try {<br>            Field field = view.getContext().getClass().getDeclaredField(“mPhoneWindow”);<br>            field.setAccessible(true);<br>            Object obj = field.get(view.getContext());<br>            java.lang.reflect.Method m1 = obj.getClass().getMethod(“getContext”);<br>            activity = (Activity) (m1.invoke(obj));</p>\n<pre><code>    } catch (Exception e) {\n        e.printStackTrace();\n    }\n} else {\n    activity = (Activity) view.getContext();\n}\nreturn activity;\n</code></pre><p>}</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>权限申请时,权限必须要在AndroidManifest.xml中申明,否则会报错</li>\n<li>FragmentTransaction配合Fragment使用时,hide()和show()方法切换Fragment时不会调用onPause()和onResume()方法,<br>这两个方法是跟着Activity的onPause()和onResume()方法一起执行的.调用Fragment中onHiddenChanged(boolean hidden)来判断Fragment是否显示</li>\n</ul>\n<p>新建项目的时候targetSdhVersion指定为了28,然后在自己Android6.0上测试一直没有问题,但是用同事的小米8,Android版本为8.0的时候,却发现无论如何连接不上网络,一开始我以为是出bug了,但是重新安装过,还是会出现同样的同样的问题,也无关后台是否重启了项目,然后硬着头皮在error里面找错开始Google,然后发现了一片新天地:</p>\n<ul>\n<li>关于无法访问网络:</li>\n</ul>\n<p>我用的是okhttp请求网络,打印了下面的错误:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.UnknownServiceException: CLEARTEXT communication to (ip地址) not permitted by network security policy</span><br></pre></td></tr></table></figure></p>\n<p>Android8.0开始,APP限制了http请求,推荐更加安全的https,所以不采取伊谢措施,你使用http的是无论如何都不能访问不了接口的<br>解决方法:<br>1.叫后端同学升级,改成https(但是不太现实,https证书啥的超级贵,增加成本)<br>2.将targetSdkVersion降低到28一下(简单方便,但是不符合开发者规范)<br>3.在res文件夹下新建xml文件,然后新建network_security_config.xml文件,写入一下配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;network-security-config&gt;</span><br><span class=\"line\">    &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;</span><br><span class=\"line\">&lt;/network-security-config&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在AndroidManifest.xml中的application标签中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:networkSecurityConfig=&quot;@xml/network_security_config&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后就可以愉快的访问了</p>\n<p>targetSdhVersion为29时</p>\n<p>//<br>com.android.internal.policy.DecorContext cannot be cast to Activity</p>\n<p>7.0以上报错 :</p>\n<p>public static Activity getActivity(View view) {<br>    Activity activity = null;<br>    if (view.getContext().getClass().getName().contains(“com.android.internal.policy.DecorContext”)) {<br>        try {<br>            Field field = view.getContext().getClass().getDeclaredField(“mPhoneWindow”);<br>            field.setAccessible(true);<br>            Object obj = field.get(view.getContext());<br>            java.lang.reflect.Method m1 = obj.getClass().getMethod(“getContext”);<br>            activity = (Activity) (m1.invoke(obj));</p>\n<pre><code>    } catch (Exception e) {\n        e.printStackTrace();\n    }\n} else {\n    activity = (Activity) view.getContext();\n}\nreturn activity;\n</code></pre><p>}</p>\n"},{"title":"生活趣事","date":"2018-12-03T05:58:01.000Z","_content":"\n回了一趟家,觉得天天越来越可爱了\n\n* 去喝了亲戚的喜酒,拿回来一些好吃的,妈妈让天天把里面的牛肉干分给哥哥一点,\n\n天天:\"不能的!\"\n\n妈妈很诧异,以为天天太小气了,居然连哥哥都不愿意分享\n\n天天:\"是四个人一起分享的!\"\n\n* 走路的时候天天不好好走,到处蹦跶,妈妈拉着他的帽子跟说你要好好走路\n天天:\"你这样子是不对的,不能拉着我们帽子走路的\"(假装生气,哼的一生),\"你要向我道歉!\"\n妈妈拗不过他,跟他说了对不起\n天天:\"没关系,我原谅你了\",然后拉着妈妈的手继续走路\n\n* 回来之后发现书包侧面的袋子里有一个果冻,我寻思着可能是天天在分果冻的时候,自言自语的说:\"这一个给哥哥\",然后塞进我的书包里了吧\n\n* 妈妈也很可爱,叫我回家喝喜酒然后办社保卡,第一次用爸爸的手机给我打电话,第二次叫爸爸给我电话,我打回去的时候打开通话记录,爸爸的通话纪录在前面我就顺手打爸爸的电话了,打了两三个吧,回去之后妈妈就说:\"你怎么给爸爸打电话不给我打电话了\"\n\n* 天天的占有欲总是特别强,每次爸爸问天天:\"妈妈有几个儿子啊\"的时候,天天总是\"嘿嘿,嘿嘿\"的笑,那天回来一家人在一起吃早饭,爸爸又问天天,天天还是老样子,爸爸就说:\"妈妈有个三孩子,我们三个都是妈妈的孩子\",全家人都笑了(妈妈好多次埋怨爸爸总说爸爸这不好那不好,然后就说我要么有三个儿子,个个都不让我省心)\n\n\n其实很喜欢用文字纪录一些东西,我觉得那才是可能保存下来的东西,但是无奈字太丑,表述太差,还是码字吧\n","source":"_posts/生活趣事.md","raw":"---\ntitle: 生活趣事\ndate: 2018-12-03 13:58:01\ntags:\n- 生活\n---\n\n回了一趟家,觉得天天越来越可爱了\n\n* 去喝了亲戚的喜酒,拿回来一些好吃的,妈妈让天天把里面的牛肉干分给哥哥一点,\n\n天天:\"不能的!\"\n\n妈妈很诧异,以为天天太小气了,居然连哥哥都不愿意分享\n\n天天:\"是四个人一起分享的!\"\n\n* 走路的时候天天不好好走,到处蹦跶,妈妈拉着他的帽子跟说你要好好走路\n天天:\"你这样子是不对的,不能拉着我们帽子走路的\"(假装生气,哼的一生),\"你要向我道歉!\"\n妈妈拗不过他,跟他说了对不起\n天天:\"没关系,我原谅你了\",然后拉着妈妈的手继续走路\n\n* 回来之后发现书包侧面的袋子里有一个果冻,我寻思着可能是天天在分果冻的时候,自言自语的说:\"这一个给哥哥\",然后塞进我的书包里了吧\n\n* 妈妈也很可爱,叫我回家喝喜酒然后办社保卡,第一次用爸爸的手机给我打电话,第二次叫爸爸给我电话,我打回去的时候打开通话记录,爸爸的通话纪录在前面我就顺手打爸爸的电话了,打了两三个吧,回去之后妈妈就说:\"你怎么给爸爸打电话不给我打电话了\"\n\n* 天天的占有欲总是特别强,每次爸爸问天天:\"妈妈有几个儿子啊\"的时候,天天总是\"嘿嘿,嘿嘿\"的笑,那天回来一家人在一起吃早饭,爸爸又问天天,天天还是老样子,爸爸就说:\"妈妈有个三孩子,我们三个都是妈妈的孩子\",全家人都笑了(妈妈好多次埋怨爸爸总说爸爸这不好那不好,然后就说我要么有三个儿子,个个都不让我省心)\n\n\n其实很喜欢用文字纪录一些东西,我觉得那才是可能保存下来的东西,但是无奈字太丑,表述太差,还是码字吧\n","slug":"生活趣事","published":1,"updated":"2020-03-31T05:41:12.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkje9y001n9otsp3ot5nof","content":"<p>回了一趟家,觉得天天越来越可爱了</p>\n<ul>\n<li>去喝了亲戚的喜酒,拿回来一些好吃的,妈妈让天天把里面的牛肉干分给哥哥一点,</li>\n</ul>\n<p>天天:”不能的!”</p>\n<p>妈妈很诧异,以为天天太小气了,居然连哥哥都不愿意分享</p>\n<p>天天:”是四个人一起分享的!”</p>\n<ul>\n<li><p>走路的时候天天不好好走,到处蹦跶,妈妈拉着他的帽子跟说你要好好走路<br>天天:”你这样子是不对的,不能拉着我们帽子走路的”(假装生气,哼的一生),”你要向我道歉!”<br>妈妈拗不过他,跟他说了对不起<br>天天:”没关系,我原谅你了”,然后拉着妈妈的手继续走路</p>\n</li>\n<li><p>回来之后发现书包侧面的袋子里有一个果冻,我寻思着可能是天天在分果冻的时候,自言自语的说:”这一个给哥哥”,然后塞进我的书包里了吧</p>\n</li>\n<li><p>妈妈也很可爱,叫我回家喝喜酒然后办社保卡,第一次用爸爸的手机给我打电话,第二次叫爸爸给我电话,我打回去的时候打开通话记录,爸爸的通话纪录在前面我就顺手打爸爸的电话了,打了两三个吧,回去之后妈妈就说:”你怎么给爸爸打电话不给我打电话了”</p>\n</li>\n<li><p>天天的占有欲总是特别强,每次爸爸问天天:”妈妈有几个儿子啊”的时候,天天总是”嘿嘿,嘿嘿”的笑,那天回来一家人在一起吃早饭,爸爸又问天天,天天还是老样子,爸爸就说:”妈妈有个三孩子,我们三个都是妈妈的孩子”,全家人都笑了(妈妈好多次埋怨爸爸总说爸爸这不好那不好,然后就说我要么有三个儿子,个个都不让我省心)</p>\n</li>\n</ul>\n<p>其实很喜欢用文字纪录一些东西,我觉得那才是可能保存下来的东西,但是无奈字太丑,表述太差,还是码字吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>回了一趟家,觉得天天越来越可爱了</p>\n<ul>\n<li>去喝了亲戚的喜酒,拿回来一些好吃的,妈妈让天天把里面的牛肉干分给哥哥一点,</li>\n</ul>\n<p>天天:”不能的!”</p>\n<p>妈妈很诧异,以为天天太小气了,居然连哥哥都不愿意分享</p>\n<p>天天:”是四个人一起分享的!”</p>\n<ul>\n<li><p>走路的时候天天不好好走,到处蹦跶,妈妈拉着他的帽子跟说你要好好走路<br>天天:”你这样子是不对的,不能拉着我们帽子走路的”(假装生气,哼的一生),”你要向我道歉!”<br>妈妈拗不过他,跟他说了对不起<br>天天:”没关系,我原谅你了”,然后拉着妈妈的手继续走路</p>\n</li>\n<li><p>回来之后发现书包侧面的袋子里有一个果冻,我寻思着可能是天天在分果冻的时候,自言自语的说:”这一个给哥哥”,然后塞进我的书包里了吧</p>\n</li>\n<li><p>妈妈也很可爱,叫我回家喝喜酒然后办社保卡,第一次用爸爸的手机给我打电话,第二次叫爸爸给我电话,我打回去的时候打开通话记录,爸爸的通话纪录在前面我就顺手打爸爸的电话了,打了两三个吧,回去之后妈妈就说:”你怎么给爸爸打电话不给我打电话了”</p>\n</li>\n<li><p>天天的占有欲总是特别强,每次爸爸问天天:”妈妈有几个儿子啊”的时候,天天总是”嘿嘿,嘿嘿”的笑,那天回来一家人在一起吃早饭,爸爸又问天天,天天还是老样子,爸爸就说:”妈妈有个三孩子,我们三个都是妈妈的孩子”,全家人都笑了(妈妈好多次埋怨爸爸总说爸爸这不好那不好,然后就说我要么有三个儿子,个个都不让我省心)</p>\n</li>\n</ul>\n<p>其实很喜欢用文字纪录一些东西,我觉得那才是可能保存下来的东西,但是无奈字太丑,表述太差,还是码字吧</p>\n"},{"_content":"大多数APP中输入框(EditText)都是有一个删除全部的按钮让用户可以直接一次性删除所输入的内容，但是原生的控件\n并不支持，第三方的也很多，但是还是要自己写一遍来加深印象，顺便复习下自定义View的使用\n\n\n### 1.定义\n\n```\n\n    public EditClearText(Context context) {\n        this(context,null);\n    }\n\n    public EditClearText(Context context, AttributeSet attrs) {\n        this(context, attrs,android.R.attr.editTextStyle);\n    }\n\n    public EditClearText(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    \n    }\n\n```\n需要注意的是在第二个方法中如果是使用this的话，第三个参数需要传android.R.attr.editTextStyle，否则不能\n被系统判定为是一个输入框（点击不能弹起键盘，没有背景）\n\n\n### 2.画图\n\n#### 测量\n\n```\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        if(!isMeasure){\n\n            int paddingRight=getPaddingRight();\n\n            size= (int) ((getMeasuredHeight()-getPaddingTop()-getPaddingBottom())*0.75);\n\n            int flag=DisplayUtil.dp2Px(3);\n\n            setPadding(getPaddingLeft(),getTop(),getPaddingRight()+size+flag,getBottom());\n\n            drawableLeft = getMeasuredWidth() - paddingRight - size;\n\n            drawablePadding = (getMeasuredHeight() - size) / 2;\n\n            isMeasure=true;\n\n        }\n\n    }\n\n\n```\n\n1. drawable的大小是取了高度的3/4\n2. 重新设置paddingRight是为了在输入文字的时候不会重叠\n3. isMeasure的作用是防止重复设置paddingRight\n\n#### 绘制\n\n```\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n     if(!getText().toString().equals(\"\")){\n        canvas.save();\n        /*\n         * 需要注意的是当文字内容有多行是，View的高度不变，但是会增加scrollY,所以绘制删除键位置时，需要考虑scrollY的值\n         */\n        int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);\n        canvas.translate(drawableLeft,drawableTop);\n\n        drawable.setBounds(0,0, size,size);\n\n        drawable.draw(canvas);\n\n        canvas.restore();\n\n        super.onDraw(canvas);\n     }\n\n    }\n\n```\n\n\n直接使用drawable.draw(canvas)会比转成bitmap画上去方便 需要注意的是canvas.save(),canvas.restore()\n因为canvas的坐标系被移动了\n\n特别注意\n\n```\n int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);\n```\n因为在文字的多行的时候，虽然View的高度不会改变，但是scrollY会变化，如果只是按照高度绘制在中间的话，会导致图片往上移动\n\n### 事件\n\n```\n   public boolean onTouchEvent(MotionEvent event) {\n\n        if(event.getAction()==MotionEvent.ACTION_UP){\n\n            if(event.getX()>=drawableLeft && event.getX()<=(drawableLeft+size)&&\n                event.getY()>=drawablePadding && event.getY()<=(drawablePadding+size)){\n\n                setText(\"\");\n                return true;\n\n            }\n        }\n\n\n        return super.onTouchEvent(event);\n    }\n```\n\n判断手指抬起时是否在drawable上，如果是，那么就清除文字\n\n\n\n\n\n\n\n\n","source":"_posts/自定义EditText.md","raw":"大多数APP中输入框(EditText)都是有一个删除全部的按钮让用户可以直接一次性删除所输入的内容，但是原生的控件\n并不支持，第三方的也很多，但是还是要自己写一遍来加深印象，顺便复习下自定义View的使用\n\n\n### 1.定义\n\n```\n\n    public EditClearText(Context context) {\n        this(context,null);\n    }\n\n    public EditClearText(Context context, AttributeSet attrs) {\n        this(context, attrs,android.R.attr.editTextStyle);\n    }\n\n    public EditClearText(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    \n    }\n\n```\n需要注意的是在第二个方法中如果是使用this的话，第三个参数需要传android.R.attr.editTextStyle，否则不能\n被系统判定为是一个输入框（点击不能弹起键盘，没有背景）\n\n\n### 2.画图\n\n#### 测量\n\n```\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        if(!isMeasure){\n\n            int paddingRight=getPaddingRight();\n\n            size= (int) ((getMeasuredHeight()-getPaddingTop()-getPaddingBottom())*0.75);\n\n            int flag=DisplayUtil.dp2Px(3);\n\n            setPadding(getPaddingLeft(),getTop(),getPaddingRight()+size+flag,getBottom());\n\n            drawableLeft = getMeasuredWidth() - paddingRight - size;\n\n            drawablePadding = (getMeasuredHeight() - size) / 2;\n\n            isMeasure=true;\n\n        }\n\n    }\n\n\n```\n\n1. drawable的大小是取了高度的3/4\n2. 重新设置paddingRight是为了在输入文字的时候不会重叠\n3. isMeasure的作用是防止重复设置paddingRight\n\n#### 绘制\n\n```\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n     if(!getText().toString().equals(\"\")){\n        canvas.save();\n        /*\n         * 需要注意的是当文字内容有多行是，View的高度不变，但是会增加scrollY,所以绘制删除键位置时，需要考虑scrollY的值\n         */\n        int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);\n        canvas.translate(drawableLeft,drawableTop);\n\n        drawable.setBounds(0,0, size,size);\n\n        drawable.draw(canvas);\n\n        canvas.restore();\n\n        super.onDraw(canvas);\n     }\n\n    }\n\n```\n\n\n直接使用drawable.draw(canvas)会比转成bitmap画上去方便 需要注意的是canvas.save(),canvas.restore()\n因为canvas的坐标系被移动了\n\n特别注意\n\n```\n int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);\n```\n因为在文字的多行的时候，虽然View的高度不会改变，但是scrollY会变化，如果只是按照高度绘制在中间的话，会导致图片往上移动\n\n### 事件\n\n```\n   public boolean onTouchEvent(MotionEvent event) {\n\n        if(event.getAction()==MotionEvent.ACTION_UP){\n\n            if(event.getX()>=drawableLeft && event.getX()<=(drawableLeft+size)&&\n                event.getY()>=drawablePadding && event.getY()<=(drawablePadding+size)){\n\n                setText(\"\");\n                return true;\n\n            }\n        }\n\n\n        return super.onTouchEvent(event);\n    }\n```\n\n判断手指抬起时是否在drawable上，如果是，那么就清除文字\n\n\n\n\n\n\n\n\n","slug":"自定义EditText","published":1,"date":"2020-03-31T05:53:34.598Z","updated":"2020-03-31T07:06:43.792Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8fkjea3001o9ots1iucjzk9","content":"<p>大多数APP中输入框(EditText)都是有一个删除全部的按钮让用户可以直接一次性删除所输入的内容，但是原生的控件<br>并不支持，第三方的也很多，但是还是要自己写一遍来加深印象，顺便复习下自定义View的使用</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context) &#123;</span><br><span class=\"line\">    this(context,null);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">    this(context, attrs,android.R.attr.editTextStyle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">    super(context, attrs, defStyleAttr);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是在第二个方法中如果是使用this的话，第三个参数需要传android.R.attr.editTextStyle，否则不能<br>被系统判定为是一个输入框（点击不能弹起键盘，没有背景）</p>\n<h3 id=\"2-画图\"><a href=\"#2-画图\" class=\"headerlink\" title=\"2.画图\"></a>2.画图</h3><h4 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!isMeasure)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int paddingRight=getPaddingRight();</span><br><span class=\"line\"></span><br><span class=\"line\">        size= (int) ((getMeasuredHeight()-getPaddingTop()-getPaddingBottom())*0.75);</span><br><span class=\"line\"></span><br><span class=\"line\">        int flag=DisplayUtil.dp2Px(3);</span><br><span class=\"line\"></span><br><span class=\"line\">        setPadding(getPaddingLeft(),getTop(),getPaddingRight()+size+flag,getBottom());</span><br><span class=\"line\"></span><br><span class=\"line\">        drawableLeft = getMeasuredWidth() - paddingRight - size;</span><br><span class=\"line\"></span><br><span class=\"line\">        drawablePadding = (getMeasuredHeight() - size) / 2;</span><br><span class=\"line\"></span><br><span class=\"line\">        isMeasure=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>drawable的大小是取了高度的3/4</li>\n<li>重新设置paddingRight是为了在输入文字的时候不会重叠</li>\n<li>isMeasure的作用是防止重复设置paddingRight</li>\n</ol>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(!getText().toString().equals(&quot;&quot;))&#123;</span><br><span class=\"line\">    canvas.save();</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * 需要注意的是当文字内容有多行是，View的高度不变，但是会增加scrollY,所以绘制删除键位置时，需要考虑scrollY的值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);</span><br><span class=\"line\">    canvas.translate(drawableLeft,drawableTop);</span><br><span class=\"line\"></span><br><span class=\"line\">    drawable.setBounds(0,0, size,size);</span><br><span class=\"line\"></span><br><span class=\"line\">    drawable.draw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">    canvas.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">    super.onDraw(canvas);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接使用drawable.draw(canvas)会比转成bitmap画上去方便 需要注意的是canvas.save(),canvas.restore()<br>因为canvas的坐标系被移动了</p>\n<p>特别注意</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);</span><br></pre></td></tr></table></figure>\n<p>因为在文字的多行的时候，虽然View的高度不会改变，但是scrollY会变化，如果只是按照高度绘制在中间的话，会导致图片往上移动</p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     if(event.getAction()==MotionEvent.ACTION_UP)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         if(event.getX()&gt;=drawableLeft &amp;&amp; event.getX()&lt;=(drawableLeft+size)&amp;&amp;</span><br><span class=\"line\">             event.getY()&gt;=drawablePadding &amp;&amp; event.getY()&lt;=(drawablePadding+size))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">             setText(&quot;&quot;);</span><br><span class=\"line\">             return true;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     return super.onTouchEvent(event);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>判断手指抬起时是否在drawable上，如果是，那么就清除文字</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大多数APP中输入框(EditText)都是有一个删除全部的按钮让用户可以直接一次性删除所输入的内容，但是原生的控件<br>并不支持，第三方的也很多，但是还是要自己写一遍来加深印象，顺便复习下自定义View的使用</p>\n<h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1.定义\"></a>1.定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context) &#123;</span><br><span class=\"line\">    this(context,null);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">    this(context, attrs,android.R.attr.editTextStyle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public EditClearText(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">    super(context, attrs, defStyleAttr);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是在第二个方法中如果是使用this的话，第三个参数需要传android.R.attr.editTextStyle，否则不能<br>被系统判定为是一个输入框（点击不能弹起键盘，没有背景）</p>\n<h3 id=\"2-画图\"><a href=\"#2-画图\" class=\"headerlink\" title=\"2.画图\"></a>2.画图</h3><h4 id=\"测量\"><a href=\"#测量\" class=\"headerlink\" title=\"测量\"></a>测量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(!isMeasure)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int paddingRight=getPaddingRight();</span><br><span class=\"line\"></span><br><span class=\"line\">        size= (int) ((getMeasuredHeight()-getPaddingTop()-getPaddingBottom())*0.75);</span><br><span class=\"line\"></span><br><span class=\"line\">        int flag=DisplayUtil.dp2Px(3);</span><br><span class=\"line\"></span><br><span class=\"line\">        setPadding(getPaddingLeft(),getTop(),getPaddingRight()+size+flag,getBottom());</span><br><span class=\"line\"></span><br><span class=\"line\">        drawableLeft = getMeasuredWidth() - paddingRight - size;</span><br><span class=\"line\"></span><br><span class=\"line\">        drawablePadding = (getMeasuredHeight() - size) / 2;</span><br><span class=\"line\"></span><br><span class=\"line\">        isMeasure=true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>drawable的大小是取了高度的3/4</li>\n<li>重新设置paddingRight是为了在输入文字的时候不会重叠</li>\n<li>isMeasure的作用是防止重复设置paddingRight</li>\n</ol>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(!getText().toString().equals(&quot;&quot;))&#123;</span><br><span class=\"line\">    canvas.save();</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     * 需要注意的是当文字内容有多行是，View的高度不变，但是会增加scrollY,所以绘制删除键位置时，需要考虑scrollY的值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);</span><br><span class=\"line\">    canvas.translate(drawableLeft,drawableTop);</span><br><span class=\"line\"></span><br><span class=\"line\">    drawable.setBounds(0,0, size,size);</span><br><span class=\"line\"></span><br><span class=\"line\">    drawable.draw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">    canvas.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">    super.onDraw(canvas);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接使用drawable.draw(canvas)会比转成bitmap画上去方便 需要注意的是canvas.save(),canvas.restore()<br>因为canvas的坐标系被移动了</p>\n<p>特别注意</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int drawableTop = (getMeasuredHeight() +getScrollY()- drawablePadding-size);</span><br></pre></td></tr></table></figure>\n<p>因为在文字的多行的时候，虽然View的高度不会改变，但是scrollY会变化，如果只是按照高度绘制在中间的话，会导致图片往上移动</p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     if(event.getAction()==MotionEvent.ACTION_UP)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         if(event.getX()&gt;=drawableLeft &amp;&amp; event.getX()&lt;=(drawableLeft+size)&amp;&amp;</span><br><span class=\"line\">             event.getY()&gt;=drawablePadding &amp;&amp; event.getY()&lt;=(drawablePadding+size))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">             setText(&quot;&quot;);</span><br><span class=\"line\">             return true;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">     return super.onTouchEvent(event);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>判断手指抬起时是否在drawable上，如果是，那么就清除文字</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck8fkje6l00049otswda27hcf","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje6r00079ots9r8tzmnv"},{"post_id":"ck8fkje6400009ots1v2qb46j","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje6u00099otsan7d0kg3"},{"post_id":"ck8fkje6n00059ots0yo11mwe","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje6x000c9otstc67hyhn"},{"post_id":"ck8fkje6s00089otszv6mcrho","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje70000e9ots4rtplbpq"},{"post_id":"ck8fkje6d00019otsul171dw8","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje78000h9otsstixhjf2"},{"post_id":"ck8fkje6j00039otswkk7hwbn","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje7a000j9otsambfh160"},{"post_id":"ck8fkje78000i9otswndvjj3z","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje7e000m9otsf32ei1mc"},{"post_id":"ck8fkje6v000a9otswfwb4kib","tag_id":"ck8fkje77000g9otslilt70dp","_id":"ck8fkje7e000n9otst6n33rxg"},{"post_id":"ck8fkje7b000k9ots7a0p9r1n","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje7f000o9ots7jdc2qx3"},{"post_id":"ck8fkje72000f9otsdz2hiwoz","tag_id":"ck8fkje7d000l9otsp0iddg4p","_id":"ck8fkje7g000p9ots7rke9w32"},{"post_id":"ck8fkje8f000q9otswkdqaqbk","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje8t000u9otspccrvl1s"},{"post_id":"ck8fkje8m000s9otschkryha4","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje8x000x9otszmifo2an"},{"post_id":"ck8fkje8x000y9ots6olk675v","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje9200139otsbaw7nw8a"},{"post_id":"ck8fkje9200149ots7x63mrsq","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje9600179otsnfatig8w"},{"post_id":"ck8fkje8t000v9otsnr5qhprh","tag_id":"ck8fkje8z00109ots9iwl2qg9","_id":"ck8fkje9800199otsjaiq5sy2"},{"post_id":"ck8fkje9400159otsbqtdbve6","tag_id":"ck8fkje77000g9otslilt70dp","_id":"ck8fkje9b001b9otsthe14ta2"},{"post_id":"ck8fkje9000119ots1pbcwbyl","tag_id":"ck8fkje9500169otsejzd7gtq","_id":"ck8fkje9c001d9otseo1vffi2"},{"post_id":"ck8fkje98001a9ots30xlo04b","tag_id":"ck8fkje9500169otsejzd7gtq","_id":"ck8fkje9e001f9otsrtmzofd5"},{"post_id":"ck8fkje9b001c9otslxxdzkwm","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje9g001h9otskkwml1b9"},{"post_id":"ck8fkje9d001e9ots26mnfhc3","tag_id":"ck8fkje6g00029otskzpxjcit","_id":"ck8fkje9k001j9otso0mhxtzx"},{"post_id":"ck8fkje9l001k9otsvuzeg433","tag_id":"ck8fkje9x001m9otsvgb9b1dg","_id":"ck8fkjea5001q9otsdf4wiio7"},{"post_id":"ck8fkje9y001n9otsp3ot5nof","tag_id":"ck8fkjea5001p9ots7wyfx1f8","_id":"ck8fkjea6001r9otswlst3iwx"}],"Tag":[{"name":"android","_id":"ck8fkje6g00029otskzpxjcit"},{"name":"ios","_id":"ck8fkje77000g9otslilt70dp"},{"name":"android studio","_id":"ck8fkje7d000l9otsp0iddg4p"},{"name":"kotlin","_id":"ck8fkje8z00109ots9iwl2qg9"},{"name":"服务器","_id":"ck8fkje9500169otsejzd7gtq"},{"name":"node","_id":"ck8fkje9x001m9otsvgb9b1dg"},{"name":"生活","_id":"ck8fkjea5001p9ots7wyfx1f8"}]}}